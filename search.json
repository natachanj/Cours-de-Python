[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation avec Python: Analyse de données et Data visualisation",
    "section": "",
    "text": "6 sessions de 3 heures (18 heures au total)"
  },
  {
    "objectID": "index.html#contenu-du-cours",
    "href": "index.html#contenu-du-cours",
    "title": "Programmation avec Python: Analyse de données et Data visualisation",
    "section": "Contenu du cours",
    "text": "Contenu du cours\n\nIntroduction à Python\n\nPrésentation et installation\nVariables, types de données, opérateurs\n\nStructures de contrôle\n\nConditions (if, elif, else)\nBoucles (for, while)\nGestion des erreurs (try, except)\n\nLes fonctions\n\nDéfinir et appeler des fonctions\nParamètres, valeurs de retour\n\nManipulation de données avec pandas\n\nChargement de fichiers CSV/Excel\nNettoyage des données (valeurs manquantes, transformations)\nSélection et filtrage des données\n\nVisualisation des données\n\nGraphiques avec Matplotlib\nVisualisation avancée avec Seaborn\n\nProgrammation orientée objet (POO)\n\nDéfinition de classes, objets, méthodes\n\nIntroduction au Machine Learning avec Python\n\nBibliothèques essentielles : scikit-learn\nPréparation des données pour le ML (normalisation, division en train/test)\nModèles supervisés : régression linéaire et classification (KNN)\nÉvaluation des modèles : métriques (MAE, R², précision, rappel)\nNotions de surapprentissage et régularisation\n\nProjet final\n\nNettoyage, exploration, visualisation et modélisation d’un dataset"
  },
  {
    "objectID": "index.html#correction-des-tp",
    "href": "index.html#correction-des-tp",
    "title": "Programmation avec Python: Analyse de données et Data visualisation",
    "section": "Correction des TP",
    "text": "Correction des TP\n\nSéance 1 : Introduction à Python\n\nTP1 :\n\nÉcrire un programme pour manipuler des types simples (nombres, chaînes).\nImplémenter un calcul d’aire et périmètre de figures géométriques.\nAjouter une fonction pour vérifier si un mot est un palindrome.\n\n\n\n\nSéance 2 : Structures de contrôle\n\nTP2 :\n\nCréer un programme pour afficher les nombres premiers dans une plage donnée.\nÉcrire des scripts utilisant des boucles imbriquées (tables de multiplication).\nAjouter la gestion d’erreurs pour une division par zéro.\n\n\n\n\nSéance 3 : Manipulation de données avec pandas\n\nTP3 :\n\nCharger un dataset CSV.\nNettoyer les données (valeurs manquantes, doublons).\nAppliquer des filtres conditionnels pour extraire des sous-ensembles.\nEffectuer des statistiques descriptives simples (mean, std, min, max).\n\n\n\n\nSéance 4 : Visualisation des données\n\nTP4 :\n\nCréer des histogrammes et des scatterplots avec Matplotlib.\nUtiliser Seaborn pour tracer des heatmaps et analyser des corrélations.\nPersonnaliser des graphiques (titres, étiquettes, couleurs).\n\n\n\n\nSéance 5 : Programmation orientée objet (POO)\n\nTP5 :\n\nImplémenter une classe pour gérer les données d’un étudiant (nom, notes, moyenne).\n\nAjouter des méthodes pour calculer la moyenne et vérifier la réussite.\n\nÉtendre la classe avec des attributs supplémentaires (matières optionnelles).\n\n\n\n\nSéance 6 : Machine Learning avec Python\n\nTP6 :\n\nCharger un dataset (pandas) et le préparer pour le Machine Learning (normalisation, séparation train/test).\n\nImplémenter un modèle de régression linéaire pour prédire une variable cible.\n\nUtiliser un modèle de classification (KNN) pour classer des données.\n\nÉvaluer les performances avec des métriques comme R², précision et rappel."
  },
  {
    "objectID": "doc/cours/introduction.html",
    "href": "doc/cours/introduction.html",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle.\n\n\n\n\nPython est un langage interprété, open source, et multiplateforme.\nCréé par Guido van Rossum en 1989 (première version en 1991).\nPoints forts :\n\nSyntaxe simple et lisible.\nLarge écosystème de bibliothèques.\n\n\n\n\n\n\n\nPratique régulière : Codez régulièrement pour solidifier vos bases.\nExplorez des projets simples : Calculatrice, jeu de devinettes, gestion d’inventaire.\nUtilisez les ressources disponibles :\n\nDocumentation officielle : python.org/doc.\nPlateformes d’exercices : LeetCode, Hackerrank.\n\n\n\n\n\n\n\n\n\nTéléchargez Python depuis python.org.\n\n\n\n\n\n\n\n\nQu’est-ce que VS Code ?\n\nUn éditeur de code léger, puissant et extensible, développé par Microsoft.\n\nIdéal pour écrire et exécuter des scripts Python grâce à ses extensions.\n\nInstaller VS Code :\n\nTéléchargez-le sur code.visualstudio.com.\n\nInstallez l’extension Python via le Visual Studio Code Marketplace :\n\nOuvrez VS Code.\nAllez dans l’onglet des extensions (icône avec des blocs).\nRecherchez Python et cliquez sur “Installer”.\n\n\n\n\n\n\n\n\nQu’est-ce qu’Anaconda ?\n\nUne distribution Python incluant Jupyter Notebook, des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.) et un gestionnaire d’environnements.\n\nIdéal pour la data science et le machine learning.\n\nInstaller Anaconda :\n\nTéléchargez-le depuis anaconda.com.\n\nSuivez les instructions pour votre système d’exploitation (Windows, macOS, Linux).\n\nAvantages :\n\nConfiguration simplifiée pour débuter.\n\nGestion facile des environnements virtuels avec conda.\n\n\n\n\n\n\n\nQu’est-ce que Jupyter Notebook ?\n\nUn environnement interactif où vous pouvez écrire et exécuter du code Python dans des blocs (appelés “cellules”).\n\nIdéal pour la data science et les visualisations.\n\nInstaller Jupyter Notebook :\n\nSi vous avez Anaconda, Jupyter est préinstallé.\n\nSinon, installez-le avec pip :\npip install notebook\n\n\n\n\n\n\n\nQu’est-ce que Google Colab ?\n\nUn environnement en ligne gratuit pour coder en Python, développé par Google.\n\nAucun besoin d’installer Python ou Jupyter : tout fonctionne dans votre navigateur.\n\nAvantage : accès à des GPU gratuits pour le machine learning.\n\nAccéder à Google Colab :\n\nRendez-vous sur colab.research.google.com.\n\nConnectez-vous avec un compte Google.\n\nCréez un nouveau notebook en cliquant sur New Notebook.\n\nFonctionnalités clés :\n\nSauvegarde automatique sur Google Drive.\n\nSupport intégré des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.).\n\n\n\n\n\n\n\n\nPython est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python.\n\n\nUne variable est un conteneur permettant de stocker des données. En Python, il suffit de nommer la variable et d’y attribuer une valeur :\nx = 5\ny = \"Python\"\nprint(x, y)\n\n\n\n\nDans un script Python, tout ce qui suit le caractère # est ignoré par l’interpréteur jusqu’à la fin de la ligne. Ces lignes sont appelées commentaires et sont destinées à expliquer le code dans un langage humain.\n\n\n\n\nClarifier le code : Expliquez des portions complexes pour vous ou d’autres développeurs.\nDocumenter le fonctionnement : Fournir des indications sur le rôle d’un morceau de code ou d’une fonction.\nFaciliter la maintenance : Les commentaires rendent votre code plus compréhensible à long terme.\n\nLes commentaires ne sont pas exécutés par Python et n’affectent donc pas les performances du programme.\n\nPour ajouter un commentaire, commencez la ligne avec un #. Python ignorera tout ce qui suit ce caractère jusqu’à la fin de la ligne.\nExemple simple :\n# Ceci est un commentaire simple\nprint(\"Hello world!\")  # Affiche un message à l'écran\n\n# Déclaration de variables\nnom = \"Alice\"  # Nom de l'utilisateur\nage = 25       # Âge de l'utilisateur\n\n# Affichage des informations\nprint(f\"Nom : {nom}\")\nprint(f\"Âge : {age}\")\n\n# Cette partie affiche une salutation\nprint(\"Bonjour et bienvenue dans le cours de Python !\")\n\n\n\n\nSoyez concis et clair Vos commentaires doivent aller à l’essentiel et être compréhensibles.\n\n# Calcule la somme des éléments de la liste\ntotal = sum([1, 2, 3, 4])\n\nÉvitez les commentaires inutiles\n\nNe commentez pas des choses évidentes que le code lui-même exprime clairement.\nExemple inutile :\n# Attribue la valeur 5 à la variable x\nx = 5\n\nMettez à jour vos commentaires\n\nAssurez-vous que vos commentaires reflètent toujours le fonctionnement réel du code, surtout après des modifications.\n\n\n\n\nCommentaires sur une ligne\n\nIls s’écrivent avec # au début de la ligne.\n# Ce programme affiche un message\nprint(\"Bienvenue en Python !\")\n\nCommentaires multilignes\n\nPour commenter plusieurs lignes, vous pouvez utiliser # au début de chaque ligne ou une chaîne de caractères triple (\"\"\" ou ''') si le commentaire est temporaire.\n# Début du programme\n# Ce script montre un exemple\n# avec des commentaires multilignes.\nOu avec une chaîne triple :\n\"\"\"\nCe script illustre :\n- L'utilisation de variables\n- L'utilisation des commentaires\n\"\"\""
  },
  {
    "objectID": "doc/cours/introduction.html#introduction",
    "href": "doc/cours/introduction.html#introduction",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle.\n\n\n\n\nPython est un langage interprété, open source, et multiplateforme.\nCréé par Guido van Rossum en 1989 (première version en 1991).\nPoints forts :\n\nSyntaxe simple et lisible.\nLarge écosystème de bibliothèques.\n\n\n\n\n\n\n\nPratique régulière : Codez régulièrement pour solidifier vos bases.\nExplorez des projets simples : Calculatrice, jeu de devinettes, gestion d’inventaire.\nUtilisez les ressources disponibles :\n\nDocumentation officielle : python.org/doc.\nPlateformes d’exercices : LeetCode, Hackerrank.\n\n\n\n\n\n\n\n\n\nTéléchargez Python depuis python.org.\n\n\n\n\n\n\n\n\nQu’est-ce que VS Code ?\n\nUn éditeur de code léger, puissant et extensible, développé par Microsoft.\n\nIdéal pour écrire et exécuter des scripts Python grâce à ses extensions.\n\nInstaller VS Code :\n\nTéléchargez-le sur code.visualstudio.com.\n\nInstallez l’extension Python via le Visual Studio Code Marketplace :\n\nOuvrez VS Code.\nAllez dans l’onglet des extensions (icône avec des blocs).\nRecherchez Python et cliquez sur “Installer”.\n\n\n\n\n\n\n\n\nQu’est-ce qu’Anaconda ?\n\nUne distribution Python incluant Jupyter Notebook, des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.) et un gestionnaire d’environnements.\n\nIdéal pour la data science et le machine learning.\n\nInstaller Anaconda :\n\nTéléchargez-le depuis anaconda.com.\n\nSuivez les instructions pour votre système d’exploitation (Windows, macOS, Linux).\n\nAvantages :\n\nConfiguration simplifiée pour débuter.\n\nGestion facile des environnements virtuels avec conda.\n\n\n\n\n\n\n\nQu’est-ce que Jupyter Notebook ?\n\nUn environnement interactif où vous pouvez écrire et exécuter du code Python dans des blocs (appelés “cellules”).\n\nIdéal pour la data science et les visualisations.\n\nInstaller Jupyter Notebook :\n\nSi vous avez Anaconda, Jupyter est préinstallé.\n\nSinon, installez-le avec pip :\npip install notebook\n\n\n\n\n\n\n\nQu’est-ce que Google Colab ?\n\nUn environnement en ligne gratuit pour coder en Python, développé par Google.\n\nAucun besoin d’installer Python ou Jupyter : tout fonctionne dans votre navigateur.\n\nAvantage : accès à des GPU gratuits pour le machine learning.\n\nAccéder à Google Colab :\n\nRendez-vous sur colab.research.google.com.\n\nConnectez-vous avec un compte Google.\n\nCréez un nouveau notebook en cliquant sur New Notebook.\n\nFonctionnalités clés :\n\nSauvegarde automatique sur Google Drive.\n\nSupport intégré des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.)."
  },
  {
    "objectID": "doc/cours/introduction.html#premiers-pas-avec-python",
    "href": "doc/cours/introduction.html#premiers-pas-avec-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python.\n\n\nUne variable est un conteneur permettant de stocker des données. En Python, il suffit de nommer la variable et d’y attribuer une valeur :\nx = 5\ny = \"Python\"\nprint(x, y)\n\n\n\n\nDans un script Python, tout ce qui suit le caractère # est ignoré par l’interpréteur jusqu’à la fin de la ligne. Ces lignes sont appelées commentaires et sont destinées à expliquer le code dans un langage humain.\n\n\n\n\nClarifier le code : Expliquez des portions complexes pour vous ou d’autres développeurs.\nDocumenter le fonctionnement : Fournir des indications sur le rôle d’un morceau de code ou d’une fonction.\nFaciliter la maintenance : Les commentaires rendent votre code plus compréhensible à long terme.\n\nLes commentaires ne sont pas exécutés par Python et n’affectent donc pas les performances du programme.\n\nPour ajouter un commentaire, commencez la ligne avec un #. Python ignorera tout ce qui suit ce caractère jusqu’à la fin de la ligne.\nExemple simple :\n# Ceci est un commentaire simple\nprint(\"Hello world!\")  # Affiche un message à l'écran\n\n# Déclaration de variables\nnom = \"Alice\"  # Nom de l'utilisateur\nage = 25       # Âge de l'utilisateur\n\n# Affichage des informations\nprint(f\"Nom : {nom}\")\nprint(f\"Âge : {age}\")\n\n# Cette partie affiche une salutation\nprint(\"Bonjour et bienvenue dans le cours de Python !\")\n\n\n\n\nSoyez concis et clair Vos commentaires doivent aller à l’essentiel et être compréhensibles.\n\n# Calcule la somme des éléments de la liste\ntotal = sum([1, 2, 3, 4])\n\nÉvitez les commentaires inutiles\n\nNe commentez pas des choses évidentes que le code lui-même exprime clairement.\nExemple inutile :\n# Attribue la valeur 5 à la variable x\nx = 5\n\nMettez à jour vos commentaires\n\nAssurez-vous que vos commentaires reflètent toujours le fonctionnement réel du code, surtout après des modifications.\n\n\n\n\nCommentaires sur une ligne\n\nIls s’écrivent avec # au début de la ligne.\n# Ce programme affiche un message\nprint(\"Bienvenue en Python !\")\n\nCommentaires multilignes\n\nPour commenter plusieurs lignes, vous pouvez utiliser # au début de chaque ligne ou une chaîne de caractères triple (\"\"\" ou ''') si le commentaire est temporaire.\n# Début du programme\n# Ce script montre un exemple\n# avec des commentaires multilignes.\nOu avec une chaîne triple :\n\"\"\"\nCe script illustre :\n- L'utilisation de variables\n- L'utilisation des commentaires\n\"\"\""
  },
  {
    "objectID": "doc/cours/introduction.html#quest-ce-quune-variable",
    "href": "doc/cours/introduction.html#quest-ce-quune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.1 Qu’est-ce qu’une variable ?",
    "text": "2.1 Qu’est-ce qu’une variable ?\nUne variable est un conteneur permettant de stocker une valeur ou des données. En Python, une variable peut contenir différents types de données comme des nombres, du texte, ou des structures complexes."
  },
  {
    "objectID": "doc/cours/introduction.html#déclaration-dune-variable",
    "href": "doc/cours/introduction.html#déclaration-dune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.2 Déclaration d’une variable",
    "text": "2.2 Déclaration d’une variable\nEn Python, il suffit d’utiliser un nom valide et de lui assigner une valeur avec le symbole =.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\nage = 25        # Entier\npi = 3.14       # Nombre flottant\nest_actif = True  # Booléen"
  },
  {
    "objectID": "doc/cours/introduction.html#les-types-de-base-en-python",
    "href": "doc/cours/introduction.html#les-types-de-base-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.3 Les Types de Base en Python",
    "text": "2.3 Les Types de Base en Python\nPython propose plusieurs types de données de base, essentiels pour la manipulation des informations.\n\n\n\n\n\n\n### Comment connaître le type d’une variable en Python ?\n\n\nPython propose une fonction intégrée appelée type() pour déterminer le type de données d’une variable.\n\n\n\n\nUtilisation de type()\nLa fonction type() prend une variable en argument et retourne son type.\nExemples de types que vous pourriez rencontrer : - str : Chaîne de caractères - int : Entier - float : Nombre décimal - bool : Valeur logique\n\nCes types de base constituent les fondations des programmes en Python et sont utilisés dans presque tous les scripts.\n\n\nChaînes de caractères (str)\nLes chaînes de caractères permettent de stocker du texte. Elles peuvent être utilisées pour manipuler des mots, des phrases ou des caractères individuels.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\ntype(nom)\n\n\n\nEntiers (int)\nLes entiers représentent des nombres sans décimales, qu’ils soient positifs ou négatifs.\nExemple :\n# Déclaration de variables\nage = 25        # Entier\ntype(age)\n\n\n\nFlottants (float)\nLes flottants représentent des nombres avec des décimales, idéaux pour des calculs nécessitant des fractions. Exemple :\n# Déclaration de variables\npi = 3.14       # Nombre flottant\ntype(pi)\n\n\n\nBooléens (bool)\nLes booléens sont des valeurs logiques, pouvant être True (vrai) ou False (faux). Ils sont souvent utilisés pour effectuer des comparaisons ou contrôler le flux d’un programme. Exemple :\n# Déclaration de variables\nest_actif = True  # Booléen\ntype(est_actif)\n\n\n\nRésumé des types de base\n\n\n\nType\nDescription\n\n\n\n\nstr\nChaîne de caractères\n\n\nint\nNombres entiers\n\n\nfloat\nNombres décimaux\n\n\nbool\nValeurs logiques (True/False)"
  },
  {
    "objectID": "doc/cours/introduction.html#la-fonction-print",
    "href": "doc/cours/introduction.html#la-fonction-print",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.1 La fonction print()",
    "text": "3.1 La fonction print()\nprint() est utilisée pour afficher des informations dans la console. Elle permet de montrer le contenu de variables, des messages, ou des résultats de calcul.\nExemple :\nprint(valeur)"
  },
  {
    "objectID": "doc/cours/introduction.html#afficher-plusieurs-éléments",
    "href": "doc/cours/introduction.html#afficher-plusieurs-éléments",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.2 Afficher plusieurs éléments",
    "text": "3.2 Afficher plusieurs éléments\nVous pouvez afficher plusieurs éléments en même temps en les séparant par des virgules. Python ajoute automatiquement un espace entre ces éléments.\nExemple :\nprint(\"Bonjour\", \"Python\", 3.10)"
  },
  {
    "objectID": "doc/cours/introduction.html#formatage-des-chaînes",
    "href": "doc/cours/introduction.html#formatage-des-chaînes",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.3 Formatage des chaînes",
    "text": "3.3 Formatage des chaînes\nPour des affichages dynamiques et lisibles, plusieurs méthodes de formatage sont disponibles :\n\nConcaténation avec + : Combine des chaînes de caractères.\n\nnom = \"Alice\"\nprint(\"Bonjour, \" + nom)\n\nSubstitution avec f-strings : Insère directement des variables dans une chaîne avec une syntaxe claire.\n\nnom = \"Alice\"\nage = 25\nprint(f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\")\n\nMéthode format() : Insère des variables dans une chaîne avec des positions spécifiques.\n\nnom = \"Alice\"\nage = 25\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(nom, age))"
  },
  {
    "objectID": "doc/cours/introduction.html#caractères-spéciaux",
    "href": "doc/cours/introduction.html#caractères-spéciaux",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.4 Caractères spéciaux",
    "text": "3.4 Caractères spéciaux\nCertaines séquences spéciales permettent de modifier l’affichage : - \\\\n : Effectue un saut de ligne. - \\\\t : Ajoute une tabulation.\nCes caractères sont utiles pour structurer l’affichage dans la console.\nprint(\"Bonjour\\\\nPython\")\nprint(\"Nom:\\\\tAlice\")"
  },
  {
    "objectID": "doc/cours/introduction.html#contrôler-la-fin-de-laffichage",
    "href": "doc/cours/introduction.html#contrôler-la-fin-de-laffichage",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.5 Contrôler la fin de l’affichage",
    "text": "3.5 Contrôler la fin de l’affichage\nPar défaut, chaque appel à print() termine par un saut de ligne. Il est possible de modifier ce comportement pour afficher plusieurs éléments sur la même ligne.\nprint(\"Bonjour\", end=\" \")\nprint(\"Python !\")"
  },
  {
    "objectID": "doc/cours/introduction.html#résumé",
    "href": "doc/cours/introduction.html#résumé",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.6 Résumé",
    "text": "3.6 Résumé\n\n\n\n\n\n\n\nMéthode\nDescription\n\n\n\n\nprint()\nAffiche des données dans la console.\n\n\nConcaténation\nCombine plusieurs chaînes de caractères.\n\n\nf-strings\nInsère des variables directement dans une chaîne.\n\n\n.format()\nFormate une chaîne avec des variables.\n\n\nCaractères spéciaux\nModifie l’apparence (nouvelle ligne, tabulation)."
  },
  {
    "objectID": "doc/cours/introduction.html#les-structures-conditionnelles",
    "href": "doc/cours/introduction.html#les-structures-conditionnelles",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "4.1 Les Structures conditionnelles",
    "text": "4.1 Les Structures conditionnelles\nLes structures conditionnelles permettent d’exécuter des blocs de code uniquement si une condition est remplie.\n\n\nLa condition if\nLa condition if est utilisée pour vérifier si une expression est vraie. Si c’est le cas, le bloc de code associé est exécuté.\n\nSyntaxe de base\nif condition:\n    # Code à exécuter si la condition est vraie"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#introduction",
    "href": "doc/cours/introduction-slides.html#introduction",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Introduction",
    "text": "Introduction\nPython est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#premiers-pas-avec-python",
    "href": "doc/cours/introduction-slides.html#premiers-pas-avec-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Premiers pas avec Python",
    "text": "Premiers pas avec Python\nPython est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#quest-ce-quune-variable",
    "href": "doc/cours/introduction-slides.html#quest-ce-quune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Qu’est-ce qu’une variable ?",
    "text": "Qu’est-ce qu’une variable ?\nUne variable est un conteneur permettant de stocker une valeur ou des données. En Python, une variable peut contenir différents types de données comme des nombres, du texte, ou des structures complexes."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#déclaration-dune-variable",
    "href": "doc/cours/introduction-slides.html#déclaration-dune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Déclaration d’une variable",
    "text": "Déclaration d’une variable\nEn Python, il suffit d’utiliser un nom valide et de lui assigner une valeur avec le symbole =.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\nage = 25        # Entier\npi = 3.14       # Nombre flottant\nest_actif = True  # Booléen"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#les-types-de-base-en-python",
    "href": "doc/cours/introduction-slides.html#les-types-de-base-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Les Types de Base en Python",
    "text": "Les Types de Base en Python\nPython propose plusieurs types de données de base, essentiels pour la manipulation des informations.\n\n\n\n\n\n\n### Comment connaître le type d’une variable en Python ?\n\n\nPython propose une fonction intégrée appelée type() pour déterminer le type de données d’une variable."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#la-fonction-print",
    "href": "doc/cours/introduction-slides.html#la-fonction-print",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "La fonction print()",
    "text": "La fonction print()\nprint() est utilisée pour afficher des informations dans la console. Elle permet de montrer le contenu de variables, des messages, ou des résultats de calcul.\nExemple :\nprint(valeur)"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#afficher-plusieurs-éléments",
    "href": "doc/cours/introduction-slides.html#afficher-plusieurs-éléments",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Afficher plusieurs éléments",
    "text": "Afficher plusieurs éléments\nVous pouvez afficher plusieurs éléments en même temps en les séparant par des virgules. Python ajoute automatiquement un espace entre ces éléments.\nExemple :\nprint(\"Bonjour\", \"Python\", 3.10)"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#formatage-des-chaînes",
    "href": "doc/cours/introduction-slides.html#formatage-des-chaînes",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Formatage des chaînes",
    "text": "Formatage des chaînes\nPour des affichages dynamiques et lisibles, plusieurs méthodes de formatage sont disponibles :\n\nConcaténation avec + : Combine des chaînes de caractères.\n\nnom = \"Alice\"\nprint(\"Bonjour, \" + nom)\n\nSubstitution avec f-strings : Insère directement des variables dans une chaîne avec une syntaxe claire.\n\nnom = \"Alice\"\nage = 25\nprint(f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\")\n\nMéthode format() : Insère des variables dans une chaîne avec des positions spécifiques.\n\nnom = \"Alice\"\nage = 25\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(nom, age))"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#caractères-spéciaux",
    "href": "doc/cours/introduction-slides.html#caractères-spéciaux",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Caractères spéciaux",
    "text": "Caractères spéciaux\nCertaines séquences spéciales permettent de modifier l’affichage : - \\\\n : Effectue un saut de ligne. - \\\\t : Ajoute une tabulation.\nCes caractères sont utiles pour structurer l’affichage dans la console.\nprint(\"Bonjour\\\\nPython\")\nprint(\"Nom:\\\\tAlice\")"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#contrôler-la-fin-de-laffichage",
    "href": "doc/cours/introduction-slides.html#contrôler-la-fin-de-laffichage",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Contrôler la fin de l’affichage",
    "text": "Contrôler la fin de l’affichage\nPar défaut, chaque appel à print() termine par un saut de ligne. Il est possible de modifier ce comportement pour afficher plusieurs éléments sur la même ligne.\nprint(\"Bonjour\", end=\" \")\nprint(\"Python !\")"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#résumé",
    "href": "doc/cours/introduction-slides.html#résumé",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Résumé",
    "text": "Résumé\n\n\n\n\n\n\n\nMéthode\nDescription\n\n\n\n\nprint()\nAffiche des données dans la console.\n\n\nConcaténation\nCombine plusieurs chaînes de caractères.\n\n\nf-strings\nInsère des variables directement dans une chaîne.\n\n\n.format()\nFormate une chaîne avec des variables.\n\n\nCaractères spéciaux\nModifie l’apparence (nouvelle ligne, tabulation)."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#les-structures-conditionnelles",
    "href": "doc/cours/introduction-slides.html#les-structures-conditionnelles",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Les Structures conditionnelles",
    "text": "Les Structures conditionnelles\nLes structures conditionnelles permettent d’exécuter des blocs de code uniquement si une condition est remplie."
  },
  {
    "objectID": "doc/tp/tp1.html",
    "href": "doc/tp/tp1.html",
    "title": "Premières requêtes SQL",
    "section": "",
    "text": "Vous allez réaliser ce TP su un Datalab.\n\n\n\n\n\n\nLe Datalab en quelques mots\n\n\n\nUn TP dédié vous expliquera plus en détail ce qu’est le Datalab.\nLe Datalab permet aux utilisateurs de lancer facilement des services pour travailler avec des langages comme R ou Python, ou encore gérer des bases de données.\nIl offre une grande puissance de calcul, ce qui permet de traiter de gros volumes de données et de réaliser des analyses complexes sans se soucier des limites techniques.\nAvec cette plateforme :\n\nles utilisateurs accèdent aux ressources nécessaires en quelques clics\nsans devoir installer eux-mêmes les logiciels\nni configurer les serveurs\n\n\n\n\n\nConnectez-vous à l’une des 2 instances suivantes (elles sont quasiment identiques) :\n\nDatalab du GENES\nDatalab SSPCloud de l’INSEE\n\nen créant un compte avec votre mail ENSAI\n\n\n\n\n\n\n\n\nTip\n\n\n\nPour éviter les problèmes de charges :\n\nLes élèves fonctionnaires feront le TP sur le SSPCloud\nLes élèves ingénieurs ➡️ Datalab du GENES\n\n\n\n\n\n\n\n\n\n\n\n\nEn cas d’indisponibilité des Datalabs\n\n\n\nUniquement en cas d’indisponibilité des Datalabs, vous pouvez réaliser le TP directement sur la VM. Le logiciel DBeaver est installé.\n\n\n\nLancez DBeaver\nOnglet Base de données ➡️ Nouvelle Connexion\n\nType de connexion : DuckDB\nSuivant\nPath : :memory:\nTerminer\n\nDans l’explorer (à gauche), clic droit sur la connexion que vous venez de créer\n\nEditeur SQL ➡️ Script SQL (raccourci : F3)\n\n\nCela ouvre une fenêtre dans laquelle vous pouvez saisir du SQL."
  },
  {
    "objectID": "doc/tp/tp1.html#introduction",
    "href": "doc/tp/tp1.html#introduction",
    "title": "Premières requêtes SQL",
    "section": "",
    "text": "Vous allez réaliser ce TP su un Datalab.\n\n\n\n\n\n\nLe Datalab en quelques mots\n\n\n\nUn TP dédié vous expliquera plus en détail ce qu’est le Datalab.\nLe Datalab permet aux utilisateurs de lancer facilement des services pour travailler avec des langages comme R ou Python, ou encore gérer des bases de données.\nIl offre une grande puissance de calcul, ce qui permet de traiter de gros volumes de données et de réaliser des analyses complexes sans se soucier des limites techniques.\nAvec cette plateforme :\n\nles utilisateurs accèdent aux ressources nécessaires en quelques clics\nsans devoir installer eux-mêmes les logiciels\nni configurer les serveurs\n\n\n\n\n\nConnectez-vous à l’une des 2 instances suivantes (elles sont quasiment identiques) :\n\nDatalab du GENES\nDatalab SSPCloud de l’INSEE\n\nen créant un compte avec votre mail ENSAI\n\n\n\n\n\n\n\n\nTip\n\n\n\nPour éviter les problèmes de charges :\n\nLes élèves fonctionnaires feront le TP sur le SSPCloud\nLes élèves ingénieurs ➡️ Datalab du GENES\n\n\n\n\n\n\n\n\n\n\n\n\nEn cas d’indisponibilité des Datalabs\n\n\n\nUniquement en cas d’indisponibilité des Datalabs, vous pouvez réaliser le TP directement sur la VM. Le logiciel DBeaver est installé.\n\n\n\nLancez DBeaver\nOnglet Base de données ➡️ Nouvelle Connexion\n\nType de connexion : DuckDB\nSuivant\nPath : :memory:\nTerminer\n\nDans l’explorer (à gauche), clic droit sur la connexion que vous venez de créer\n\nEditeur SQL ➡️ Script SQL (raccourci : F3)\n\n\nCela ouvre une fenêtre dans laquelle vous pouvez saisir du SQL."
  },
  {
    "objectID": "doc/tp/tp1.html#lancement-du-service",
    "href": "doc/tp/tp1.html#lancement-du-service",
    "title": "Premières requêtes SQL",
    "section": "1 Lancement du service",
    "text": "1 Lancement du service\n\n\n\n\n\n\nNote\n\n\n\nUniquement sur le Datalab.\n\n\n\nLancez le service CloudBeaver\n\nAllez dans Catalogue de services\nOnglet Databases\n\n\n\n\n\n\n\n\nCloudBeaver\n\n\n\nCloudBeaver est une application web légère dédiée à la gestion de bases de données. Elle permet de se connecter à divers types de bases de données, qu’elles soient SQL, NoSQL ou hébergées dans le cloud, à partir d’un seul point d’accès via un navigateur. CloudBeaver facilite l’exploration, la modification et la visualisation des données sans nécessiter l’installation de logiciels locaux.\nElle offre également des fonctionnalités de sécurité pour protéger l’accès aux données. Son interface conviviale en fait un outil accessible aussi bien aux développeurs qu’aux analystes de données.\n\n\nPour ce premier TP, nous n’allons pas utiliser de base de données PostgreSQL. Nous allons simplement utiliser DuckDB pour lire des fichiers de données.\n\n\n\n\n\n\nDuckDB\n\n\n\nDuckDB est un moteur de base de données relationnelle conçu pour des analyses rapides et efficaces.\nDuckDB est idéal pour les charges de travail analytiques en raison de sa simplicité, de sa rapidité et de son extensibilité, surtout pour traiter des fichiers volumineux localement.\n\n\n\n\n\n\n\nCaractéristique\nDescription\n\n\n\n\nSimplicité\nFonctionne sans serveur, intégré dans le processus hôte. Aucune dépendance externe pour la compilation ou l’exécution, simplifiant son déploiement.\n\n\nRapidité\nOptimisé pour l’analytique (OLAP) avec un moteur d’exécution vectorisé en colonnes, réduisant le temps de traitement pour les requêtes complexes.\n\n\nRichesse fonctionnelle\nSupporte des requêtes SQL complexes, fonctions de fenêtre, index secondaires, et assure des garanties ACID grâce au contrôle de concurrence (MVCC).\n\n\nExtensibilité\nPermet l’ajout de types de données, fonctions et formats de fichiers via des extensions (supporte Parquet, JSON, S3, HTTP(S)).\n\n\nGratuit et open-source\nLicence MIT, code source disponible et contributions ouvertes à tous.\n\n\n\n\n\n\nCréez une nouvelle connexion DuckDB\n\nEn haut à gauche, cliquez sur le +, puis New connection\nSélectionner DuckDB\nCliquez sur le bouton CREATE\n\nOuvrez un éditeur SQL\n\nDans l’explorer à gauche, clic droit sur votre connection DuckDB ➡️ SQL Editor\nvous pouvez maintenant saisir du code SQL"
  },
  {
    "objectID": "doc/tp/tp1.html#les-prénoms",
    "href": "doc/tp/tp1.html#les-prénoms",
    "title": "Premières requêtes SQL",
    "section": "2 Les prénoms",
    "text": "2 Les prénoms\nLe fichier des prénoms contient des données sur les prénoms attribués aux enfants nés en France depuis 1900. Ces données sont disponibles au niveau France et par département.\nDans ce TP, nous allons utiliser la version au format parquet, mise à disposition sur le site data.gouv par Icem7.\n\n\n\n\n\n\nFichier parquet\n\n\n\nLe format Parquet est un format de fichier de stockage de données optimisé pour les systèmes de traitement analytique de grande échelle. Voici ses principales caractéristiques :\n\nStockage en colonnes : Parquet stocke les données par colonnes plutôt que par lignes, ce qui améliore l’efficacité de l’accès aux données dans les charges de travail analytiques.\nCompression efficace : La compression par colonne permet un taux de compression moyen de 5 à 10 fois par rapport aux formats CSV, voire plus pour de gros fichiers. Cela réduit significativement la taille des données stockées et le coût de stockage.\nOptimisé pour l’analytique : Parquet est conçu pour les requêtes en lecture intensive, car il permet de charger uniquement les colonnes nécessaires pour une analyse, ce qui améliore les performances en particulier sur les données volumineuses.\nMétadonnées Riches et Auto-descriptives : Parquet inclut des métadonnées détaillées (schéma, types de données, statistiques min/max), permettant une lecture rapide et sans risque d’erreur. Ces métadonnées facilitent également le traitement des données par différents outils.\nLangage Indépendant et Open Source : Le format Parquet est indépendant du langage et peut être utilisé avec divers langages de programmation (Python, R, C++, Java). Il est aussi open source et compatible avec la plupart des frameworks de big data.\n\n\n\nPour en savoir plus sur le format Parquet :\n\nParquet, qu’est-ce que c’est ?, Databricks\nWhat is the Parquet File Format?, Upsolver blog\n\n\n\nCréez une vue prenom qui pointera vers le fichier parquet des prénoms\nCREATE OR REPLACE VIEW prenom AS\nFROM 'https://static.data.gouv.fr/resources/base-prenoms-insee-format-parquet/20231121-161435/prenoms-nat2022.parquet'\n\nVous pourrez ensuite requêter sur cette vue comme si c’était une table\n\n\n\n\n\n\n\n\nÉxécuter une requête\n\n\n\nCliquez sur la requête pour y positionner le pointeur de la souris, puis au choix :\n\nCliquez sur le petit triangle orange\nCTRL + ENTREE\n\n\n\n\n2.1 Premières requêtes\n\n\n\n\n\n\nImportant\n\n\n\nPrenez le temps et l’habitude d’écrire de jolies requêtes bien alignées !!!\n\n\nbien.sql\n\nSELECT c.nom AS club, \n       AVG(j.elo) AS moyenne_elo\n  FROM joueuse j \n INNER JOIN club c USING (id_club) \n WHERE j.mail IS NOT NULL \n GROUP BY c.nom \n ORDER BY 2 DESC;\n\n\n\n\npasbien.sql\n\nSELECT c.nom AS club, AVG(j.elo) AS moyenne_elo FROM joueuse j INNER JOIN club c USING (id_club) WHERE mail IS NOT NULL GROUP BY c.nom ORDER BY 2 DESC;\n\n\n\n\nListez tous les éléments de prenom\nFiltrez pour ne plus afficher les prénoms rares\n\n\n\n\n\n\n\nSecret statistique\n\n\n\nLes prénoms ayant un nombre insuffisant d’occurrences sont regroupés sous une appellation générique. Cela permet de protéger le secret statistique et de garantir l’anonymat.\nSans cette précaution, par exemple :\n\nsi vous vous appeliez Yann-Adam LEFGRIGO\net que vous êtes le seul à porter ce prénom\nn’importe qui pourrait connaître votre année de naissance\n\nDe même, si vous êtiez 2 à porter ce prénom, l’autre Yann-Adam connaitrait aussi votre année de naissance. Ce n’est toujours pas satisfaisant. Il faut donc à minima 3 individus pour garantir l’anonymat.\n\n\n\nDe quel type est le champ annais ? Pourquoi ?\nListez les différentes années de naissance\n\nClassez-ces années en décroissant\nQue remarquez-vous ?\n\nAjoutez un filtre pour exclure l’année non renseignée\n\n\n\n2.2 Année 2022\n\n\n\n\n\n\nFiltrez sur l’année 2022 et excluez les prénoms rares.\n\n\n\n\nListez les prénoms de l’année 2022\n\nClassez-les en décroissant par le nombre de fois où ils sont été donnés\n\nListez les prénoms de l’année 2022 donnés plus de 2000 fois\nClassez-les d’abord par sexe, puis par nombre décroissant d’occurrences\n\nQuels sont les prénoms masculins et féminins les plus donnés ?\n\nListez les prénoms féminins commençant par la lettre Q\nCompter le nombre de prénoms commençant par chaque lettre\n\nPour extraite la première lettre d’un prénom, vous pouvez par exemple utiliser la fonction SUBSTRING\nBonus : différenciez filles et garçons\n\n\n\n\n2.3 Statistiques descriptives\n\nLancez la commande SUMMARIZE prenom; pour avoir quelques stats sur la table\n\n\n\n\n\n\n\nFiltrez pour exclure les prénoms rares.\n\n\n\n\nAffichez pour l’année 2003, les prénoms et leurs nombres de caractères\n\nTrouvez une fonction adéquate\n\nAffichez le nombres de caractères minimum, maximum et moyen parmi les prénoms de 2003\nListez les 3 prénoms de 2003 ayant le nombre de caractères maximum\nModifiez cette dernière requête pour afficher pour chaque année entre 2015 et 2022 le ou les prénoms avec le plus de caractères\n\nclassez par année\nDifficulty : ⭐ ⭐ ⭐\n\nAffichez pour chaque année la taille moyenne des prénoms\n\nclassez par année\nutilisez la fonction ROUND(&lt;value&gt;, 2) pour arrondir les moyennes\nQue remarquez-vous ?\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nDans cette partie vous allez avoir besoin d’utiliser des sous-requêtes\n\n\n\n\n\n2.4 Jérôme, c’est moi\n\nListez les différentes années où le prénom JÉRÔME a été donné\n\nclassez par année décroissante\nQue remarquez-vous ?\n\nListez également les JEROME avec d’autres accents / sans accent\n\nrecherchez une fonction DuckDB qui permet de répondre à ce besoin\n\nAffichez pour chaque année le nombre de fois où le prénom JEROME a été donné, quelle que soit l’accentuation\n\n\n\n\n\n\n\nAide\n\n\n\n\n\n\nvoir Fontion DuckDB strip_accents()\nRegroupez par strip_accents(preusuel) et annais\nAffichez strip_accents(preusuel), annais et la somme de la colonne nombre\n\n\n\n\n\n\n2.5 Suivi temporel\n\n\n\n\n\n\nFiltrez pour exclure l’année XXXX.\n\n\n\n\nCréez une requête qui permet d’avoir le nombre de naissances par année depuis l’année 2000\n\nClassez par année décroissante\n\nComplétez la requête pour afficher le nombre de prénoms différents données chaque année\n\nRemarque : vous n’aurez pas le nombre exact car certains sont dans les prénoms rares\n\nÉcrivez une requête qui donne le nombre de filles et de garçons nés chaque année depuis 2000\n\n\n\n\n\n\n\nNote\n\n\n\nMême si le champ annais n’est pas de type numérique, il est possible de comparer des chaines de caractères.\nLe code ASCII est utilisé pour comparer le premier caractère de la chaine, puis en cas d’égalité, le 2e caractère…\n\n\n\n\n2.6 Prénoms composés\nNous allons maintenant nous interesser aux prénoms composés entre 2000 et 2009\n\nListez les prénoms composés entre les années 2000 et 2009 incluses\nRegroupez-les par preusuel, puis affichez également le nombre de fois où ils ont été donnés\n\nTriez en décroissant par ce nombre\n\nFiltrez pour ne garder que les prénoms composés contenant le prénom JEAN\n\nQue remarquez-vous ? N’y a-t-il pas des intrus ?\n\nTrouvez une solution pour remédier à ce souci\n\nPar exemple avec la fonction DuckDB split_part()\n\n\n\n\n2.7 Cette année-là\n\n\n\n\n\n\nDifficulty : ⭐ ⭐ ⭐\nFiltrez sur l’année 1962 et excluez les prénoms rares.\n\n\n\n\nComptez le nombre de prénoms distincts donnés\nComplétez en comptant le nombre de prénoms distincts donnés par sexe\nComplétez en calculant le nombre total des prénoms distincts donnés, en prenant en compte la distinction entre les sexes\n\nexemple : ici Dominique (H) et Dominique (F) comptent pour 2 prénoms\n\nDonnez la liste des prénoms donnés à la fois à des filles et des garçons\n\naffichez le nombre de fois où ils ont été donnés à chaque sexe\n\nAjoutez à la dernière requête une colonne contenant un booléen qui affiche\n\nTrue si le prénom a été donné à plus de filles que de garçons\nFalse sinon\n\nAu lieu d’afficher ce booléen, ajoutez une condition pour n’afficher que lorsque le prénom a été plus donné à des filles"
  },
  {
    "objectID": "doc/tp/tp1.html#fichier-des-individus",
    "href": "doc/tp/tp1.html#fichier-des-individus",
    "title": "Premières requêtes SQL",
    "section": "3 Fichier des individus",
    "text": "3 Fichier des individus\n\nCréez une vue qui pointe vers le fichier des individus du recensement de la population 2020\nCREATE OR REPLACE VIEW individus AS\nFROM 'https://static.data.gouv.fr/resources/recensement-de-la-population-fichiers-detail-individus-localises-au-canton-ou-ville-2020-1/20231023-122841/fd-indcvi-2020.parquet';\nComptez le nombre d’individus\n\nPourquoi ce nombre d’individus vivant en France paraît faible ?\n\n\n\n\n\n\n\n\nPoids de l’individu\n\n\n\nDans de nombreuses bases de données de l’INSEE, la variable ipondi représente le poids de l’individu.\ni.e. Si une ligne a un IPONDI égal à 2, cela signifie qu’elle représente 2 individus.\n\n\n\nAu lieu de compter le nombre de lignes, sommez la variable ipondi\n\nVous pouvez suffixer votre somme par ::INT pour convertir ce nombre en entier\n\nAffichez 10 lignes\n\nQue remarquez-vous ?\n\n\n\n\n\n\n\n\nCodification\n\n\n\nPourquoi utiliser une codification pour le fichier national individus localisés au canton-ou-ville du recensement de la population 2020 ?\n\nEspace de stockage réduit : Les codes courts remplacent des chaînes de texte plus longues, ce qui diminue la taille du fichier et rend le stockage et le transfert de données plus efficaces. Même après codification, le fichier pèse plus de 500 Mo\nStandardisation et uniformité : Utiliser des codes standardisés permet de garantir une structure homogène et facilite l’intégration et la comparaison des données entre différents fichiers ou études.\nPerformances de traitement : Les codes sont plus rapides à traiter que des textes longs, notamment pour des opérations de recherche, de tri, et de filtrage, ce qui est crucial pour les grands ensembles de données.\n\n\n\n\nPour s’y retrouver, créez une vue vers le dictionnaire des variables\nCREATE OR REPLACE VIEW variables_individus AS\nFROM 'https://static.data.gouv.fr/resources/recensement-de-la-population-fichiers-detail-individus-localises-au-canton-ou-ville-2020-1/20231025-082910/dictionnaire-variables-indcvi-2020.csv'\nAffichez tout le contenu de cette vue\nTrouvez la modalité représentant le département de résidence de l’individu\nAffichez le nombre d’habitants par départements\n\nordonnez par numéro de département\n\nComplétez la requête en :\n\nrestreignant sur les individus entre 25 et 29 ans\ndifférenciant les hommes et les femmes"
  },
  {
    "objectID": "doc/tp/tp1.html#arrêtez-votre-service",
    "href": "doc/tp/tp1.html#arrêtez-votre-service",
    "title": "Premières requêtes SQL",
    "section": "Arrêtez votre service",
    "text": "Arrêtez votre service\nC’est la fin du TP, vous pouvez maintenant sauvegarder votre travail et libérer les ressources réservées :\n\nCopiez votre code et collez le sur votre machine dans un fichier .sql\n\npar exemple dans P:/Cours1A/UE3-Bases-de-donnees-relationnelles/TP1/tp1.sql\n\nRetournez sur la page d’accueil du Datalab\nAllez dans Mes Services et supprimez votre service"
  },
  {
    "objectID": "doc/tp/tp1.html#pour-aller-plus-loin",
    "href": "doc/tp/tp1.html#pour-aller-plus-loin",
    "title": "Premières requêtes SQL",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\n\n3 explorations bluffantes avec DuckDB"
  },
  {
    "objectID": "doc/tp/tp4.html",
    "href": "doc/tp/tp4.html",
    "title": "Chess Unofficial Federation",
    "section": "",
    "text": "Important\n\n\n\n\nÉcrivez des requêtes jolies !\n\n\n\nCe sujet vous occupera pour les TP4 et 5."
  },
  {
    "objectID": "doc/tp/tp4.html#introduction",
    "href": "doc/tp/tp4.html#introduction",
    "title": "Chess Unofficial Federation",
    "section": "",
    "text": "Important\n\n\n\n\nÉcrivez des requêtes jolies !\n\n\n\nCe sujet vous occupera pour les TP4 et 5."
  },
  {
    "objectID": "doc/tp/tp4.html#lancement-des-services",
    "href": "doc/tp/tp4.html#lancement-des-services",
    "title": "Chess Unofficial Federation",
    "section": "1 Lancement des services",
    "text": "1 Lancement des services\nConnectez-vous à l’une des 2 instances suivantes d’Onyxia (elles sont quasiment identiques) :\n\nDatalab du GENES\nDatalab SSPCloud de l’INSEE\n\nsi besoin de créer un compte, utilisez votre mail ENSAI\n\n\nEt ensuite lancez les services suivants (voir TP2 si besoin de plus de détails)\n\nPostgreSQL : Datalab GENES ou SPPCloud\nCloudBeaver"
  },
  {
    "objectID": "doc/tp/tp4.html#les-données",
    "href": "doc/tp/tp4.html#les-données",
    "title": "Chess Unofficial Federation",
    "section": "2 Les données",
    "text": "2 Les données\n\n\n\n\n\n\nVotre mission du jour sera d’aider la nouvellement créée Fédération Française des Échecs Sincéres et Sans Subterfuges à corriger les erreurs dans sa base de données pour ensuite récompenser ses meilleures joueuses.\n\n\n\n\n2.1 Chargez les données\n\nCopiez le contenu de ces 2 scripts sql\n\ncréation des tables\ninsertion des données\n\nCollez-les dans la fenêtre SQL de CloudBeaver\nExécutez les scripts\n\nCliquez sur la petite icone sous les triangles oranges qui ressemble à 📜\nraccourci (ALT + X)\n\n\n\n\n\n\n\n\nReprise TP5\n\n\n\nAprès avoir chargé les données pour le TP5, veuillez appliquer ces corrections vues lors d’un exercice du TP4 :\nUPDATE echecs.joueuse\n   SET elo = elo - 1200\n WHERE elo &gt; 2600\n   AND code_titre IS NULL;\n\nUPDATE echecs.joueuse\n   SET date_naissance = date_naissance + INTERVAL '100 years'\n WHERE id_joueuse IN (111, 122, 133, 144);\n\nUPDATE echecs.joueuse\n   SET date_naissance = date_naissance - INTERVAL '100 years'\n WHERE id_joueuse IN (155, 166, 177, 188);\n\nUPDATE echecs.joueuse\n   SET nom = REPLACE(REPLACE(REPLACE(nom, 'EUH', 'E'), 'AO', 'A'), 'OU', 'U')\n WHERE code_titre IS NULL;\n\nDELETE FROM echecs.partie\n WHERE id_blanc = id_noir;\n\n\n\n\n2.2 Description\nLes tables sont les suivantes :\n\njoueuse(id_joueuse, code_titre, nom, prenom, elo, date_naissance, #id_club, arbitre)\ntitre(code, nom, description)\nclub(id_club, nom, ville, #id_presidente)\npartie(id_partie, #id_blanc, #id_noir, date_partie, #id_resultat, #id_ouverture, #id_tournoi)\nresultat_partie(id_resultat, resultat, description)\nouverture(id_ouverture, eco, nom, coups)\ntournoi(id_tournoi, nom, ville, date_debut, date_fin, #id_cadence, nb_rondes, nb_participantes, #id_arbitre)\ncadence(id_cadence, nom, description)\n\n\n\n\n\n\n\n\nCatégorie\nDescription\n\n\n\n\nJoueuse\nListe des joueuses\n\n\nTitre\nListe des titres, certains attribués aux fortes joueuses\n\n\nClub\nListe des clubs\n\n\nPartie\nPartie entre 2 joueuses, soit libre, soit dans le cadre d’un tournoi\n\n\nRésultat_partie\nDifférents résultats possibles dans une partie (par exemple : victoire des blancs, match nul, etc.)\n\n\nOuverture\nDésignation de l’ouverture (comment débute une partie)\n\n\nTournoi\nListe des tournois\n\n\nCadence\nRythme de jeu lors d’un tournoi (blitz, rapide, lent)\n\n\n\n\n\n2.3 Modèle de données\n\n\n\n\n\n\nCaution\n\n\n\nDans le modèle de données, certaines tables sont reliées 2 fois entre elles :\n\njoueuse et partie : car lors d’une partie une joueuse a les blancs et l’autre, les noirs\njoueuse et club :\n\nid_club est une clé étrangère dans la table joueuse car une joueuse est membre d’un seul club\nid_presidente est une clé étrangère de la table club référençant l’id_joueuse de la présidente"
  },
  {
    "objectID": "doc/tp/tp4.html#recherche-des-irrégularités",
    "href": "doc/tp/tp4.html#recherche-des-irrégularités",
    "title": "Chess Unofficial Federation",
    "section": "3 Recherche des irrégularités",
    "text": "3 Recherche des irrégularités\n\n\n\n\n\n\nÀ la fédération, il y a malheureusement de nombreuses rumeurs de corruption, et même de dopage !\nVotre première mission sera de vérifier l’intégrité des données de la base.\n\n\n\nIl paraîtrait que certaines joueuses aient truquées leurs classements elo. Vérifiez et corrigez cela :\n\nListez la table des joueuses\nClassez par elo décroissant\nÉcrivez une requête qui permet d’afficher les joueuses avec un elo suspect (elo &gt; 2600 et non titrée)\n\nNotez leurs id_joueuse\n\nPour chacune de ces joueuses, diminuez leur elo de 1200\nVérifier à partir de leurs id_joueuse que la mise à jour a bien été effectuée\n\nUne autre erreur concernerait les dates de naissances des joueuses\n\nAffichez l’année de naissance des joueuses\nRegroupez par année et comptez le nombre d’occurences\nÉcrivez une requête pour ne garder que les joueuses avec des années de naissances étranges\nApportez une correction adaptée\n\nToujours sur la table des joueuses, vous avez peut-être remarqué qu’une puissante technique d’anonymisation a été utilisée.\n\nCommencez par afficher dans un SELECT une version plus propre\nUne fois que le résultat est assez correct, mettez à jour la table joueuse\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nVous pouvez utiliser la fonction REPLACE()\n\net même les enchainer : REPLACE(REPLACE(REPLACE()))\n\nAttention : les noms des joueuses titrées n’ont pas été anonymisées\n\nSi vous souhaitez utiliser des techniques d’anonymisation un peu plus efficaces, rendez-vous en 3A pour les Master ID et STD.\n\n\n\nPassons maintenant à la table des parties. À votre avis, est-ce normal de jouer des parties contre soi-même ?\n\nDétectez les parties suspectes\nÀ partir de ces données, créez une table tricheuse pour pouvoir surveiller leurs agissements par la suite\nSupprimez les parties suspectes"
  },
  {
    "objectID": "doc/tp/tp4.html#élection-des-présidentes",
    "href": "doc/tp/tp4.html#élection-des-présidentes",
    "title": "Chess Unofficial Federation",
    "section": "4 Élection des présidentes",
    "text": "4 Élection des présidentes\n\n\n\n\n\n\nVous avez peut-être remarqué que les clubs n’ont pas de présidentes, nous allons donc organiser des élections sans triche !\nMais pour faire plus simple, la fédé a décidé de nommer comme présidente de chaque club, sa joueuse ayant le plus faible elo.\n\n\n\n\nListez pour chaque club, ses joueuses\n\naffichez le nom du club, ainsi que tout le contenu de la table joueuse\n\nPour chaque club, trouvez le elo minimum\nStockez dans une table temporaire tous les couples (id_club, elo_minimum)\nTrouvez pour chaque club, la joueuse avec le plus petit elo\n\nen cas d’égalité, prenez ensuite le plus petit id_joueuse\n\nStockez dans une table temporaire les couples (id_club, id_joueuse de la future présidente)\nMettez à jour la table club avec leurs nouvelles présidentes\nListez les clubs et leurs présidentes"
  },
  {
    "objectID": "doc/tp/tp4.html#remise-en-route-tp5",
    "href": "doc/tp/tp4.html#remise-en-route-tp5",
    "title": "Chess Unofficial Federation",
    "section": "5 Remise en route TP5",
    "text": "5 Remise en route TP5\nQuelques questions faciles pour se remettre en route.\n\nAffichez noms, prénoms, elo des joueuses ainsi que le nom de leur club. Ordonnez par elo décroissant\n\nCombien avez-vous de lignes ?\nCombien de lignes compte la table joueuse ?\n\nAffichez tous les noms, prénoms, elo des joueuses ainsi que leur éventuel nom de club\nAjoutez à la précédente requête l’éventuel nom du titre de la joueuse"
  },
  {
    "objectID": "doc/tp/tp4.html#quelques-statistiques",
    "href": "doc/tp/tp4.html#quelques-statistiques",
    "title": "Chess Unofficial Federation",
    "section": "6 Quelques statistiques",
    "text": "6 Quelques statistiques\n\n\n\n\n\n\nRegardons maintenant quelques statistiques sur ces données.\n\n\n\n\nComptez le nombre de parties jouées\nAffichez le nombre de parties jouées par tournoi\n\naffichez le nom du tournoi\nincluez les parties jouées hors tournoi\n\nPour chaque tournoi, calculez également les taux de victoire des blancs et des noirs, ainsi que celui de matchs nuls\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nCommencez par exemple par calculer le nombre de victoires des blancs\nDivisez par le bon nombre\nPour avoir un float, vous pouvez multiplier par 1.0\nUtilisez ROUND() pour arrondir à 2 chiffres significatifs\n\n\n\n\n\nComplétez pour ne conserver que les tournois avec 20 % ou moins de matchs nuls\n\nJetons maintenant un oeil aux ouvertures qui permettent de gagner plus souvent\n\n\n\n\n\n\nOuvertures\n\n\n\nEn début de partie, le nombre de coups possibles et corrects reste assez limité. Les différentes possibilités de commencer une partie sont catégorisées et appelées Ouvertures.\nVient ensuite le milieu de jeu lorsque toutes les pièces sont développées.\nEt enfin (si personne ne s’est pris un échec et mat) la finale, i.e. lorsque les Dames ont été échangées et qu’il reste peu de pièces.\n\n\n\nUne des ouvertures n’existe pas, elle n’a été jouée dans aucune partie\n\nTrouvez et supprimez cette ouverture\n\nComme fait précédemment pour les tournois, calculez pour chaque ouverture :\n\nnombre de parties jouées\ntaux de victoire des blancs\ntaux de victoire des noirs\ntaux de matchs nuls\n\nAffichez les joueuses ayant joué plus de 5 fois avec les pièces noires la Défense Sicilienne"
  },
  {
    "objectID": "doc/tp/tp4.html#afficher-les-résultats-de-parties",
    "href": "doc/tp/tp4.html#afficher-les-résultats-de-parties",
    "title": "Chess Unofficial Federation",
    "section": "7 Afficher les résultats de parties",
    "text": "7 Afficher les résultats de parties\nLes résultats de parties sont généralement affichés sous ce format :\n\nAix-les-Bains 2006\n\n\n\n\n\n\n\n\n\nBlancs\n\nRés\nNoirs\n\n\n\n\n\nPRZYMUSINSKI Nicolas\n2043\n0 - 1\nf GREGOIRE Sylvain\n2268\n\n\nMEYNARD Thibault\n2256\n1 - 0\nZERMICHE Cherif\n2035\n\n\nHOUARD Yannick\n2010\nX - X\nPEREZ Flavio\n2230\n\n\nCOULON Guillaume\n2001\n0 - 1\nJOLLY Jean-Francois\n2211\n\n\nFISCHER Marc\n2185\nX - X\nDENEUVILLE Ludovic\n2003\n\n\nMATHIS Julien\n1951\n0 - 1\nPIERONI Guillaume\n2170\n\n\nBOIZANTE Yvain\n2148\nX - X\nSAEZ Nicolas\n1998\n\n\n\n\n\n\n\n\n\nL’objectif de cette partie est d’aboutir à ce résultat.\nVous noterez le f à la première ligne qui est l’éventuel titre de la joueuse en minuscule.\n\n\n\n\nCommencez par joindre les tables contenant les éléments à afficher\nEnsuite, gardez uniquement les colonnes nécessaires\nConcaténez titre, nom et prénom, et renommez les colonnes pour obtenir l’affichage demandé\nAffichez les résultat du Blitz à Rennes (tournoi)\n\n\n\n\n\n\n\nEnfin nous souhaitons récompenser la meilleure performance.\nUne performance est une victoire contre une joueuse ayant au moins 400 points elo de plus.\n\n\n\n\nAffichez toutes les performances\nClassez-les par différence de elo décroissante\n\n\n\n\n\n\n\nUn paquet de 🍪 est à retirer dans le bureau du professeur pour la joueuse détentrice de la meilleure perf !\nEt pour l’autrice de la plus belle contre-perf, notre partenaire premium, la Fédération Française de la Lose offre un magnifique tee-shirt floqué Reine des Mazettes, J’ai raté un mat en 1, Je suis passé de +10 à -10 ou encore J’ai fait pat avec Roi et Dame contre Roi."
  },
  {
    "objectID": "doc/tp/tp4.html#gagnantes-des-tournois",
    "href": "doc/tp/tp4.html#gagnantes-des-tournois",
    "title": "Chess Unofficial Federation",
    "section": "8 Gagnantes des tournois",
    "text": "8 Gagnantes des tournois\nVia la table partie, il est possible de retrouver quelle joueuse a participé à quel tournoi.\nCependant ce n’est pas très intuitif, ni pratique.\nNous allons donc commencer par créer une vue des participantes\n\nListez les différents tournois auquels a participé HOU Yifan\nListez tous les différents couples (id_joueuse, id_tournoi) possibles et existants dans la table partie\nCréez la vue participante(id_tournoi, id_joueuse)\n\nen y insérant les données de la dernière requête\n\nVérifiez que cette vue contient 960 enregistrements\n\n\n\n\n\n\n\nPour trouver les gagnantes des tournois, il faut trouver leurs nombres de points marqués.\nUne célébre citation dit « Je ne perds jamais, soit je gagne, soit j’apprends ».\nAux échecs, la victoire rapporte 1 point, le match nul 0.5 et la défaite 0.\n\n\n\nCependant un problème se pose : une seule ligne de la partie contient le nombre de points marqués de 2 joueuses.\n\n\n\nid_partie\nid_blanc\nid_noir\nresultat\n\n\n\n\n1\n11\n22\n1 - 0\n\n\n2\n123\n99\nX - X\n\n\n\nPour calculer les points de chaque joueuse, ce serait plus pratique de dupliquer chaque ligne pour avoir :\n\n\n\nid_partie\nid_joueuse\nscore\n\n\n\n\n1\n11\n1\n\n\n1\n22\n0\n\n\n2\n123\n0.5\n\n\n2\n99\n0.5\n\n\n\n\nListez pour toutes les parties, le score des blancs (comme sur le tableau ci-dessus)\nIncluez également pour la suite, les colonnes :\n\nid_tournoi\nle elo de l’adversaire\n\nFaites de même pour les noirs et stockez le tout dans une vue partie_score\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nVous pouvez utiliser une structure CASE WHEN THEN\n\nSELECT &lt;?&gt;,\n       CASE\n           WHEN &lt;?&gt; THEN &lt;?&gt; \n           WHEN &lt;?&gt; THEN &lt;?&gt;\n           ELSE &lt;?&gt;          \n       END AS score\n  FROM &lt;?&gt;\n\n\n\n\nVérifiez que pour toutes les parties, le score cumulé des deux joueuses vaut 1\nAffichez le classement par points de l’Open de Guingamp\n\nVous remarquez qu’il y a des égalités au nombre de points.\n\nUtilisez la moyenne elo des adversaires pour départager les ex æquo\n\nPlus la joueuse a affronté d’autres joueuses fortes, mieux elle sera classée\n\n\n\n\n\n\n\n\nVérification\n\n\n\n\n\nUne petite requête basique pour vérifier vos résultats :\nWITH resultat_score AS (\n    SELECT rp.*,\n           CASE\n               WHEN rp.resultat IN ('1 - 0', '1 - F') THEN 1 \n               WHEN rp.resultat = 'X - X'             THEN 0.5\n               ELSE 0\n           END AS score_blanc,\n           CASE\n               WHEN rp.resultat IN ('0 - 1', 'F - 1') THEN 1 \n               WHEN rp.resultat = 'X - X'             THEN 0.5\n               ELSE 0\n           END AS score_noir\n      FROM echecs.resultat_partie rp\n    ),\npartie_score AS (\n    SELECT p.id_partie,\n           p.id_tournoi,\n           UNNEST(ARRAY[id_blanc, id_noir]) AS id_joueuse,\n           UNNEST(ARRAY[score_blanc, score_noir]) AS score,\n           UNNEST(ARRAY[jn.elo, jb.elo]) AS elo_adversaire\n      FROM echecs.partie p\n      JOIN resultat_score USING(id_resultat)\n      JOIN echecs.joueuse jb ON (jb.id_joueuse = p.id_blanc)\n      JOIN echecs.joueuse jn ON (jn.id_joueuse = p.id_noir)\n    )\nSELECT CONCAT_WS(' ', LOWER(j.code_titre), j.nom, j.prenom) AS joueuse,\n       j.elo,\n       SUM(ps.score) AS points,\n       ROUND(AVG(ps.elo_adversaire)) AS moyenne_elo_adversaire\n  FROM echecs.joueuse j\n  JOIN partie_score ps USING(id_joueuse)\n  JOIN echecs.tournoi t USING(id_tournoi)\n WHERE t.nom = 'Open de Guingamp'\n GROUP BY j.id_joueuse,\n          joueuse,\n          j.elo\n ORDER BY points DESC,\n          moyenne_elo_adversaire DESC;\n\n\n\n\nCréez une vue contenant le classement de chaque joueuse dans chaque tournoi\n\nincluez le nom du tournoi, de la joueuse, son nombre de points, la moyenne elo des adversaire\ncalculez son classement dans le tournoi (💡 voir RANK OVER PARTITION BY)\n\nAffichez la liste de toutes les gagnantes des tournois"
  },
  {
    "objectID": "doc/tp/tp4.html#qui-est-la-meilleure",
    "href": "doc/tp/tp4.html#qui-est-la-meilleure",
    "title": "Chess Unofficial Federation",
    "section": "9 Qui est la meilleure ?",
    "text": "9 Qui est la meilleure ?\n\n\n\n\n\n\nNous souhaitons calculer le pourcentage de points marqués par chaque joueuse, ainsi que ses taux de victoires, matchs nuls et défaites.\n\n\n\nChoisissez une joueuse, par exemple Judith POLGAR\n\nEn utilisant une vue déjà créée, calculez son nombre de parties jouées et son nombre de points marqués\nCalculez le ratio pour avoir son ratio de points par partie\nCalculez ses taux de victoires, matchs nuls et défaites\nAdaptez la requête pour faire ces calculs pour toutes les joueuses\n\nclassez par ratio de points par partie déscroissant"
  },
  {
    "objectID": "doc/tp/tp4.html#arrêtez-votre-service",
    "href": "doc/tp/tp4.html#arrêtez-votre-service",
    "title": "Chess Unofficial Federation",
    "section": "Arrêtez votre service",
    "text": "Arrêtez votre service\nC’est la fin du TP, vous pouvez maintenant sauvegarder votre travail et libérer les ressources réservées :\n\nCopiez votre code et collez le sur votre machine dans un fichier .sql\n\npar exemple dans P:/Cours1A/UE3-Bases-de-donnees-relationnelles/TP4/tp4.sql\nou en téléchargeant depuis CloudBeaver le fichier sql (petit bouton avec un dossier et une flèche vers le bas)\n\nRetournez sur la page d’accueil du Datalab\nAllez dans Mes Services et supprimez votre service"
  },
  {
    "objectID": "doc/tp/correction/tp3.html",
    "href": "doc/tp/correction/tp3.html",
    "title": "Nombres premiers",
    "section": "",
    "text": "def crible_eratosthene(n):\n    \"\"\"Génère une liste de booléens où True indique qu'un nombre est premier.\"\"\"\n\n    est_premier = [True] * (n + 1)\n    est_premier[0] = est_premier[1] = False  # 0 et 1 ne sont pas premiers\n\n    for i in range(2, int(n**0.5) + 1):\n        if est_premier[i]:\n            for multiple in range(i * i, n + 1, i):\n                est_premier[multiple] = False\n\n    return est_premier\nl = crible_eratosthene(100000)\n\ncpt = 0\nfor i in l[10000:]:\n    if i:\n        cpt += 1\n\nprint(cpt)\nl[8363]"
  },
  {
    "objectID": "doc/tp/correction/tp3.html#fichier-des-communes",
    "href": "doc/tp/correction/tp3.html#fichier-des-communes",
    "title": "Nombres premiers",
    "section": "1 Fichier des communes",
    "text": "1 Fichier des communes\n\nimport pandas as pd\n\n\nimport duckdb\n\nduckdb.sql(\"\"\"\nCREATE OR REPLACE VIEW commune AS\nFROM 'https://www.insee.fr/fr/statistiques/fichier/7766585/v_commune_2024.csv';\n\"\"\")\n\n\nduckdb.sql(\"\"\"\nSELECT *\n  FROM commune\n\"\"\").to_df()\n\n\nduckdb.sql(\"\"\"\nSELECT reg\n  FROM commune\n WHERE NCC = 'MAMOUDZOU';\n\"\"\").to_df()\n\n\nduckdb.sql(\"\"\"\nSELECT COUNT(1)\n  FROM commune\n WHERE dep = '973';\n\"\"\").to_df()\n\n\nduckdb.sql(\"\"\"\nSELECT COUNT(1)\n  FROM commune\n WHERE dep IN ('02','60','80')\n   AND NCC LIKE '%L%L%L%L%';\n\"\"\").to_df()\n\n\nduckdb.sql(\"\"\"\nSELECT dep,\n       COUNT(1) AS nb_communes,\n       RANK() OVER (ORDER BY COUNT(1) DESC) AS rang\n  FROM commune\n WHERE dep IS NOT NULL\n GROUP BY dep\nHAVING nb_communes &gt;= 500\n ORDER BY 2 DESC;\n\"\"\").to_df()\n\n\nduckdb.sql(\"\"\"\nSELECT dep\n  FROM commune\n WHERE LENGTH(ncc) = (SELECT max(LENGTH(ncc))\n                        FROM commune);\n\"\"\").to_df()"
  },
  {
    "objectID": "doc/tp/correction/tp3.html#polars",
    "href": "doc/tp/correction/tp3.html#polars",
    "title": "Nombres premiers",
    "section": "2 Polars",
    "text": "2 Polars\n\nimport os\nimport polars as pl\n\ns3_endpoint = f'https://{os.environ[\"AWS_S3_ENDPOINT\"]}'\ns3_access_key = os.environ[\"AWS_ACCESS_KEY_ID\"]\ns3_secret_access_key = os.environ[\"AWS_SECRET_ACCESS_KEY\"]\ns3_session_token = os.environ[\"AWS_SESSION_TOKEN\"]\ns3_region = os.environ[\"AWS_DEFAULT_REGION\"]\n\ns3_username = os.environ[\"VAULT_TOP_DIR\"] # un peu bancal pour avoir le username\n\n\ns3_file_path = f\"s3://{s3_username}/ENSAI/SQL/tp3-longueur-fil.parquet\"\n\nstorage_options = {\n    \"aws_endpoint\":  s3_endpoint,\n    \"aws_access_key_id\": s3_access_key,\n    \"aws_secret_access_key\": s3_secret_access_key,\n    \"aws_token\": s3_session_token,\n    \"aws_region\": s3_region\n  }\n\nfile = pl.scan_parquet(source=s3_file_path, \n                     storage_options=storage_options)\n\n\ndf = file.collect()\n\n\nprint(df)\n\n\ndf.filter(pl.col(\"vetement\") == \"gilet\")"
  },
  {
    "objectID": "doc/tp/correction/tp3.html#diffusion",
    "href": "doc/tp/correction/tp3.html#diffusion",
    "title": "Nombres premiers",
    "section": "3 Diffusion",
    "text": "3 Diffusion\n\nfichier_prenoms = pl.scan_parquet(source=\"s3://ldeneuville-ensai/diffusion/ENSAI/SQL-TP/prenoms-nat2022.parquet\", \n                               storage_options=storage_options)\n\n\ntop10f2021 = fichier_prenoms\\\n    .filter((pl.col(\"sexe\") == 2) & \n            (pl.col(\"annais\") == \"2021\") & \n            (pl.col(\"preusuel\") != \"_PRENOMS_RARES\"))\\\n    .group_by(\"preusuel\")\\\n    .agg(pl.col(\"nombre\").sum().alias(\"nombre_total\"))\\\n    .sort(\"nombre_total\", descending=True)\\\n    .limit(10)\\\n    .collect()\n\n\ntop10f2021\n\n\ntop10f2021_sql = fichier_prenoms\\\n    .sql(\"\"\"\n      SELECT preusuel, \n             SUM(nombre) AS nombre_total\n        FROM self\n       WHERE preusuel &lt;&gt; '_PRENOMS_RARES'\n         AND annais = '2021'\n         AND sexe = 2\n       GROUP BY preusuel\n       ORDER BY nombre_total DESC\n       LIMIT 10\n    \"\"\")\\\n    .collect()\n\ntop10f2021_sql\n\n\nprenom = \"Katia\"\nannee_debut, annee_fin = 1960, 1980\n\ndf_prenom_annee = fichier_prenoms\\\n    .filter((pl.col(\"preusuel\") == prenom.upper()) & \n            (pl.col(\"annais\").str.to_integer(strict=False).is_not_null()) &  # Convertir et exclure les nulls\n            (pl.col(\"annais\").str.to_integer(strict=False) &gt;= annee_debut) & \n            (pl.col(\"annais\").str.to_integer(strict=False) &lt;= annee_fin))\\\n    .group_by(\"annais\")\\\n    .agg(pl.col(\"nombre\").sum().alias(\"nombre_total\"))\\\n    .sort(\"annais\")\\\n    .collect()\n\nprint(df_prenom_annee)\n\n\nfichier_prenoms.sql(f\"\"\"\nSELECT annais, \n       SUM(nombre) AS nombre_total\n  FROM self\n WHERE preusuel = 'KATIA'\n   AND annais != 'XXXX' \n   AND annais BETWEEN '{annee_debut}' AND '{annee_fin}'\n GROUP BY annais\n ORDER BY annais;\n \"\"\").collect()\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Set seaborn style for a cleaner, more appealing look\nsns.set_theme(style=\"whitegrid\")\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Data\nyears = df_prenom_annee[\"annais\"].to_list()         # Extracts years as a list\ncounts = df_prenom_annee[\"nombre_total\"].to_list()  # Extracts counts as a list\n\n# Bar plot with custom colors and transparency for better visuals\nax.bar(years, \n       counts, \n       color=\"#4C72B0\", \n       edgecolor=\"black\", \n       alpha=0.8)\n\n# Set labels and title with padding for readability\nax.set_xlabel(\"Année\", fontsize=12, labelpad=10)\nax.set_ylabel(\"Nombre d'occurences\", fontsize=12, labelpad=10)\nax.set_title(f\"Occurrences du prénom {prenom} par année ({annee_debut}-{annee_fin})\", fontsize=14, pad=15)\n\n# Rotate x-axis labels, improve spacing, and format grid\nax.tick_params(axis='x', rotation=45)\nplt.tight_layout()  # Adjust layout for tight fit\n\n# Display the plot\nplt.show()"
  },
  {
    "objectID": "doc/tp/correction/tp3.html#le-prénom",
    "href": "doc/tp/correction/tp3.html#le-prénom",
    "title": "Nombres premiers",
    "section": "4 Le prénom",
    "text": "4 Le prénom\n\nprenoms_feminins = fichier_prenoms.sql(f\"\"\"\nSELECT preusuel, \n       SUM(nombre) AS nombre_total\n  FROM self\n WHERE preusuel != '_PRENOMS_RARES'\n   AND annais != 'XXXX' \n   AND sexe = 2\n   AND annais BETWEEN '1970' AND '2000'\n GROUP BY preusuel\n ORDER BY nombre_total DESC,\n          preusuel DESC;\n \"\"\").collect()\n\n\n(8363 - 3) / 5\n\n\nprenoms_feminins.row(1672)\n\n\nprenoms_feminins.with_row_index()[1670:1680]"
  },
  {
    "objectID": "doc/tp/correction/tp3.html#export",
    "href": "doc/tp/correction/tp3.html#export",
    "title": "Nombres premiers",
    "section": "5 Export",
    "text": "5 Export\n\nimport s3fs\n\nfs = s3fs.S3FileSystem(\n    client_kwargs={'endpoint_url': 'https://'+'minio-simple.lab.groupe-genes.fr'},\n    key = os.environ[\"AWS_ACCESS_KEY_ID\"], \n    secret = os.environ[\"AWS_SECRET_ACCESS_KEY\"], \n    token = os.environ[\"AWS_SESSION_TOKEN\"])\n\ndestination = f\"s3://{s3_username}/ENSAI/SQL/output.csv\"\n\nwith fs.open(destination, mode='wb') as f:\n    top10f2021.write_csv(f)"
  },
  {
    "objectID": "doc/tp/tp3.html",
    "href": "doc/tp/tp3.html",
    "title": "Découverte du Datalab",
    "section": "",
    "text": "Le Datalab permet aux statisticiens de découvrir, d’expérimenter, d’apprendre, de se former aux outils de la data.\n\n\nDans le monde professionnel, plusieurs problèmes se posent au statisticien :\n\nsa machine n’est pas assez puissante\ninstaller certains logiciels est parfois interdit et bloqué par le système\nil doit analyser des données sensibles en toute sécurité\n\nÀ l’INSEE, un projet est né pour pallier à ce besoin : Onyxia porté par le lab de l’INSEE.\nLa première étape fut de créer une infrastructure Cloud avec des CPUs, des GPUs, de la RAM et du stockage.\nEnsuite, avoir plein de ressources c’est très bien, mais encore faut-il savoir les utiliser. Or lancer des services dans le cloud nécessite quelques compétences spécifiques (Docker, Kubernetes, Helm, S3…) qui ne sont pas à la portée de tous.\nD’où l’idée de créer une interface graphique pour pouvoir lancer des services en quelques clics. Onyxia s’appuie sur des technologies sous-jacentes (Kubernetes, Helm, S3…) pour proposer une IHM agréable pour le datascientist. Cependant, la philosophie du projet Onyxia est d’être une brique qui facilite le travail sans se rendre indispensable. L’idée est d’éviter que les utilisateurs ne s’enferment dans un choix technologique et qu’il soit couteux d’en sortir.\nÀ l’INSEE, une instance de ce logiciel a été installée sur le Datalab SSP Cloud, ouverte à tous les agents publics. Vous pouvez y créer un compte car c’est également ouvert à tous les élèves de l’ENSAI (en utilisant votre mail ENSAI).\n\n\n\n\n\n\nWarning\n\n\n\nNe déposez pas de données sensibles sur cette instance, ni sur celle du GENES.\nPour celles et ceux qui iront à l’INSEE, une autre instance nommée LS3 n’est accessible qu’en interne et autorise l’utilisation de données sensibles.\n\n\nOnyxia est un logiciel Libre et Open Source. Chacun peut installer sa propre instance sur son infra. C’est ce qu’ont fait de nombreux organismes, ainsi que le GENES.\n\n\n\n\nLe principe est d’offrir aux utilisateurs la possibilité de lancer de nombreux services à la demande (Jupyter, Rstudio, VSCode, PostgreSQL…) avec une puissance de calcul adaptée aux besoins.\n\n\n\n\n\n\nCaution\n\n\n\nCes services sont éphémères, car si les ressources sont importantes, il faut savoir les partager !\nLe principe général est le suivant :\n\nVous lancez votre service en réservant des ressources (CPU, GPU, RAM, Stockage)\nVous effectuez votre travail\nVous sauvegardez votre code (git) et vos résultats (MinIO)\nVous supprimez votre service et libérez les ressources"
  },
  {
    "objectID": "doc/tp/tp3.html#introduction",
    "href": "doc/tp/tp3.html#introduction",
    "title": "Découverte du Datalab",
    "section": "",
    "text": "Le Datalab permet aux statisticiens de découvrir, d’expérimenter, d’apprendre, de se former aux outils de la data.\n\n\nDans le monde professionnel, plusieurs problèmes se posent au statisticien :\n\nsa machine n’est pas assez puissante\ninstaller certains logiciels est parfois interdit et bloqué par le système\nil doit analyser des données sensibles en toute sécurité\n\nÀ l’INSEE, un projet est né pour pallier à ce besoin : Onyxia porté par le lab de l’INSEE.\nLa première étape fut de créer une infrastructure Cloud avec des CPUs, des GPUs, de la RAM et du stockage.\nEnsuite, avoir plein de ressources c’est très bien, mais encore faut-il savoir les utiliser. Or lancer des services dans le cloud nécessite quelques compétences spécifiques (Docker, Kubernetes, Helm, S3…) qui ne sont pas à la portée de tous.\nD’où l’idée de créer une interface graphique pour pouvoir lancer des services en quelques clics. Onyxia s’appuie sur des technologies sous-jacentes (Kubernetes, Helm, S3…) pour proposer une IHM agréable pour le datascientist. Cependant, la philosophie du projet Onyxia est d’être une brique qui facilite le travail sans se rendre indispensable. L’idée est d’éviter que les utilisateurs ne s’enferment dans un choix technologique et qu’il soit couteux d’en sortir.\nÀ l’INSEE, une instance de ce logiciel a été installée sur le Datalab SSP Cloud, ouverte à tous les agents publics. Vous pouvez y créer un compte car c’est également ouvert à tous les élèves de l’ENSAI (en utilisant votre mail ENSAI).\n\n\n\n\n\n\nWarning\n\n\n\nNe déposez pas de données sensibles sur cette instance, ni sur celle du GENES.\nPour celles et ceux qui iront à l’INSEE, une autre instance nommée LS3 n’est accessible qu’en interne et autorise l’utilisation de données sensibles.\n\n\nOnyxia est un logiciel Libre et Open Source. Chacun peut installer sa propre instance sur son infra. C’est ce qu’ont fait de nombreux organismes, ainsi que le GENES.\n\n\n\n\nLe principe est d’offrir aux utilisateurs la possibilité de lancer de nombreux services à la demande (Jupyter, Rstudio, VSCode, PostgreSQL…) avec une puissance de calcul adaptée aux besoins.\n\n\n\n\n\n\nCaution\n\n\n\nCes services sont éphémères, car si les ressources sont importantes, il faut savoir les partager !\nLe principe général est le suivant :\n\nVous lancez votre service en réservant des ressources (CPU, GPU, RAM, Stockage)\nVous effectuez votre travail\nVous sauvegardez votre code (git) et vos résultats (MinIO)\nVous supprimez votre service et libérez les ressources"
  },
  {
    "objectID": "doc/tp/tp3.html#objectifs",
    "href": "doc/tp/tp3.html#objectifs",
    "title": "Découverte du Datalab",
    "section": "Objectifs",
    "text": "Objectifs\nCe TP d’initiation va vous permettre de :\n\nLancer vos premiers services\nVous familiariser avec l’espace de stockage S3\nConfigurer votre compte sur le datalab\n\n\n\n\n\n\n\nFil rouge\n\n\n\nVos collègues Josette et Félix attendent un heureux événement. Ils avaient trouvé le prénom idéal pour leur enfant à naître.\nCependant, un malencontreux accident de fer à repasser les a rendu amnésiques tous les deux.\nVotre mission, si vous l’acceptez, est de retrouver ce fameux prénom. Pour cela, vous allez devoir explorer les fonctionnalités du Datalab."
  },
  {
    "objectID": "doc/tp/tp3.html#se-connecter",
    "href": "doc/tp/tp3.html#se-connecter",
    "title": "Découverte du Datalab",
    "section": "1 Se connecter",
    "text": "1 Se connecter\nVous pouvez réaliser ce TP soit sur :\n\nLe Datalab du GENES\nLe Datalab SSPCloud de l’INSEE\n\nsi besoin de créer un compte, utilisez votre mail ENSAI"
  },
  {
    "objectID": "doc/tp/tp3.html#lancer-un-service",
    "href": "doc/tp/tp3.html#lancer-un-service",
    "title": "Découverte du Datalab",
    "section": "2 Lancer un service",
    "text": "2 Lancer un service\n\n\n\n\n\n\nFil rouge\n\n\n\nAvant de partir à la recherche du prénom, Josette a une envie de doubitchou.\nVous retrouvez la recette, mais il vous manque la quantité exacte en grammes de margarine.\nVous savez simplement que la valeur recherchée correspond à combien il y a de nombres premiers entre 10 000 et 100 000.\nNaturellement, vous vous dites que la solution la plus simple est de créer un programme Python pour trouver la réponse. Or, Python n’est pas installé sur votre machine et vous ne savez pas comment faire… Mais alors : pourquoi ne pas lancer un service du Datalab qui permet d’exécuter du Python.\n\n\n\n2.1 Un premier service\n\nAllez dans Catalogue de services\nSélectionnez le service Jupyter-python, puis cliquez deux fois sur Lancer\n\nAttendez quelques secondes le temps que le service se lance.\n\nCliquez pour copier le mot de passe\nCliquez sur Ouvrir le service 🚀\n\npassword : collez le mot de passe\n\n\nVotre service Jupyter Python s’ouvre.\n\n\n\n\n\n\nCe qu’il se passe sous le capot\n\n\n\n\n\nPour plus de détails, vous pouvez consulter la vidéo en bas de la page.\nPrenons l’exemple de ce qu’il se passe en arrière plan lorsque vous lancez un service Vscode-python :\n\nConstruction de l’image Docker\nUne image Docker est un paquet léger et autonome qui contient tout le nécessaire pour exécuter une application : le code, les bibliothèques, les dépendances, les variables d’environnement et les fichiers de configuration.\nLes images Docker permettent de créer des environnements isolés et cohérents, garantissant ainsi la portabilité et la reproductibilité des applications.\n\nNous partons de l’image de base d’Onyxia\n\nubuntu:22.04 et quelques éléments de config\n\nNous ajoutons la couche python-minimal\n\ninstallation de python et quelques packages classiques\n\nNous ajoutons la couche python-datascience\n\nJulia, Quarto et des packages de datascience (numpy, pandas…)\n\nNous ajoutons la couche vscode\n\nInstallation de Visual Studio Code et configuration\n\n\nVous avez maintenant une image Docker avec tout ce qu’il faut pour bien travailler.\n\n\nDockerHub\nCette image est construite et déposée sur DockerHub onyxia-vscode-python.\nNous allons ensuite lancer une instance de cette image : un conteneur.\nUne image est comme un moule, et un conteneur est un objet fabriqué à partir de ce moule. L’image contient les instructions, et le conteneur est l’instance concrète créée à partir de ce modèle. Vous verrez le même principe dans le cours de POO avec les classes (modèles) et les objets (instances)\nPour gérer tous les conteneurs lancés sur le datalab, nous avons besoin d’un orchestrateur : Kubernetes.\n\n\nChart Helm\nCependant, nous allons d’abord utiliser Helm pour faciliter le déploiement.\nHelm simplifie le processus de déploiement d’applications sur Kubernetes en automatisant les tâches répétitives et en fournissant une gestion centralisée des configurations.\nLe chart Helm vscode-python est un ensemble de fichiers de configuration qui facilite le déploiement d’application dans un envrionnement Kubernetes.\n\n\nDéploiement sur Kube\nKubernetes (K8s) est un système open-source qui automatise le déploiement, la mise à l’échelle et la gestion d’applications conteneurisées. C’est un orchestrateur de conteneurs.\nK8s récupére via le chart Helm toutes les infos nécessaires et déploie le conteneur (créé à partir de l’image Docker) sur l’infra du datalab.\n\n\n\n\n\nCréez un Notebook Python\n\nFile ➡️ New ➡️ Notebook\n\nDans la cellule, écrivez un code Python qui permet de compter combien il y a de nombres premiers entre 10 000 et 100 000\n\nPour vous aider, vous pouvez utiliser cette fonction qui génére une liste de booléens.\ndef crible_eratosthene(n) -&gt; list[bool]:\n    \"\"\"Génère une liste de booléens où True indique qu'un nombre est premier.\"\"\"\n\n    est_premier = [True] * (n + 1)\n    est_premier[0] = est_premier[1] = False  # 0 et 1 ne sont pas premiers\n\n    for i in range(2, int(n**0.5) + 1):\n        if est_premier[i]:\n            for multiple in range(i * i, n + 1, i):\n                est_premier[multiple] = False\n\n    return est_premier\n\n\n\n\n\n\nTip\n\n\n\nN’hésitez pas à créer plusieurs cellules pour découper votre code (petites icones avec des +)\n\n\nComme vous êtes un as de la programmation, cela ne vous prend que trois minutes. C’est beaucoup plus rapide que si vous aviez du installer Python, ainsi qu’un environnement d’exécution.\n\nVérifiez que le résultat est lui même un nombre premier\n\nNotez le vous en aurez besoin à la fin\n\n\n\n\n2.2 Utiliser des données\n\n\n\n\n\n\nFil rouge\n\n\n\nVous vous rendez compte qu’il faut plus de 8 kg de margarine et que vous n’en avez pas assez dans le frigo.\nFélix propose d’aller en chercher à la superette du coin. Il entre dans l’ascenseur pour descendre les 6 étages et patatra, il se retrouve bloqué.\nPour retrouver les 5 chiffres du numéro du dépanneur, vous allez devoir répondre à 5 questions en requêtant le fichier des communes françaises.\n\n\n\n\n\n\n\n\nCOG\n\n\n\nChaque année, l’INSEE publie sur son site le Code officiel géographique (COG).\nCe référentiel regroupe, au 1er janvier, les codes et libellés des communes, cantons, arrondissements, départements, régions, ainsi que ceux des pays et territoires étrangers.\n\n\nVous allez utiliser via DuckDB du SQL dans du code Python. Commencez par importer le package et créer la vue vers le fichier des communes 2024.\nimport duckdb\n\nduckdb.sql(\"\"\"\nCREATE OR REPLACE VIEW commune AS\nFROM 'https://www.insee.fr/fr/statistiques/fichier/7766585/v_commune_2024.csv';\n\"\"\")\nPour exécuter une requête :\nduckdb.sql(\"\"\"\nSELECT *\n  FROM commune\n\"\"\")\n\n\n\n\n\n\nTip\n\n\n\nPour avoir un affichage plus joli, vous pouvez convertir la sortie en du dataframe pandas avec la méthode to_df().\nimport pandas as pd\n\nduckdb.sql(\"\"\"\nSELECT *\n  FROM commune\n\"\"\").to_df()\n\n\n\nQuel est le code région de Mayotte ?\nCombien de communes y a-t-il en Guyane ?\nParmi les 3 départements de la Picardie (Aisne, Oise, Somme), combien de communes ont au minimum 4 L dans leur nom ?\nAffichez le nombre de communes par département\n\nClassez par nombre de communes décroissant\nQuel est le numéro du département se classant au 20e rang ?\n\nQuel est le numéro du département dans lequel se trouve le nom de commune le plus long\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nLa somme des 5 nombres vaut 149\nLes nombres sont dans l’ordre croissant\n\n\n\n\nVous venez ici d’utiliser des données disponibles sur internet. Vous pouvez également effectuer des traitements sur vos propres données en les stockant sur S3."
  },
  {
    "objectID": "doc/tp/tp3.html#stockage-s3",
    "href": "doc/tp/tp3.html#stockage-s3",
    "title": "Découverte du Datalab",
    "section": "3 Stockage S3",
    "text": "3 Stockage S3\n\n\n\n\n\n\nDéfinition\n\n\n\nS3 : Simple Storage System.\nInventé par Amazon, ce système de stockage est devenu l’outil standard du marché pour le stockage en ligne.\nMinIO est une solution alternative de stockage d’objets open-source qui permet de déployer facilement un stockage évolutif et performant. Elle est compatible avec l’API S3 d’Amazon, ce qui facilite l’intégration avec les applications existantes.\nPour faire simple, vous pouvez vous dire que c’est comme si vous allez stocker vos fichiers dans un Drive.\n\n\nLorsque l’on travaille dans le cloud, il est essentiel de séparer les données des programmes pour :\n\nmieux gérer les ressources\nrenforcer la sécurité en limitant les accès et les permissions\npermettre une scalabilité indépendante des composants\n\nMinIO offre :\n\nune haute disponibilité\nune sécurité renforcée grâce au chiffrement des données et des contrôles d’accès\ndes performances élevées, particulièrement adaptées aux environnements nécessitant un accès rapide aux données, comme le Big Data et l’intelligence artificielle\n\n\n3.1 Votre bucket\n\n\n\n\n\n\nDéfinition\n\n\n\nUn bucket est un conteneur de stockage utilisé pour regrouper des objets (fichiers et métadonnées) dans des systèmes de stockage de type cloud. Il facilite l’organisation, la gestion des permissions et l’accès aux données dans un espace de stockage structuré.\n\n\nLors de votre création de compte, un bucket est créé avec votre nom d’utilisateur. Dans ce bucket, vous pouvez :\n\ncréer / supprimer des dossiers\nimporter / supprimer des fichiers\n\nVous avez plusieurs possibilités pour gérer à votre stockage :\n\nDepuis le Datalab, onglet Mes fichiers\nDepuis la console MinIO :\n\nhttps://minio-console.lab.sspcloud.fr/\nhttps://minio-simple.lab.groupe-genes.fr\n\nDepuis un terminal avec le client Minio\n\n\n\n3.2 Stocker vos fichiers\n\n\n\n\n\n\nFil rouge\n\n\n\nFélix est sauvé, il peut maintenant aller chercher de la margarine et du papier cadeau (ça peut toujours servir).\nEn attendant, Josette s’occupe en confectionnant un superbe gilet gris avec son amie Thérèse.\nElle se souvient qu’elle a noté quelque part la longueur de fil nécessaire dans un fichier csv.\n\n\n\nTéléchargez ce fichier parquet\n\nEnsuite, allez sur la page d’accueil du Datalab :\n\nAllez dans Mes fichiers\nCréez un dossier ENSAI puis à l’intérieur un dossier SQL\nTéléversez votre fichier parquet dans le dossier SQL\n\n\n\n\n\n\n\nChemin vers mes fichiers\n\n\n\nVous remarquerez à droite, des lignes de commande du type mc cp tp3-longueur-fil.parquet s3/&lt;username&gt;/ENSAI/SQL/tp3-longueur-fil.parquet.\nCe sont des commandes pour interagir avec votre stockage depuis un terminal (voir ci-après).\nCependant, vous pouvez extraire de ces commandes une information intéressante : le chemin vers votre fichier : s3/&lt;username&gt;/ENSAI/SQL/tp3-longueur-fil.parquet.\n\n\nVous venez de charger un fichier, voyons maintenant comment y accéder dans un Service, en utilisant par exemple le notebook que vous avez déjà lancé.\n\n\n3.3 Utiliser des données\nSur la page d’accueil du Datalab :\n\nAllez dans Mon Compte, puis dans l’onglet Connexion au Stockage\n\nVous trouverez ici des informations pour vous connecter au stockage selon le language que vous utilisez : Python, R…\nD’ailleurs pour chaque langage, il y a même plusieurs packages qui font le job. Par exemple s3fs ou boto3 pour Python.\nRetournez dans votre service Notebook Jupyter :\n\nCréez un nouveau Notebook\n\nvous pouvez par exemple le nommer S3.ipynb\n\nCréer 2 cellules, puis collez et exécutez les 2 blocs de code ci-dessous\n\nCommencez par importer les packages nécessaires et récupérer les valeurs des variables d’environnement pour pouvoir se connecter à votre stockage.\nimport os\nimport polars as pl\n\ns3_endpoint = f'https://{os.environ[\"AWS_S3_ENDPOINT\"]}'\ns3_access_key = os.environ[\"AWS_ACCESS_KEY_ID\"]\ns3_secret_access_key = os.environ[\"AWS_SECRET_ACCESS_KEY\"]\ns3_session_token = os.environ[\"AWS_SESSION_TOKEN\"]\ns3_region = os.environ[\"AWS_DEFAULT_REGION\"]\n\ns3_username = os.environ[\"VAULT_TOP_DIR\"] # un peu bancal pour avoir le username\n\n\n\n\n\n\nWarning\n\n\n\nLes clés et les jetons ont une durée de vie limitée.\nSi vous laissez votre service ouvert trop longtemps (pas bien !), vos clés et jetons pourraient être expirés.\nDans ce cas, vous pouvez recharger en dur les nouvelles valeurs (voir Mon Compte &gt; Connexion au Stockage).\n\n\nDéfinissez le chemin où se trouve votre fichier et lisez le avec Polars.\ns3_file_path = f\"s3://{s3_username}/ENSAI/SQL/tp3-longueur-fil.parquet\"\n\nstorage_options = {\n    \"aws_endpoint\":  s3_endpoint,\n    \"aws_access_key_id\": s3_access_key,\n    \"aws_secret_access_key\": s3_secret_access_key,\n    \"aws_token\": s3_session_token,\n    \"aws_region\": s3_region\n  }\n\nfile = pl.scan_parquet(source=s3_file_path, \n                     storage_options=storage_options)\n\n\n\n\n\n\nPolars\n\n\n\nPolars est une bibliothèque rapide et performante pour la manipulation de données en Python et Rust, optimisée pour les grands volumes de données.\nContrairement à Pandas, Polars utilise une approche orientée colonnes (columnar) et tire parti du traitement parallèle, ce qui le rend particulièrement adapté pour les opérations analytiques lourdes.\nSa syntaxe, proche de celle de Pandas, permet des transformations, agrégations et manipulations de données avec des méthodes performantes et expressives.\nPour plus de détails : https://ssphub.netlify.app/post/polars/\n\n\n\nCréez une troisième cellule et affichez le fichier chargé\n\nQue se passe-t-il ?\n\n\n\n\n\n\n\n\nMode Lazy\n\n\n\nVous avez appelé la méthode scan_parquet() qui correspond au mode Lazy de Polars.\nLe mode Lazy signifie que Polars va accumuler toutes les instructions que vous lui donnez sans pour autant les exécuter tout de suite.\nMais quel est l’intérêt ?\nImaginons que vous êtes en train d’analiser un trés gros fichier et que vous enchainez à la suite diverses opérations (filtres, sélections de colonnes, regroupements, agrégations, tri…), deux choix s’offrent à vous :\nOption 1 (mode Eager : pl.read_parquet()):\n\nvous chargez tout le fichier en RAM (dans la mémoire de votre machine)\nvous appliquez des opérations dans n’importe quel ordre\nvous lancez, c’est long et ça rame…\n\nOption 2 (mode Lazy : pl.scan_parquet()):\n\nvous scannez le fichier, i.e. analyser sa structure (types de colonnes) et ses métadonnées\nvous donnez vos opérations dans n’importe quel ordre\nà la fin, vous demandez à Polars de vous fournir le résultat\nà ce moment, Polars va optimiser l’ordre des traitements en utilisant son propre plan d’exécution et vous donner une réponse beaucoup plus rapide\n\nEn résumé, en mode Eager, à chaque étape la machine effectue bêtement tous les calculs que vous lui demandez. En mode Lazy, la machine liste les opérations que vous demandez. Puis lorsque vous exigez un résultat, l’ordre des opérations est optimisé et la réponse est beaucoup plus rapide.\n\n\n\nPour demander le chargement du fichier, appelez la méthode collect()\n\nstockez le résultat dans une variable df\n\nVous pouvez maintenant afficher le contenu de df avec un print\n\nEn appelant la méthode collect(), vous avez « forcé » Polars à charger les données en mémoire.\n\nAppliquez au dataframe la méthode filter() pour trouver la longueur de fil du gilet\n\ndf.filter(pl.col(\"&lt;column_name&gt;\") == \"&lt;value&gt;\")\n\n\n\n\n3.4 Données d’autres utilisateurs\n\n\n\n\n\n\nFil rouge\n\n\n\nPendant que Josette confectionne son gilet, Félix revient avec la margarine.\nOr, Josette n’a finalement plus faim. Félix se met alors à bouder et va s’enfermer dans les toilettes pour avaler des pilules qu’il a prises au passage à la pharmacie. Soudain, la mémoire lui revient !\nIl se rappelle qu’ils avaient trouvé le prénom en parcourant… Le fichier des prénoms !\n\n\nCe fichier est stocké sur le bucket d’un autre utilisateur à l’une des adresses suivante :\n\nSSP Cloud : s3://ludo2ne/diffusion/ENSAI/SQL-TP/prenoms-nat2022.parquet\nDatalab du GENES : s3://ldeneuville-ensai/diffusion/ENSAI/SQL-TP/prenoms-nat2022.parquet\n\n\n\n\n\n\n\nImportant\n\n\n\nMalheureusement sur le Datalab du GENES, la fonctionnalité n’est pas encore implémentée sur le Datalab du GENES.\nLes dossiers diffusion de chaque utilisateur ne sont pas accessibles en lecture.\nCe n’est plus trop dans la philosophie de l’exercice, mais pour contourner le problème :\n\nTéléchargez le fichier des prenoms\nStockez le sur votre S3\nUtilisez ce fichier pour la suite\n\n\n\n\n\n\n\n\n\nDiffusion\n\n\n\nÀ la racine de votre Bucket, vous pouvez créer un dossier nommé diffusion.\nVous pourrez alors stocker à l’intérieur les dossiers et fichiers que vous souhaitez partager aux autres utilisateurs. Ils auront un droit d’accès en lecture sur votre dossier diffusion.\n\n\n\nScannez ce fichier avec Polars\n\nstockez-le dans une variable nommée fichier_prenoms\n\nUtilisez le code ci-dessous pour afficher le top10 des prénoms féminins en 2022\n\ntop10f2021 = fichier_prenoms\\\n    .filter((pl.col(\"sexe\") == 2) & \n            (pl.col(\"annais\") == \"2021\") & \n            (pl.col(\"preusuel\") != \"_PRENOMS_RARES\"))\\\n    .group_by(\"preusuel\")\\\n    .agg(pl.col(\"nombre\").sum().alias(\"nombre_total\"))\\\n    .sort(\"nombre_total\", descending=True)\\\n    .limit(10)\\\n    .collect()\n\nVous pouvez effectuez les mêmes traitements en encapsulant du sql :\n\ntop10f2021_sql = fichier_prenoms\\\n    .sql(\"\"\"\n      SELECT preusuel, \n             SUM(nombre) AS nombre_total\n        FROM self\n       WHERE preusuel &lt;&gt; '_PRENOMS_RARES'\n         AND annais = '2021'\n         AND sexe = 2\n       GROUP BY preusuel\n       ORDER BY nombre_total DESC\n       LIMIT 10\n    \"\"\")\\\n    .collect()\n\n\n\n\n\n\nFil rouge\n\n\n\nAlors que vous alliez chercher le prénom, votre camarade Katia vous demande en quelle année son prénom a été le plus donné entre 1960 et 1980.\n\n\n\nÉcrivez la requête SQL qui fait le même travail que les instructions ci-dessous\n\nprenom = \"Katia\"\nannee_debut, annee_fin = 1960, 1980\n\ndf_prenom_annee = fichier_prenoms\\\n    .filter((pl.col(\"preusuel\") == prenom.upper()) & \n            (pl.col(\"annais\").str.to_integer(strict=False).is_not_null()) & \n            (pl.col(\"annais\").str.to_integer(strict=False) &gt;= annee_debut) & \n            (pl.col(\"annais\").str.to_integer(strict=False) &lt;= annee_fin))\\\n    .group_by(\"annais\")\\\n    .agg(pl.col(\"nombre\").sum().alias(\"nombre_total\"))\\\n    .sort(\"annais\")\\\n    .collect()\n\nprint(df_prenom_annee)\n\n\n\n\n\n\nDiagramme en barre\n\n\n\n\n\nVous pouvez également tracer un graphique avec ces données :\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Set seaborn style for a cleaner, more appealing look\nsns.set_theme(style=\"whitegrid\")\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Data\nyears = df_prenom_annee[\"annais\"].to_list()         # Extracts years as a list\ncounts = df_prenom_annee[\"nombre_total\"].to_list()  # Extracts counts as a list\n\n# Bar plot with custom colors and transparency for better visuals\nax.bar(years, \n       counts, \n       color=\"#4C72B0\", \n       edgecolor=\"black\", \n       alpha=0.8)\n\n# Set labels and title with padding for readability\nax.set_xlabel(\"Année\", fontsize=12, labelpad=10)\nax.set_ylabel(\"Nombre d'occurences\", fontsize=12, labelpad=10)\nax.set_title(f\"Occurrences du prénom {prenom} par année ({annee_debut}-{annee_fin})\", fontsize=14, pad=15)\n\n# Rotate x-axis labels, improve spacing, and format grid\nax.tick_params(axis='x', rotation=45)\nplt.tight_layout()  # Adjust layout for tight fit\n\n# Display the plot\nplt.show()\n\n\n\nNous y sommes presque ! Pour trouver le fameux prénom :\n\nReprenez le résultat du nombre de nombres premiers entre 10 000 et 100 000\nOtez 3\nDivisez par 5\n\nLe prénom recherché est à ce rang de classement pour les prénoms féminins donnés en France entre 1970 et 2000.\n\nÉcrivez la requête\n\nFiltrez les prénoms féminins donnés entre 1970 et 2000\nClassez-les par le nombre de fois où ils ont été donné décroissant et prénom décroissant\n\nTrouvez le prénom classé au rang demandé\n\nVous pouvez utiliser ce code : &lt;df&gt;.with_row_index()[&lt;index_inf&gt;:&lt;index_sup&gt;]\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nCe n’est pas encore implémenté dans Polars, mais il est possible en SQL de générer les rangs : RANK() OVER (ORDER BY SUM(nombre) DESC) AS rang.\nLa réponse :\n\nCommence par un S\nMonsieur et Madame Hier ont une fille, comment s’appelle-t-elle ?\n\n\n\n\n\n\n3.5 Exportez vos résultats vers MinIO\nVous pouvez également exporter vos fichiers vers S3.\nNous allons utiliser ici la librairie s3fs.\n\nCollez et lancez ce code :\nimport s3fs\n\nfs = s3fs.S3FileSystem(\n    client_kwargs={'endpoint_url': 'https://'+'minio-simple.lab.groupe-genes.fr'},\n    key = os.environ[\"AWS_ACCESS_KEY_ID\"], \n    secret = os.environ[\"AWS_SECRET_ACCESS_KEY\"], \n    token = os.environ[\"AWS_SESSION_TOKEN\"])\n\ndestination = f\"s3://{s3_username}/ENSAI/SQL/output.csv\"\n\nwith fs.open(destination, mode='wb') as f:\n    top10f2021.write_csv(f)\nSur le Datalab, allez dans Mes fichiers ➡️ ENSAI ➡️ SQL\n\nle fichier output.csv a été généré\nrafraichissez la page si besoin\n\nDouble-cliquez sur ce fichier pour en avoir un aperçu\n\n\nPour plus de détails sur le stockage des fichiers sur S3 :\n\nLes données sur le cloud , Python pour la data science, Lino Galiana"
  },
  {
    "objectID": "doc/tp/tp3.html#libérer-les-ressources",
    "href": "doc/tp/tp3.html#libérer-les-ressources",
    "title": "Découverte du Datalab",
    "section": "Libérer les ressources",
    "text": "Libérer les ressources\nUne fois vos travaux terminés, il est temps de libérer les ressources réservées.\n\nSi besoin, sauvegardez vos notebooks\n\nclic droit sur le nom du fichier ➡️ Download\n\nPuis sur la page d’accueil, allez dans Mes services, mettez votre service à la poubelle\n\nVous pouvez aisément reproduire votre travail plus tard :\n\nVotre code est téléchargé\nVos données sont toujours sur MinIO\nIl suffit de relancer un nouveau service et de relancer les calculs\n\nUne manière plus propre de travailler est d’utiliser git pour versionner son code."
  },
  {
    "objectID": "doc/tp/tp3.html#fin-du-tp",
    "href": "doc/tp/tp3.html#fin-du-tp",
    "title": "Découverte du Datalab",
    "section": "Fin du TP",
    "text": "Fin du TP\nLe but de ce TP était de vous faire découvrir les fonctionnalités de base du Datalab et les bonnes pratiques de travail dans un environnement Cloud.\n\n\n\n\n\n\nImportant\n\n\n\nLa suite du TP est optionnelle.\nElle est simplement donnée pour celles et ceux qui souhaient aller plus loin et profiter de toutes les fonctionnalités du Datalab.\n\n\n\nBesoin d’assistance ?\n\nContactez l’équipe du SSP Cloud sur Slack\nPour le Datalab du GENES, vous trouverez sur la page d’accueil un lien pour rejoindre le canal Teams\n\n\n\nPour aller plus loin\nUne présentation complète du projet Onyxia au Devoxx 2023, de sa philosophie et de son fonctionnement par Olivier LEVITT, Joseph GARRONE et Frédéric COMTE.\n\nUne présentation plus courte\n\nD’autres videos sur la page GitHub du projet\n\n\nBibliographie\n\nUtiliser RStudio sur l’environnement SSP Cloud, UtilitR\nFormations et tutoriels du SSP Cloud\n\nNombreux tutos : Python, R, ML, Spark, Cartographie\n\nDoc SSP Cloud\nPrincipes du Datalab\nDécouverte d’Onyxia et de son datalab SSP Cloud, Nathan Randriamanana"
  },
  {
    "objectID": "doc/tp/tp3.html#travailler-avec-git",
    "href": "doc/tp/tp3.html#travailler-avec-git",
    "title": "Découverte du Datalab",
    "section": "4 Travailler avec Git",
    "text": "4 Travailler avec Git\n\n\n\n\n\n\nCaution\n\n\n\nSur le datalab, vos services ont une durée de vie limitée.\nPour sauvegarder vos programmes, la bonne pratique est d’utiliser un dépôt git. Nous allons donc créer et utiliser un jeton pour communiquer avec GitHub.\nPour suivre la démarche, il faut disposer d’un compte GitHub. Il est possible de suivre une démarche similaire avec GitLab.\n\n\n\n4.1 Générer un token GitHub\n\n\n\n\n\n\nDéjà fait ?\n\n\n\nSi vous avez déjà généré et déclaré un jeton GitHub, inutile de refaire ces 2 étapes.\n\n\n\nConnectez-vous à votre compte GitHub\nAllez dans settings ➡️ Developer settings ➡️ Personal access tokens ➡️ Tokens (classic)\nGénérez un nouveau jeton classique\n\nRenseigner :\n\nnom du token : Datalab GENES\ndate d’expiration ➡️ Custom ➡️ 1 an\n\n✅ Cochez repo\nCliquez sur Generate token\nCopiez ce jeton commençant par ghp_ et gardez le précieusement de côté quelques minutes\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\nCe jeton ne sera visible qu’une seule fois\nsi vous le perdez ou s’il est expiré, il faut en générer un nouveau\n\n\n\n\n\n4.2 Déclarer votre jeton\nGitHub vous a fournit un jeton. Il faut maintenant le déclarer sur le Datalab :\n\nAllez dans Mon Compte ➡️ Onglet Git\nRenseignez les informations suivantes\n\nnom d’utilisateur Git\nmail (celui utilisé pour votre compte GitHub)\n\nCollez votre token\n\n\n\n\n\n\n\nConfig Git\n\n\n\nVous pouvez maintenant échanger du code entre les services du Datalab et vos dépôts GitHub. 🎉\n\n\n\n\n4.3 Dépôt pour le code\nAvant de créer un service, nous allons créer un dépôt GitHub qui permettra de sauvegarder votre code.\n\nDans GitHub, créer un nouveau Repository\n\nRepository name : TP3-datalab\nPrivate\n✅ Cochez Add a README file\n.gitignore template : Python\nChoose a license : Apache Licence 2.0\nCreate Repository\n\nSur la page de votre repo, cliquez sur le bouton Code\nCopiez l’adresse https du repo\n\n\n\n4.4 Branchez votre service sur un répo\nLors du lancement d’un Service, vous pouvez vous brancher sur un répo git. Ainsi le contenu de votre dépôt sera importé dans votre service.\nVous pourrez alors utiliser le code de votre dépôt et éventuellement le mettre à jour en effectuant un push.\nLancez un service Jupyter Notebook\n\nOuvrez la Configuration\n\nDe nombreux onglets permettent de configurer votre service\nService : possibilité d’utiliser une autre image Docker\nResources : choisir CPU et RAM\nInit : script à lancer au démarrage\n\nAllez dans l’onglet Git et collez l’adresse https du repo dans la case Repository url\nLancez le service, puis attendez quelques secondes\n\n\n\n4.5 Sauver son code\n\nSur Jupyter, ouvrez un terminal\n\nFile ➡️ New ➡️ Terminal\n\nPositionnez-vous dans le repo : cd /home/onyxia/work/TP3-datalab/\ngit status pour voir l’état actuel\n\nle fichier ex0.ipynb doit apparaître dans les Untracked files\n\nAjoutez ce fichier à l’index\nCréez un commit\nPoussez ce commit vers votre dépôt distant (GitHub)\n\nVous pouvez vérifier sur GitHub que votre fichier ex0.ipynb est bien présent\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ngit add .\ngit commit -m \"création fichier tp3\"\ngit push\n\n\n\n\n\nExercice\nPar exemple en important le fichier des prénoms avec Polars et en encapsulant du SQL :\n\nÉcrivez la requête du nombre de fois ou votre prénom a été donné entre 2010 et 2020\nCréez une nouvelle cellule et écrivez une requête pour afficher les 5 années où sont nées le plus de filles\nQuels sont les prénoms masculins et féminins les plus donnés depuis 1900 ?\nAffichez le nombres de filles et de garçons nés chaque année depuis 2010\n\n💡 Aide : SUM(CASE WHEN ? THEN ? ELSE ? END)"
  },
  {
    "objectID": "doc/tp/tp3.html#minio",
    "href": "doc/tp/tp3.html#minio",
    "title": "Découverte du Datalab",
    "section": "5 MinIO",
    "text": "5 MinIO\nD’autres possibilités pour accéder à votre stockage\n\n5.1 Client MinIO\nLe client MinIO installé et utilisable depuis le terminal permet également d’interagir avec vos fichiers.\nOuvrez un terminal (File ➡️ New ➡️ Terminal):\n\nmc ls s3/&lt;username&gt;/ENSAI/SQL : pour lister le contenu de votre dossier\nmc cp s3/&lt;username&gt;/ENSAI/SQL/output.csv . : pour copier le fichier depuis s3 dans votre dossier courant\n\nle fichier apparait dans votre explorer\n\nSupprimez ce fichier : rm output.csv\n\nCar importer les fichiers de données dans son espace de travail n’est pas une bonne pratique\n\n\n\n\n\n\n\n\nTip\n\n\n\nLa commande mc --help liste toutes les commandes possibles (ESPACE pour défiler, CTRL+C pour sortir)\n\n\n\n\n5.2 Console Minio\nVous pouvez également accéder à votre stockage avec la console Minio :\n\nhttps://minio-console.lab.sspcloud.fr/\nhttps://minio-simple.lab.groupe-genes.fr\n\n\n\n5.3 Python et s3fs\nimport os\nimport s3fs\nimport polars as pl\n\nfs = s3fs.S3FileSystem(\n    client_kwargs={\"endpoint_url\": f\"https://{os.environ['AWS_S3_ENDPOINT']}\"},\n    key = os.environ[\"AWS_ACCESS_KEY_ID\"], \n    secret = os.environ[\"AWS_SECRET_ACCESS_KEY\"], \n    token = os.environ[\"AWS_SESSION_TOKEN\"])\n\ns3_username = os.environ[\"VAULT_TOP_DIR\"] # un peu bancal pour avoir le username\n\nbucket_name = f\"{s3_username}/diffusion/\"\n\nfiles = fs.ls(bucket_name)\n\nfor file in files:\n    print(file)\n\n\n\n\n\n\nAffichage plus joli\n\n\n\n\n\n!pip install humanize\nimport humanize\n\ndata = []\n\nfor file in fs.ls(bucket_name, detail=True):\n\n    if file['type'] == 'directory':\n        subfolder_files = fs.find(file['name'])\n        file_count = len(subfolder_files)\n        file_type = \"Folder\"\n        size = None\n    else:\n        file_count = \"\"\n        file_type = \"File\"\n        size = file['size']\n    \n    data.append({\n        \"Name\": os.path.basename(file['name']),\n        \"Type\": file_type,\n        \"Size\": size or 0,\n        \"Nb Files\": file_count\n    })\n\ndf = pl.DataFrame(sorted(\n         data,\n         key=lambda x: (\n             0 if x[\"Type\"] == \"Folder\" else 1,\n             -x[\"Nb Files\"] if x[\"Nb Files\"] else 0,\n             -x[\"Size\"])\n        ))\\\n        .with_columns(pl.col('Size').map_elements(lambda x: humanize.naturalsize(x, binary=True) if x else \"\", return_dtype=pl.String).alias('Size'))\n\nprint(f\"Bucket : {bucket_name}\", df, sep = \"\\n\")"
  },
  {
    "objectID": "doc/tp/tp3.html#surveiller-son-service",
    "href": "doc/tp/tp3.html#surveiller-son-service",
    "title": "Découverte du Datalab",
    "section": "6 Surveiller son service",
    "text": "6 Surveiller son service\n\nSur la page du Datalab, allez dans Mes services\nCliquez sur le nom du service (Jupyter-python)\nCliquez sur Surveillance externe\n\nVous arrivez sur la page de l’outil Grafana qui permet d’observer les métriques de votre service."
  },
  {
    "objectID": "doc/tp/tp3.html#les-secrets",
    "href": "doc/tp/tp3.html#les-secrets",
    "title": "Découverte du Datalab",
    "section": "7 Les secrets",
    "text": "7 Les secrets\n\n\n\n\n\n\nEnigme du Père Fouras\n\n\n\nPlus j’ai de gardiens, moins je suis gardé.\nMoins j’ai de gardiens, plus je suis gardé.\nQui suis-je ?\n\n\nCertains éléments ne doivent pas être diffusés dans votre code (jetons d’accès, mots de passe…).\nPour éviter d’avoir à nettoyer votre code à chaque fois que vous le poussez sur GitHub, le datalab propose de gérer vos secrets.\n\n7.1 Créer un secret\n\nAllez dans Mes secrets\nCréez un Nouveau secret nommé projet_patate\nDouble-cliquez pour ouvrir ce secret\nAjoutez une variable\n\nNom : PATATE_TOKEN\nValeur : 123456\nCliquez sur ✅ pour valider\n\nAjoutez une autre variable\n\nNom : PATATE_PORT\nValeur : 5236\nCliquez sur ✅ pour valider\n\n\n\n\n7.2 Utiliser dans un service\n\nPréparez le lancement d’un service Rstudio\nDans la configuration, allez dans l’onglet Vault\nsecret : projet_patate\nLancez le service\n\nDans votre servives, les deux variables d’environnement ont été créées.\n\nVérifiez leur présence via le terminal : env | grep PATATE ou echo $PATATE_TOKEN\nOuvrez un notebook et récupérez la valeur de PATATE_TOKEN\nimport os\n\ntoken = os.environ[\"PATATE_TOKEN\"]\nprint(token)\nUne fois que vous avez fini de jouer, supprimez votre service\n\n\n\n\n\n\n\nNote\n\n\n\nCe TP avait pour but de vous familiariser avec le Datalab. Vous pouvez l’utiliser pour faire du Python, du R, créer une base de données (prochain TP) ou utiliser de nombreux autres outils."
  },
  {
    "objectID": "doc/tp/tp3.html#personnaliser-son-service",
    "href": "doc/tp/tp3.html#personnaliser-son-service",
    "title": "Découverte du Datalab",
    "section": "8 Personnaliser son service",
    "text": "8 Personnaliser son service\n🚧\n\nUtiliser un script d’initiation\nUtilser sa propre image Docker"
  },
  {
    "objectID": "doc/tp/tp2.html",
    "href": "doc/tp/tp2.html",
    "title": "Exercices vintages",
    "section": "",
    "text": "Lors du premier TP, nous avons utilisé DuckDB pour lire les données d’un fichier parquet. Aujourd’hui nous allons créer notre propre base de données PostgreSQL, puis y déclarer des tables et insérer de données. Enfin nous allons requêter ces données.\nLors de ce TP, vous allez :\n\nCréer votre base de données PostgreSQL\nLancer des scripts de création de tables et d’insertion de données\nRelier des tables en utilisant les jointures\nSélectionner et filtrer des données\n\n\n\n\n\n\n\nImportant\n\n\n\n\nÉcrivez des requêtes jolies !"
  },
  {
    "objectID": "doc/tp/tp2.html#introduction",
    "href": "doc/tp/tp2.html#introduction",
    "title": "Exercices vintages",
    "section": "",
    "text": "Lors du premier TP, nous avons utilisé DuckDB pour lire les données d’un fichier parquet. Aujourd’hui nous allons créer notre propre base de données PostgreSQL, puis y déclarer des tables et insérer de données. Enfin nous allons requêter ces données.\nLors de ce TP, vous allez :\n\nCréer votre base de données PostgreSQL\nLancer des scripts de création de tables et d’insertion de données\nRelier des tables en utilisant les jointures\nSélectionner et filtrer des données\n\n\n\n\n\n\n\nImportant\n\n\n\n\nÉcrivez des requêtes jolies !"
  },
  {
    "objectID": "doc/tp/tp2.html#lancement-des-services",
    "href": "doc/tp/tp2.html#lancement-des-services",
    "title": "Exercices vintages",
    "section": "1 Lancement des services",
    "text": "1 Lancement des services\n\n1.1 Datalab du GENES ou SSPCloud\nConnectez-vous à l’une des 2 instances suivantes d’Onyxia (elles sont quasiment identiques) :\n\nDatalab du GENES\nDatalab SSPCloud de l’INSEE\n\nsi besoin de créer un compte, utilisez votre mail ENSAI\n\n\n\n\n\n\n\n\nTip\n\n\n\nL’instance du GENES est plus récente donc encore en cours de rodage. Celle de l’INSEE est plus ancienne et donc plus robuste.\nPour éviter les problèmes de charges, vous utiliserez selon votre profil :\n\nélèves fonctionnaires ➡️ SSPCloud\nélèves ingénieurs ➡️ SSPCloud ou Datalab du GENES\n\n\n\n\n\n1.2 Base de données PostgreSQL\n\nLancez le service PostgreSQL\n\nLien direct de lancement : Datalab GENES ou SPPCloud\nou manuellement : Catalogue de services ➡️ Databases ➡️ Lancer\nConfiguration Postgresql ➡️ Primary : Mettez tous les paramètres au minimum (Persistent volume size, CPU, Memory)\n\nCela permettra d’éviter de réserver inutilement des ressources dont vous n’aurez pas besoin\n\nCliquez sur Lancer\n\nCopiez-collez dans un fichier texte les informations de connexion PostgreSQL : Hostname, Port, Database, Username, Password\n\n\n\n1.3 CloudBeaver\nNous venons de créer un SGBD, nous avons maintenant besoin d’un outil de gestion pour s’y connecter et envoyer des requêtes.\n\nLancez le service CloudBeaver\n\nCatalogue de services ➡️ Databases\n\nCopiez-collez également les informations de connexion au service CloudBeaver\nOuvrez ce service\n\n\n\n\n\n\n\nTip\n\n\n\nNormalement la connexion à la base de données PostgreSQL est détectée automatiquement.\nDans le cas contraire, il faut cliquer sur le +, puis sur New connection et renseigner les éléments de connexion.\n\n\n\nDans l’explorateur à gauche, clic droit sur bdd PostgreSQL ➡️ SQL Editor\n\nCela ouvre une fenêtre où vous pouvez écrire du code SQL pour interagir avec votre base de données.\n\n\n1.4 VM ENSAI\nUniquement en cas de soucis avec les Datalabs, vous pouvez faire le TP sur la VM.\n\n\n\n\n\n\nDBeaver sur la VM\n\n\n\n\n\nUn serveur héberge une base de données PostgreSQL.\nPour vous connecter à votre bdd, lancez le logiciel DBeaver depuis votre VM. Ensuite, uniquement la première fois, vous devrez effectuer le paramètrage ci-dessous et créer la connexion à votre bdd.\n\nParamètrage\n\nMenu Fenêtre &gt; Preference\n\nFormatage SQL\n\nCasse des mots clefs : UPPER\nInsert spaces for tabs\nAppliquer\n\nMetadonnées\n\nDécocher Ouvrir une connexion séparée pour la lecture des métadonnées\n\nEditeur SQL\n\nDécocher Ouvrir une connexion séparée pour chaque éditeur\n\n\n\n\n\nCréation de la connexion PostgreSQL\n\nCliquer sur l’icone Nouvelle connexion en haut à gauche sous fichier\nSélectionner PostgreSQL puis suivant\n\nHost : sgbd-eleves.domensai.ecole\nPort : 5432\nDatabase : idxxxx\nNom d’utilisateur : idxxxx\nMot de passe : idxxxx\nTest de connexion\nAcceptez les mises à jour des pilotes\nTerminer"
  },
  {
    "objectID": "doc/tp/tp2.html#méthodo-écrire-une-requête",
    "href": "doc/tp/tp2.html#méthodo-écrire-une-requête",
    "title": "Exercices vintages",
    "section": "2 Méthodo : Écrire une requête",
    "text": "2 Méthodo : Écrire une requête\nIl est parfois difficile d’écrire du premier coup LA requête qui répond directement à la question posée. Voici une méthode qui peut vous aider à écrire vos requêtes pas à pas :\n\n\n\n\n\n\nImaginons que l’on vous demande de lister les noms et prénoms des joueuses du club de la ville de Saint Quentin, dont le prénom commence par un A classées par elo décroissant.\njoueuse(id_joueuse, nom, prenom, elo, #id_club)\nclub(id_club, nom, ville)\n\n\n\n\n2.1 Listez les tables nécessaires\nCommencez par lister les tables nécessaires, puis joignez les. Ici nous avons besoin des 2 tables.\nUtilisez pour l’instant SELECT * pour sélectionner toutes les colonnes.\nSELECT *\n  FROM joueuse j\n  JOIN club c USING(id_club);\n\n\n2.2 Appliquez les filtres\nPour ne garder que les lignes qui nous intéressent :\n\nVille du club : Saint Quentin\nPrénom qui commence par un A**\n\nSELECT *\n  FROM joueuse j\n  JOIN club c USING(id_club)\n WHERE c.ville = 'Saint Quentin'\n   AND j.prenom LIKE 'A%';\n\n\n2.3 Ordonnez les résultats\nSELECT *\n  FROM joueuse j\n  JOIN club c USING(id_club)\n WHERE c.ville = 'Saint Quentin'\n   AND j.prenom LIKE 'A%'\n ORDER BY j.elo DESC;\n\n\n2.4 Sélectionner les colonnes requises\nIl est demandé de ne garder que les noms et prénoms des joueuses\nSELECT j.nom,\n       j.prenom\n  FROM joueuse j\n  JOIN club c USING(id_club)\n WHERE c.ville = 'Saint Quentin'\n   AND j.prenom LIKE 'A%'\n ORDER BY j.elo DESC;"
  },
  {
    "objectID": "doc/tp/tp2.html#exercices",
    "href": "doc/tp/tp2.html#exercices",
    "title": "Exercices vintages",
    "section": "3 Exercices",
    "text": "3 Exercices\n\n3.1 École de musique 🎸\nNous allons commencer par créer les tables et insérer les données :\n\nCopiez le contenu de ce script sql\nCollez dans la fenêtre SQL de CloudBeaver\nExécutez le script\n\nCliquez sur la petite icone sous les triangles oranges qui ressemble à 📜\nraccourci (ALT + X)\n\nVérifiez que votre schéma et vos tables sont créés\n\nDans l’explorateur : PostgreSQL ➡️ Databases ➡️ defaultdb ➡️ Schemas\nClic droit sur Schemas ➡️ Refresh\n\n\nSi tout est ok, vous n’avez plus besoin du script de création et d’insertion de données.\n\nSupprimez tout le contenu du code SQL que vous venez d’exécuter ou ouvrez un nouvel éditeur SQL\n\nVoici le modèle de données :\n\nVous pouvez maintenant commencer l’exercice et écrire les requêtes permettant de répondre aux questions suivantes :\n\nQuels sont les noms des instruments présents dans la base de données\nQuels sont les noms et adresses des adhérents\nQuelle est l’adresse de l’adhérent numéro 15\nQuels sont les numéros des adhérents de nom DUPONT\n\nRéalisez les jointures qui permettent d’obtenir :\n\nLes noms des instruments dont joue chaque adhérent\nLe nom des adhérents inscrits au cours numéro 6\nLes noms des cours ayant lieu le samedi et les noms des adhérents inscrits\nLes noms des cours auxquels sont inscrits les adhérents qui jouent du piano\nDe quels instruments jouent les personnes inscrites au cours de guitare classique (GUIT-CLASS)\n\n\n\n3.2 Location de DVD 💿\nIl fut un temps où des entreprises se spécialisaient dans la location de DVD. Dans cet exercice, une telle entreprise souhaite informatiser la gestion des prêts.\nVoici le Modèle de données :\n\n\nCréation de tables\n\nUtiliser le code ci-dessous pour créer le schéma et les 3 tables de droite\nDROP SCHEMA IF EXISTS dvd CASCADE;\n\nCREATE SCHEMA dvd;\n\nCREATE TABLE dvd.realisateur(\n    num_realisateur    INT PRIMARY KEY,\n    nom_realisateur    TEXT,\n    prenom_realisateur TEXT);\n\nCREATE TABLE dvd.film(\n    num_film       INT PRIMARY KEY,\n    titre          TEXT,\n    genre          TEXT,\n    date_sortie    DATE);\n\nCREATE TABLE dvd.a_realise(\n    num_film         INT REFERENCES dvd.film(num_film),\n    num_realisateur  INT REFERENCES dvd.realisateur(num_realisateur),\n    PRIMARY KEY (num_film, num_realisateur));\nÉcrivez les requêtes qui permettent de créer les 3 autres tables\nChargez les données avec ce script sql\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nAttention, ici l’ordre de création des tables a son importance.\nReprenons et modifions l’exemple ci-dessus :\n\nimaginez que vous essayez de créer en premier la table a_realise\nle champ num_film de cette table est une clé étrangère\nil référence la clé primaire num_film de la table film\nor si la table film n’existe pas, à votre avis, que va-t-il se passer ?\n\n\n\n\n\n\nRequêtes\nDonnez les requêtes pour obtenir :\n\nNom et prénom des adhérents\nTitre des films de la base\nNuméro d’adhérent de Pierre DUCHEMIN\nNom, Prénom et adresse de tous les DUCHEMIN\nNuméro des DVD du film la guerre des etoiles\n\nPour les 3 requêtes suivantes, vous afficherez les noms et prénoms sur une seule colonne. Utilisez le mot clé AS pour renommer cette colonne à l’affichage.\n\nNom, Prénom des adhérents ayant emprunté le film la guerre des etoiles\nNom, Prénom des adhérents ayant au moins un emprunt en cours (la date de fin de l’emprunt est nulle)\nNom, Prénom du réalisateur de la Guerre des étoiles\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nIl existe différentes manières de concaténer du texte :\n\nfonctions PostgreSQL CONCAT(), CONCAT_WS()\nopérateur ||\n\n\n\n\n\nTitre des films empruntés par Pierre DUCHEMIN, ainsi que dates de début et de fin\nNom des réalisateurs des films empruntés par Pierre DUCHEMIN\nNom des réalisateurs de films de science fiction ou policiers\n\nUtilisons maintenant des méthodes d’agrégation pour répondre aux questions suivantes :\n\nNombre de DVD dont le coût de l’emprunt est inférieur ou égal à 2€\nNombre d’emprunts ayant été effectués par Dominique Duchemin\nNombre de films différents ayant été empruntés par Dominique Duchemin\nNuméro des DVD en ordre décroissant du nombre de fois qu’ils ont été empruntés\nNuméro du DVD le plus récemment acheté\n\nQuelques questions sur les dates :\n\nQuelle a été la durée d’emprunt la plus longue\nEn date du 10 août 2010, combien de DVD sont en cours d’emprunt\nCombien de dvd ont été achetés chaque année\n\nPour terminer cet exercice, nous allons rechercher les titres des films qui n’ont jamais été empruntés. Procédons par étapes et écrivez les requêtes suivantes :\n\nDifférents numéros des films empruntés\nTitre des films ayant pour numéro 18, 19 ou 20\nTitre des films n’ayant pas pour numéros ni 18, ni 19, ni 20\nTitre des films n’ayant jamais été empruntés\n\n\n\n\n3.3 Rugby World Cup 🏉\n\n\n\n\n\n\nPour les plus rapides 🚀\n\n\n\nNous souhaitons informatiser les résultats de la coupe du monde de rugby. Pour cela nous avons créé les deux tables suivantes : equipe et matches.\nCommencez par créez et charger les tables avec ce script.\n\nDonner les noms des équipes qui ont joué à Nantes\nContre quelles équipes a joué l’équipe de France ?\nPour tous les matchs, affichez les informations suivantes :\n\nDate du match\nNom de la première équipe\nnombre de points de la première équipe\nnombre de points de la deuxième équipe\nnom de la deuxième équipe et lieu du match\n\nQuels sont les noms d’équipes qui ont gagné au moins deux matchs\nQuels sont les noms des équipes qui ont perdu tous leurs matchs\nPour chaque équipe donner le nombre de matchs qu’elles ont gagné ou perdu\nDonner le nombre total de points obtenus par équipe en classant les équipes de celle ayant marqué le plus à celle ayant marqué le moins"
  },
  {
    "objectID": "doc/tp/tp2.html#arrêtez-votre-service",
    "href": "doc/tp/tp2.html#arrêtez-votre-service",
    "title": "Exercices vintages",
    "section": "Arrêtez votre service",
    "text": "Arrêtez votre service\nC’est la fin du TP, vous pouvez maintenant sauvegarder votre travail et libérer les ressources réservées :\n\nCopiez votre code et collez le sur votre machine dans un fichier .sql\n\npar exemple dans P:/Cours1A/UE3-Bases-de-donnees-relationnelles/TP2/tp2.sql\nou en téléchargeant depuis CloudBeaver le fichier sql (petit bouton avec un dossier et une flèche vers le bas)\n\nRetournez sur la page d’accueil du Datalab\nAllez dans Mes Services et supprimez votre service"
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#programmation-avec-python-bases-et-applications",
    "href": "doc/cours/intro-python-slides.html#programmation-avec-python-bases-et-applications",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Programmation avec Python : Bases et Applications",
    "text": "Programmation avec Python : Bases et Applications\n\n18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#objectifs",
    "href": "doc/cours/intro-python-slides.html#objectifs",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Objectifs",
    "text": "Objectifs\n\nComprendre les bases du langage Python.\nManipuler les variables, types de données et structures de contrôle.\nExplorer les bibliothèques populaires : NumPy, Pandas, Matplotlib.\nIntroduire les concepts de machine learning avec Scikit-learn.\nRéaliser un projet intégrant toutes les notions vues."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#python",
    "href": "doc/cours/intro-python-slides.html#python",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Python",
    "text": "Python\n\nLangage polyvalent : data science, machine learning, développement web, automatisation.\nAvantages :\n\nSyntaxe simple et claire.\nLarge écosystème de bibliothèques open source.\nUtilisé par des entreprises, start-ups, et dans la recherche académique."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#organisation-des-tp",
    "href": "doc/cours/intro-python-slides.html#organisation-des-tp",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Organisation des TP",
    "text": "Organisation des TP\n\n5 TP + 1 projet final\nEnvironnements : VS Code, Jupyter Notebook, Google Colab.\nApproche : Alternance entre exercices guidés et explorations libres.\nLes projets doivent suivre une structuration rigoureuse :\n\nNettoyage des données.\nVisualisation.\nAnalyse et modélisation."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#ce-quil-faut-faire",
    "href": "doc/cours/intro-python-slides.html#ce-quil-faut-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Ce qu’il faut faire",
    "text": "Ce qu’il faut faire\n\nLisez attentivement les consignes de chaque TP.\nEssayez de résoudre les exercices par vous-même.\nRecherchez dans les cours et tutoriels en ligne.\nTravaillez en binôme pour échanger des idées.\nPosez des questions à l’enseignante en cas de blocage."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#à-ne-pas-faire",
    "href": "doc/cours/intro-python-slides.html#à-ne-pas-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "À ne pas faire",
    "text": "À ne pas faire\n\nUtiliser ChatGPT sans comprendre la solution.\nCopier/coller des réponses sans vérifier leur validité.\nNe pas documenter votre code ou vos démarches.\n\n\nNote : Ces pratiques nuisent à l’apprentissage et à la compréhension."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#évaluation",
    "href": "doc/cours/intro-python-slides.html#évaluation",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Évaluation",
    "text": "Évaluation\n\nPartie 1 : Projet à faire à la maison.\n\nSujet distribué une semaine avant la date de l’examen.\nAnalyse et exploration d’un dataset fourni.\nÀ rendre sous forme d’un notebook bien structuré :\n\nExplication des étapes de nettoyage.\nVisualisation des données et interprétation.\nConclusions et recommandations.\n\n\nPartie 2 : QCM.\n\nDurée : 2h.\nQuestions portant sur les concepts abordés pendant le cours et les TP.\nLa date sera définie à l’avance."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#bibliographie",
    "href": "doc/cours/intro-python-slides.html#bibliographie",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Bibliographie",
    "text": "Bibliographie\n\nDocumentation officielle Python\nPython for Everybody\nGoogle Colab\nPython Crash Course (Livre)\nW3Schools Python Tutorial"
  },
  {
    "objectID": "doc/cours/intro.html",
    "href": "doc/cours/intro.html",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "",
    "text": "18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro.html#programmation-avec-python-bases-et-applications",
    "href": "doc/cours/intro.html#programmation-avec-python-bases-et-applications",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "",
    "text": "18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro.html#objectifs",
    "href": "doc/cours/intro.html#objectifs",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Objectifs",
    "text": "Objectifs\n\nComprendre les bases du langage Python.\nManipuler les variables, types de données et structures de contrôle.\nExplorer les bibliothèques populaires : NumPy, Pandas, Matplotlib.\nIntroduire les concepts de machine learning avec Scikit-learn.\nRéaliser un projet intégrant toutes les notions vues."
  },
  {
    "objectID": "doc/cours/intro.html#python",
    "href": "doc/cours/intro.html#python",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Python",
    "text": "Python\n\nLangage polyvalent : data science, machine learning, développement web, automatisation.\nAvantages :\n\nSyntaxe simple et claire.\nLarge écosystème de bibliothèques open source.\nUtilisé par des entreprises, start-ups, et dans la recherche académique."
  },
  {
    "objectID": "doc/cours/intro.html#organisation-des-tp",
    "href": "doc/cours/intro.html#organisation-des-tp",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Organisation des TP",
    "text": "Organisation des TP\n\n5 TP + 1 projet final\nEnvironnements : VS Code, Jupyter Notebook, Google Colab.\nApproche : Alternance entre exercices guidés et explorations libres.\nLes projets doivent suivre une structuration rigoureuse :\n\nNettoyage des données.\nVisualisation.\nAnalyse et modélisation."
  },
  {
    "objectID": "doc/cours/intro.html#ce-quil-faut-faire",
    "href": "doc/cours/intro.html#ce-quil-faut-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Ce qu’il faut faire",
    "text": "Ce qu’il faut faire\n\nLisez attentivement les consignes de chaque TP.\nEssayez de résoudre les exercices par vous-même.\nRecherchez dans les cours et tutoriels en ligne.\nTravaillez en binôme pour échanger des idées.\nPosez des questions à l’enseignante en cas de blocage."
  },
  {
    "objectID": "doc/cours/intro.html#à-ne-pas-faire",
    "href": "doc/cours/intro.html#à-ne-pas-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "À ne pas faire",
    "text": "À ne pas faire\n\nUtiliser ChatGPT sans comprendre la solution.\nCopier/coller des réponses sans vérifier leur validité.\nNe pas documenter votre code ou vos démarches.\n\n\nNote : Ces pratiques nuisent à l’apprentissage et à la compréhension."
  },
  {
    "objectID": "doc/cours/intro.html#évaluation",
    "href": "doc/cours/intro.html#évaluation",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Évaluation",
    "text": "Évaluation\n\nPartie 1 : Projet à faire à la maison.\n\nSujet distribué une semaine avant la date de l’examen.\nAnalyse et exploration d’un dataset fourni.\nÀ rendre sous forme d’un notebook bien structuré :\n\nExplication des étapes de nettoyage.\nVisualisation des données et interprétation.\nConclusions et recommandations.\n\n\nPartie 2 : QCM.\n\nDurée : 2h.\nQuestions portant sur les concepts abordés pendant le cours et les TP.\nLa date sera définie à l’avance."
  },
  {
    "objectID": "doc/cours/intro.html#bibliographie",
    "href": "doc/cours/intro.html#bibliographie",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Bibliographie",
    "text": "Bibliographie\n\nDocumentation officielle Python\nPython for Everybody\nGoogle Colab\nPython Crash Course (Livre)\nW3Schools Python Tutorial"
  },
  {
    "objectID": "doc/glossaire.html",
    "href": "doc/glossaire.html",
    "title": "Glossaire",
    "section": "",
    "text": "🚧"
  },
  {
    "objectID": "doc/glossaire.html#python",
    "href": "doc/glossaire.html#python",
    "title": "Glossaire",
    "section": "Python",
    "text": "Python\nUn langage de programmation interprété, polyvalent, et accessible, utilisé dans divers domaines comme la data science, l’intelligence artificielle, le développement web et l’automatisation.\n\nVariable\nUn espace mémoire réservé pour stocker une valeur.\nEn Python, les variables n’ont pas de type explicitement défini, mais leur contenu en a un (ex : int, str, float).\nSynonymes : Identifiant, Conteneur.\n\n\nType de données\nCatégorie de données que peut prendre une variable : - int : nombres entiers. - float : nombres décimaux. - str : chaînes de caractères. - bool : valeurs booléennes (True, False).\nSynonymes : Type, Classe."
  },
  {
    "objectID": "doc/glossaire.html#structures-de-contrôle",
    "href": "doc/glossaire.html#structures-de-contrôle",
    "title": "Glossaire",
    "section": "Structures de contrôle",
    "text": "Structures de contrôle\n\nCondition\nPermet d’exécuter un bloc de code en fonction d’une condition.\nSyntaxe en Python :\nif condition:\n    # Faire quelque chose\nelif autre_condition:\n    # Faire autre chose\nelse:\n    # Faire par défaut"
  }
]