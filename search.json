[
  {
    "objectID": "doc/tp/tp1.html",
    "href": "doc/tp/tp1.html",
    "title": "Bien Démarrer Avec Python",
    "section": "",
    "text": "Ce TP est composé de deux parties principales qui vous guideront à travers les bases de Python, les structures de contrôle et les types de données.\n\n\nCe fichier introduit les concepts de base pour débuter avec Python :\n\nInstallation et configuration de l’environnement Python.\nPremiers pas avec les types de données (entiers, flottants, chaînes, etc.).\nUtilisation de l’instruction print() pour afficher des résultats.\nPremiers calculs et manipulations de variables.\n\nTélécharger le notebook : Bien démarrer avec Python\n\n\n\n\nDans cette partie, vous apprendrez à structurer vos programmes et à manipuler les données efficacement :\n\nLes structures de contrôle comme les boucles for et while.\nLes conditions if, elif, et else.\nManipulation des types de données complexes comme les listes, dictionnaires, et ensembles.\nExercices pratiques pour appliquer les concepts étudiés.\n\nTélécharger le notebook : Structure de contôle\nTélécharger le notebook : Types de Données\n\n\n\n\nÀ la fin de ce TP, vous serez capable de : - Manipuler les types de données de base en Python. - Utiliser des structures conditionnelles et des boucles pour contrôler l’exécution de votre code. - Résoudre des exercices pratiques pour renforcer vos compétences.\nTéléchargez les fichiers et commencez votre apprentissage dès maintenant !"
  },
  {
    "objectID": "doc/tp/tp1.html#partie-1-bien-démarrer-avec-python",
    "href": "doc/tp/tp1.html#partie-1-bien-démarrer-avec-python",
    "title": "Bien Démarrer Avec Python",
    "section": "",
    "text": "Ce fichier introduit les concepts de base pour débuter avec Python :\n\nInstallation et configuration de l’environnement Python.\nPremiers pas avec les types de données (entiers, flottants, chaînes, etc.).\nUtilisation de l’instruction print() pour afficher des résultats.\nPremiers calculs et manipulations de variables.\n\nTélécharger le notebook : Bien démarrer avec Python"
  },
  {
    "objectID": "doc/tp/tp1.html#partie-2-structures-de-contrôle-et-types-de-données",
    "href": "doc/tp/tp1.html#partie-2-structures-de-contrôle-et-types-de-données",
    "title": "Bien Démarrer Avec Python",
    "section": "",
    "text": "Dans cette partie, vous apprendrez à structurer vos programmes et à manipuler les données efficacement :\n\nLes structures de contrôle comme les boucles for et while.\nLes conditions if, elif, et else.\nManipulation des types de données complexes comme les listes, dictionnaires, et ensembles.\nExercices pratiques pour appliquer les concepts étudiés.\n\nTélécharger le notebook : Structure de contôle\nTélécharger le notebook : Types de Données"
  },
  {
    "objectID": "doc/tp/tp1.html#objectif",
    "href": "doc/tp/tp1.html#objectif",
    "title": "Bien Démarrer Avec Python",
    "section": "",
    "text": "À la fin de ce TP, vous serez capable de : - Manipuler les types de données de base en Python. - Utiliser des structures conditionnelles et des boucles pour contrôler l’exécution de votre code. - Résoudre des exercices pratiques pour renforcer vos compétences.\nTéléchargez les fichiers et commencez votre apprentissage dès maintenant !"
  },
  {
    "objectID": "doc/tp/tp2.html",
    "href": "doc/tp/tp2.html",
    "title": "Fonctions, Modules et POO",
    "section": "",
    "text": "Comprendre et appliquer les fonctions en Python.\nStructurer un projet Python en utilisant des modules.\nDécouvrir les bases de la programmation orientée objet.\n\nVous pouvez télécharger le fichier .ipynb en cliquant ici\n\n\n\n\n\nÉcrivez une fonction qui affiche le tableau de multiplication d’un entier positif donné.\n\n\n\n\nÉcrivez une fonction qui prend en paramètres une liste L et un élément a, et qui retourne True si a est présent dans la liste, et False sinon.\n\n\n\n\nÉcrivez une fonction qui prend une liste L de nombres et un entier n en paramètres, puis renvoie une nouvelle liste où chaque élément est multiplié par n.\n\n\n\n\nÉcrivez une fonction qui prend en paramètres une liste L et un élément a, et retourne la position de a dans la liste. Si l’élément n’est pas présent, renvoyez -1. N’utilisez pas la fonction index().\n\n\n\n\nÉcrivez une fonction qui prend une liste de nombres entiers en paramètre, et renvoie un dictionnaire où les clés sont les nombres et les valeurs indiquent leur parité ('pair' ou 'impair').\n\n\n\n\nÉcrivez une fonction qui prend une liste en paramètre et retourne une liste de tuples (élément, occurrence) représentant chaque élément et son nombre d’apparitions dans la liste, sans répétitions.\n\n\n\n\nCréez une liste en compréhension qui contient uniquement les carrés des nombres pairs d’une liste donnée.\n\n\n\n\nCréez un dictionnaire en compréhension qui associe chaque élément d’une liste à son carré.\n\n\n\n\n\n\n\n\nDéfinissez une classe Book avec les attributs : title, author et price.\nImplémentez un constructeur pour initialiser ces attributs.\nAjoutez une méthode view() qui affiche les informations du livre.\nTestez la classe en créant plusieurs instances.\n\n\n\n\n\n\nImplémentez une classe Polynome représentant un polynôme du second degré ( P(x) = ax^2 + bx + c ).\nAjoutez les méthodes suivantes :\n\neval(x) : calcule la valeur de ( P(x) ) pour une valeur donnée de ( x ).\ndelta() : calcule le discriminant ( = b^2 - 4ac ).\nracines() : calcule les racines du polynôme si elles existent.\n\n\n\n\n\n\n\nCréez une classe Domino avec deux attributs représentant les valeurs des deux parties du domino.\nAjoutez une méthode affiche_points() pour afficher les points du domino.\nAjoutez une méthode valeur() pour retourner la somme des points.\nTestez votre classe en instanciant plusieurs dominos.\n\n\n\n\n\n\nÉcrivez une fonction récursive pour calculer la somme des éléments d’une liste.\nImplémentez une fonction récursive pour calculer la suite de Fibonacci ( F(n) ).\n\nLa suite de Fibonacci est une série de nombres dans laquelle chaque terme est la somme des deux termes précédents. La formule mathématique de cette suite est définie comme suit :\n[ F(n) =\n\\[\\begin{cases}\n0 & \\text{si } n = 0, \\\\\n1 & \\text{si } n = 1, \\\\\nF(n-1) + F(n-2) & \\text{si } n &gt; 1.\n\\end{cases}\\]\n]\n\n\n\nPour ( n = 0, 1, 2, , 9 ), la suite de Fibonacci est donnée par :\n[ F(0) = 0, , F(1) = 1, , F(2) = 1, , F(3) = 2, , F(4) = 3, , F(5) = 5, , F(6) = 8, , F(7) = 13, , F(8) = 21, , F(9) = 34. ]"
  },
  {
    "objectID": "doc/tp/tp2.html#objectifs",
    "href": "doc/tp/tp2.html#objectifs",
    "title": "Fonctions, Modules et POO",
    "section": "",
    "text": "Comprendre et appliquer les fonctions en Python.\nStructurer un projet Python en utilisant des modules.\nDécouvrir les bases de la programmation orientée objet.\n\nVous pouvez télécharger le fichier .ipynb en cliquant ici"
  },
  {
    "objectID": "doc/tp/tp2.html#partie-1-fonctions",
    "href": "doc/tp/tp2.html#partie-1-fonctions",
    "title": "Fonctions, Modules et POO",
    "section": "",
    "text": "Écrivez une fonction qui affiche le tableau de multiplication d’un entier positif donné.\n\n\n\n\nÉcrivez une fonction qui prend en paramètres une liste L et un élément a, et qui retourne True si a est présent dans la liste, et False sinon.\n\n\n\n\nÉcrivez une fonction qui prend une liste L de nombres et un entier n en paramètres, puis renvoie une nouvelle liste où chaque élément est multiplié par n.\n\n\n\n\nÉcrivez une fonction qui prend en paramètres une liste L et un élément a, et retourne la position de a dans la liste. Si l’élément n’est pas présent, renvoyez -1. N’utilisez pas la fonction index().\n\n\n\n\nÉcrivez une fonction qui prend une liste de nombres entiers en paramètre, et renvoie un dictionnaire où les clés sont les nombres et les valeurs indiquent leur parité ('pair' ou 'impair').\n\n\n\n\nÉcrivez une fonction qui prend une liste en paramètre et retourne une liste de tuples (élément, occurrence) représentant chaque élément et son nombre d’apparitions dans la liste, sans répétitions.\n\n\n\n\nCréez une liste en compréhension qui contient uniquement les carrés des nombres pairs d’une liste donnée.\n\n\n\n\nCréez un dictionnaire en compréhension qui associe chaque élément d’une liste à son carré."
  },
  {
    "objectID": "doc/tp/tp2.html#partie-2-programmation-orientée-objet-poo",
    "href": "doc/tp/tp2.html#partie-2-programmation-orientée-objet-poo",
    "title": "Fonctions, Modules et POO",
    "section": "",
    "text": "Définissez une classe Book avec les attributs : title, author et price.\nImplémentez un constructeur pour initialiser ces attributs.\nAjoutez une méthode view() qui affiche les informations du livre.\nTestez la classe en créant plusieurs instances.\n\n\n\n\n\n\nImplémentez une classe Polynome représentant un polynôme du second degré ( P(x) = ax^2 + bx + c ).\nAjoutez les méthodes suivantes :\n\neval(x) : calcule la valeur de ( P(x) ) pour une valeur donnée de ( x ).\ndelta() : calcule le discriminant ( = b^2 - 4ac ).\nracines() : calcule les racines du polynôme si elles existent.\n\n\n\n\n\n\n\nCréez une classe Domino avec deux attributs représentant les valeurs des deux parties du domino.\nAjoutez une méthode affiche_points() pour afficher les points du domino.\nAjoutez une méthode valeur() pour retourner la somme des points.\nTestez votre classe en instanciant plusieurs dominos.\n\n\n\n\n\n\nÉcrivez une fonction récursive pour calculer la somme des éléments d’une liste.\nImplémentez une fonction récursive pour calculer la suite de Fibonacci ( F(n) ).\n\nLa suite de Fibonacci est une série de nombres dans laquelle chaque terme est la somme des deux termes précédents. La formule mathématique de cette suite est définie comme suit :\n[ F(n) =\n\\[\\begin{cases}\n0 & \\text{si } n = 0, \\\\\n1 & \\text{si } n = 1, \\\\\nF(n-1) + F(n-2) & \\text{si } n &gt; 1.\n\\end{cases}\\]\n]\n\n\n\nPour ( n = 0, 1, 2, , 9 ), la suite de Fibonacci est donnée par :\n[ F(0) = 0, , F(1) = 1, , F(2) = 1, , F(3) = 2, , F(4) = 3, , F(5) = 5, , F(6) = 8, , F(7) = 13, , F(8) = 21, , F(9) = 34. ]"
  },
  {
    "objectID": "doc/glossaire.html",
    "href": "doc/glossaire.html",
    "title": "Glossaire",
    "section": "",
    "text": "🚧"
  },
  {
    "objectID": "doc/glossaire.html#python",
    "href": "doc/glossaire.html#python",
    "title": "Glossaire",
    "section": "Python",
    "text": "Python\nUn langage de programmation interprété, polyvalent, et accessible, utilisé dans divers domaines comme la data science, l’intelligence artificielle, le développement web et l’automatisation.\n\nVariable\nUn espace mémoire réservé pour stocker une valeur.\nEn Python, les variables n’ont pas de type explicitement défini, mais leur contenu en a un (ex : int, str, float).\nSynonymes : Identifiant, Conteneur.\n\n\nType de données\nCatégorie de données que peut prendre une variable : - int : nombres entiers. - float : nombres décimaux. - str : chaînes de caractères. - bool : valeurs booléennes (True, False).\nSynonymes : Type, Classe."
  },
  {
    "objectID": "doc/glossaire.html#structures-de-contrôle",
    "href": "doc/glossaire.html#structures-de-contrôle",
    "title": "Glossaire",
    "section": "Structures de contrôle",
    "text": "Structures de contrôle\n\nCondition\nPermet d’exécuter un bloc de code en fonction d’une condition.\nSyntaxe en Python :\nif condition:\n    # Faire quelque chose\nelif autre_condition:\n    # Faire autre chose\nelse:\n    # Faire par défaut"
  },
  {
    "objectID": "doc/cours/typedonnees.html",
    "href": "doc/cours/typedonnees.html",
    "title": "Les Types de données en Python",
    "section": "",
    "text": "Python propose des types de données avancés pour manipuler des collections de données ou des structures complexes. Ces types sont essentiels pour gérer des informations organisées."
  },
  {
    "objectID": "doc/cours/typedonnees.html#les-listes-list",
    "href": "doc/cours/typedonnees.html#les-listes-list",
    "title": "Les Types de données en Python",
    "section": "1 Les Listes (list)",
    "text": "1 Les Listes (list)\nLes listes sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de types différents.\nCaractéristiques :\n\nOrdonnées : Les éléments conservent leur position dans l’ordre dans lequel ils ont été ajoutés.\nModifiables : Les listes peuvent être modifiées après leur création (ajout, suppression, modification d’éléments).\nHétérogènes : Une liste peut contenir des éléments de différents types.\n\n\n\nCréation de listes\nLes listes peuvent être créées à partir d’une série d’éléments séparés par des virgules et entourés de crochets [ ].\nExemple :\nfruits = [\"pomme\", \"banane\", \"cerise\"]\nnombres = [1, 2, 3, 4]\nfruits.append(\"orange\")  # Ajoute un élément\nprint(fruits)\n\n\n\nOpérations CRUD sur les Listes en Python\nLes opérations CRUD (Create, Read, Update, Delete) représentent les actions fondamentales que l’on peut effectuer sur des données dans une application. Ces actions sont souvent utilisées dans la gestion des bases de données, mais elles s’appliquent également aux structures de données comme les listes en Python :\n\nCreate (Créer) : Ajouter de nouvelles données.\nRead (Lire) : Consulter ou accéder aux données existantes.\nUpdate (Mettre à jour) : Modifier les données existantes.\nDelete (Supprimer) : Effacer les données.\n\n\n\nCréer une Liste (Create)\nPour créer une liste, utilisez des crochets ([]) et séparez les éléments par des virgules.\nExemple :\n# Créer une liste vide\nma_liste = []\n\n# Créer une liste avec des éléments\nfruits = [\"pomme\", \"banane\", \"cerise\"]\nprint(fruits)  # Affiche : ['pomme', 'banane', 'cerise']\n\n\n\n\nLire les Données (Read)\n\nAccéder à un élément par son index\nLes indices commencent à 0.\nExemple :\nfruits = [\"pomme\", \"banane\", \"cerise\"]\nprint(fruits[0])  # Affiche : \"pomme\"\nprint(fruits[-1])  # Affiche : \"cerise\" (dernier élément)\n\n\n\nParcourir une liste\nVous pouvez utiliser une boucle pour parcourir tous les éléments.\nExemple :\nfor fruit in fruits:\n    print(fruit)\n\n\n\nLongueur de la liste\nUtilisez la fonction len() pour connaître le nombre d’éléments dans une liste.\nExemple :\nfruits = [\"pomme\", \"banane\", \"cerise\"]\nprint(len(fruits))  # Affiche : 3\n\n\n\n\nMettre à Jour une Liste (Update)\n\nModifier un élément existant\nAccédez à l’élément par son index et assignez-lui une nouvelle valeur.\nExemple :\nfruits = [\"pomme\", \"banane\", \"cerise\"]\nfruits[1] = \"orange\"  # Remplace \"banane\" par \"orange\"\nprint(fruits)  # Affiche : ['pomme', 'orange', 'cerise']\n\n\n\nAjouter des éléments\n\nÀ la fin de la liste :\nUtilisez la méthode append().\nExemple :\nfruits = [\"pomme\", \"orange\", \"cerise\"]\nfruits.append(\"mangue\")\nprint(fruits)  # Affiche : ['pomme', 'orange', 'cerise', 'mangue']\n\n\n\n\nÀ une position spécifique\nUtilisez la méthode insert() pour insérer un élément à une position spécifique dans une liste.\nExemple :\nfruits = [\"pomme\", \"orange\", \"cerise\", \"mangue\"]\nfruits.insert(1, \"fraise\")  # Ajoute \"fraise\" à l'index 1\nprint(fruits)  # Affiche : ['pomme', 'fraise', 'orange', 'cerise', 'mangue']\n\n\n\nFusionner deux listes\nPour fusionner deux listes, vous pouvez utiliser l’opérateur + ou la méthode extend().\nExemple :\nlegumes = [\"carotte\", \"tomate\"]\nfruits = [\"pomme\", \"fraise\", \"orange\", \"cerise\", \"mangue\"]\n\n# Fusion avec extend()\nfruits.extend(legumes)\nprint(fruits)  # Affiche : ['pomme', 'fraise', 'orange', 'cerise', 'mangue', 'carotte', 'tomate']\n\n\n\nFusionner deux listes avec l’opérateur +\nVous pouvez également utiliser l’opérateur + pour créer une nouvelle liste fusionnée.\nExemple :\nlegumes = [\"carotte\", \"tomate\"]\nfruits = [\"pomme\", \"fraise\", \"orange\", \"cerise\", \"mangue\"]\n\n# Fusion avec +\nnouvelle_liste = fruits + legumes\nprint(nouvelle_liste)  # Affiche : ['pomme', 'fraise', 'orange', 'cerise', 'mangue', 'carotte', 'tomate']\n\n\n\n\nSupprimer des Éléments (Delete)\n\nSupprimer un élément par sa valeur\nUtilisez la méthode remove().\nExemple :\nfruits.remove(\"orange\")  # Supprime \"orange\"\nprint(fruits)  # Affiche : ['pomme', 'fraise', 'cerise', 'mangue', 'carotte', 'tomate']\n\n\n\n\nSupprimer un élément par son index\nUtilisez l’instruction del ou la méthode pop().\n\nAvec del :\ndel fruits[0]  # Supprime le premier élément\nprint(fruits)  # Affiche : ['fraise', 'cerise', 'mangue', 'carotte', 'tomate']\n\n\n\n\nUtilisation de pop()\nLa méthode pop() supprime un élément d’une liste et le retourne. Par défaut, elle supprime le dernier élément de la liste, mais vous pouvez également lui spécifier un index pour supprimer un élément particulier.\nExemple :\nfruits = ['pomme', 'fraise', 'cerise', 'mangue', 'carotte', 'tomate']\n\n# Supprimer et retourner le dernier élément\ndernier_fruit = fruits.pop()  # Supprime \"tomate\" de la liste\nprint(dernier_fruit)  # Affiche : \"tomate\"\nprint(fruits)  # Affiche : ['pomme', 'fraise', 'cerise', 'mangue', 'carotte']\n\n\n\nSupprimer tous les éléments avec clear()\nLa méthode clear() supprime tous les éléments de la liste, laissant une liste vide. Contrairement à pop(), elle ne retourne aucun élément.\nExemple :\nfruits = ['pomme', 'fraise', 'cerise', 'mangue', 'carotte']\n\n# Supprimer tous les éléments\nfruits.clear()\nprint(fruits)  # Affiche : []\n\n\n\nDifférence entre pop() et clear()\n\n\n\n\n\n\n\n\nMéthode\nFonctionnalité\nExemple de résultat\n\n\n\n\npop()\nSupprime et retourne un seul élément de la liste (par défaut, le dernier).\nfruits.pop() -&gt; retourne \"tomate\", modifie la liste.\n\n\nclear()\nSupprime tous les éléments de la liste sans retourner quoi que ce soit.\nfruits.clear() -&gt; retourne None, vide la liste.\n\n\n\n\npop() est utile lorsque vous voulez traiter ou sauvegarder l’élément supprimé.\nclear() est idéal pour réinitialiser une liste sans conserver ses éléments.\n\n\n\n\nRésumé des Méthodes CRUD sur les Listes\n\n\n\n\n\n\n\n\nOpération\nMéthode\nDescription\n\n\n\n\nCreate\n[], append(), insert()\nCréer ou ajouter des éléments.\n\n\nRead\nindex, len(), for loop\nLire ou parcourir les éléments.\n\n\nUpdate\nindex, append(), extend()\nModifier ou ajouter des éléments.\n\n\nDelete\nremove(), pop(), del, clear()\nSupprimer des éléments ou tout vider."
  },
  {
    "objectID": "doc/cours/typedonnees.html#les-tuples-tuple",
    "href": "doc/cours/typedonnees.html#les-tuples-tuple",
    "title": "Les Types de données en Python",
    "section": "2 Les Tuples (tuple)",
    "text": "2 Les Tuples (tuple)\nLes tuples sont des collections ordonnées, mais immuables (non modifiables après leur création). Ils sont souvent utilisés pour stocker des données constantes.\nCaractéristiques :\n\nOrdonnés : Les éléments conservent leur position.\nImmuables : Impossible de modifier, ajouter ou supprimer des éléments après leur création.\n\n\n\nCréation de Tuples\nUn tuple peut être créé en plaçant une série d’éléments séparés par des virgules dans des parenthèses ().\nExemple :\nmon_tuple = (1, 2, 3)\nprint(mon_tuple)  # Affiche : (1, 2, 3)\n\n\n\nOpérations CRUD sur les Tuples\nComme les tuples sont immuables, les opérations Update et Delete diffèrent légèrement de celles des listes. Voici un aperçu des actions fondamentales :\n\nCreate (Créer) : Ajouter de nouvelles données.\nRead (Lire) : Consulter ou accéder aux données existantes.\nUpdate (Mettre à jour) : Pas directement possible (les tuples sont immuables).\nDelete (Supprimer) : Vous pouvez supprimer le tuple entier mais pas ses éléments individuels.\n\n\n\nCréer un Tuple (Create)\nExemple :\n# Créer un tuple avec des éléments\nmon_tuple = (1, 'Python', 3.14)\nprint(mon_tuple)  # Affiche : (1, 'Python', 3.14)\nVous pouvez également créer un tuple sans parenthèses (packing) :\nmon_tuple = 1, 'Python', 3.14\n\n\nLire les Données (Read)\nAccéder à un élément par son index :\nmon_tuple = (1, 'Python', 3.14)\nprint(mon_tuple[1])  # Affiche : 'Python'\nParcourir un tuple avec une boucle :\nfor element in mon_tuple:\n    print(element)\nLongueur du tuple :\nprint(len(mon_tuple))  # Affiche : 3\n\n\nMettre à Jour un Tuple (Update)\nLes tuples sont immutables, donc vous ne pouvez pas modifier leurs éléments directement. Cependant, vous pouvez créer un nouveau tuple basé sur l’ancien.\nExemple :\nmon_tuple = (1, 2, 3)\nnouveau_tuple = mon_tuple + (4, 5)\nprint(nouveau_tuple)  # Affiche : (1, 2, 3, 4, 5)\n\n\nSupprimer un Tuple (Delete)\nVous ne pouvez pas supprimer un élément spécifique d’un tuple, mais vous pouvez supprimer le tuple entier.\nExemple :\nmon_tuple = (1, 2, 3)\ndel mon_tuple\n\n\n\nAvantages des Tuples\n\nImmutabilité : Protège les données contre les modifications accidentelles.\nPerformance : Les tuples sont plus rapides à traiter que les listes.\nUtilisation dans les clés de dictionnaire : Les tuples peuvent être utilisés comme clés dans un dictionnaire (contrairement aux listes).\n\nExemple :\ncoordonnees = {\n    (0, 0): 'Origine',\n    (1, 2): 'Point A'\n}\nprint(coordonnees[(1, 2)])  # Affiche : 'Point A'\n\n\nDifférences entre Listes et Tuples\n\n\n\nCaractéristique\nListe\nTuple\n\n\n\n\nMutabilité\nMutable\nImmuable\n\n\nSyntaxe\n[ ]\n( )\n\n\nPerformance\nPlus lente\nPlus rapide\n\n\nUtilisation\nDonnées modifiables\nDonnées fixes"
  },
  {
    "objectID": "doc/cours/typedonnees.html#les-dictionnaires-dict",
    "href": "doc/cours/typedonnees.html#les-dictionnaires-dict",
    "title": "Les Types de données en Python",
    "section": "3 Les Dictionnaires (dict)",
    "text": "3 Les Dictionnaires (dict)\nLes dictionnaires sont des collections non ordonnées (dans les versions antérieures à Python 3.7) qui stockent des paires clé-valeur. Chaque clé doit être unique.\nCaractéristiques :\n\nAccès rapide : Vous pouvez accéder rapidement aux valeurs à l’aide de leurs clés.\nModifiables : Vous pouvez ajouter, modifier ou supprimer des paires clé-valeur.\nClés uniques : Une clé ne peut être présente qu’une seule fois.\n\n\nCréation de Dictionnaires\nUn dictionnaire peut être créé en utilisant des accolades {} et des paires clé-valeur séparées par des deux-points :.\nExemple :\nmon_dict = {\n    'nom': 'Alice',\n    'age': 25,\n    'ville': 'Paris'\n}\nprint(mon_dict)  # Affiche : {'nom': 'Alice', 'age': 25, 'ville': 'Paris'}\n\n\nOpérations CRUD sur les Dictionnaires\nLes dictionnaires permettent les opérations fondamentales CRUD (Create, Read, Update, Delete) comme suit :\n\nCreate (Créer) : Ajouter de nouvelles paires clé-valeur.\nRead (Lire) : Accéder à une valeur via sa clé.\nUpdate (Mettre à jour) : Modifier la valeur associée à une clé existante ou ajouter une nouvelle clé.\nDelete (Supprimer) : Supprimer une paire clé-valeur.\n\n\nCréer un Dictionnaire (Create)\nExemple :\n# Créer un dictionnaire vide\nmon_dict = {}\n\n# Ajouter des paires clé-valeur\nmon_dict['nom'] = 'Alice'\nmon_dict['age'] = 25\nprint(mon_dict)  # Affiche : {'nom': 'Alice', 'age': 25}\n\n\nLire les Données (Read)\nAccéder à une valeur par sa clé :\nmon_dict = {'nom': 'Alice', 'age': 25, 'ville': 'Paris'}\nprint(mon_dict['nom'])  # Affiche : Alice\nUtiliser la méthode get() pour éviter les erreurs :\nprint(mon_dict.get('pays', 'Clé introuvable'))  # Affiche : Clé introuvable\nParcourir un dictionnaire :\nfor cle, valeur in mon_dict.items():\n    print(f'{cle} : {valeur}')\nClés et valeurs :\nprint(mon_dict.keys())   # Affiche les clés : dict_keys(['nom', 'age', 'ville'])\nprint(mon_dict.values()) # Affiche les valeurs : dict_values(['Alice', 25, 'Paris'])\n\n\nMettre à Jour un Dictionnaire (Update)\nAjouter ou modifier une clé :\nmon_dict = {'nom': 'Alice', 'age': 25}\nmon_dict['ville'] = 'Paris'  # Ajout\nmon_dict['age'] = 26         # Mise à jour\nprint(mon_dict)  # Affiche : {'nom': 'Alice', 'age': 26, 'ville': 'Paris'}\nFusionner deux dictionnaires :\nautre_dict = {'pays': 'France', 'profession': 'Ingénieure'}\nmon_dict.update(autre_dict)\nprint(mon_dict)  # Affiche : {'nom': 'Alice', 'age': 26, 'ville': 'Paris', 'pays': 'France', 'profession': 'Ingénieure'}\n\n\nSupprimer des Éléments (Delete)\nSupprimer une paire clé-valeur :\nmon_dict = {'nom': 'Alice', 'age': 25, 'ville': 'Paris'}\ndel mon_dict['age']\nprint(mon_dict)  # Affiche : {'nom': 'Alice', 'ville': 'Paris'}\nSupprimer et retourner une valeur avec pop() :\nville = mon_dict.pop('ville')\nprint(ville)  # Affiche : Paris\nprint(mon_dict)  # Affiche : {'nom': 'Alice'}\nSupprimer tous les éléments avec clear() :\nmon_dict.clear()\nprint(mon_dict)  # Affiche : {}\n\n\n\nAvantages des Dictionnaires\n\nRapidité : Accès direct aux valeurs via les clés.\nFlexible : Peut contenir des données de types variés.\nOrganisation : Idéal pour structurer des données complexes.\n\nExemple :\nutilisateur = {\n    'id': 123,\n    'nom': 'Alice',\n    'contact': {\n        'email': 'alice@example.com',\n        'telephone': '123-456-7890'\n    }\n}\nprint(utilisateur['contact']['email'])  # Affiche : alice@example.com\n\n\nDifférences entre Listes et Dictionnaires\n\n\n\n\n\n\n\n\nCaractéristique\nListe\nDictionnaire\n\n\n\n\nAccès aux données\nPar index numérique\nPar clé\n\n\nStructure\nSéquence ordonnée\nPaires clé-valeur\n\n\nMutabilité\nMutable\nMutable (clés immuables)"
  },
  {
    "objectID": "doc/cours/typedonnees.html#les-ensembles-set",
    "href": "doc/cours/typedonnees.html#les-ensembles-set",
    "title": "Les Types de données en Python",
    "section": "4 Les Ensembles (set)",
    "text": "4 Les Ensembles (set)\nLes ensembles sont des collections non ordonnées et uniques (chaque élément apparaît une seule fois). Ils sont utiles pour éliminer les doublons ou effectuer des opérations mathématiques sur des ensembles.\nCaractéristiques :\n\nNon ordonnés : Les éléments n’ont pas de position fixe.\nÉléments uniques : Les doublons sont automatiquement supprimés.\nOpérations mathématiques : Permettent des opérations comme l’union, l’intersection, la différence, etc.\n\n\nCréation d’Ensembles\nUn ensemble peut être créé en utilisant la fonction set() ou en plaçant des éléments entre accolades {}.\nExemple :\nmon_set = {1, 2, 3, 4}\nprint(mon_set)  # Affiche : {1, 2, 3, 4}\n\n# Création d'un ensemble à partir d'une liste\nmon_set = set([1, 2, 2, 3])\nprint(mon_set)  # Affiche : {1, 2, 3} (les doublons sont supprimés)\n\n\nOpérations CRUD sur les Ensembles\nLes ensembles prennent en charge les opérations fondamentales CRUD (Create, Read, Update, Delete) :\n\nCreate (Créer) : Ajouter de nouveaux éléments.\nRead (Lire) : Vérifier la présence d’un élément.\nUpdate (Mettre à jour) : Ajouter ou supprimer des éléments.\nDelete (Supprimer) : Supprimer des éléments ou réinitialiser l’ensemble.\n\n\nCréer un Ensemble (Create)\nExemple :\n# Créer un ensemble vide\nmon_set = set()\n\n# Ajouter des éléments\nmon_set.add(1)\nmon_set.add(2)\nprint(mon_set)  # Affiche : {1, 2}\n\n\nLire les Données (Read)\nVérifier la présence d’un élément :\nmon_set = {1, 2, 3}\nprint(1 in mon_set)  # Affiche : True\nprint(4 in mon_set)  # Affiche : False\nParcourir un ensemble avec une boucle :\nfor element in mon_set:\n    print(element)\nTaille de l’ensemble :\nprint(len(mon_set))  # Affiche : 3\n\n\nMettre à Jour un Ensemble (Update)\nAjouter des éléments :\nmon_set = {1, 2}\nmon_set.add(3)  # Ajoute un seul élément\nmon_set.update([4, 5])  # Ajoute plusieurs éléments\nprint(mon_set)  # Affiche : {1, 2, 3, 4, 5}\nSupprimer des éléments :\nAvec remove() :\nmon_set.remove(2)  # Supprime 2 de l'ensemble\nprint(mon_set)  # Affiche : {1, 3, 4, 5}\nAvec discard() (ne lève pas d’erreur si l’élément n’existe pas) :\nmon_set.discard(10)  # Aucun effet si 10 n'est pas présent\n\n\nSupprimer des Éléments (Delete)\nSupprimer un élément avec pop() :\nmon_set = {1, 2, 3}\nelement = mon_set.pop()  # Supprime et retourne un élément aléatoire\nprint(element)  # Affiche : 1 (ou un autre élément)\nprint(mon_set)  # Affiche : {2, 3}\nSupprimer tous les éléments avec clear() :\nmon_set.clear()\nprint(mon_set)  # Affiche : set()\n\n\n\nOpérations Mathématiques avec les Ensembles\nLes ensembles permettent des opérations mathématiques classiques :\nUnion : Combine tous les éléments des deux ensembles.\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\nprint(set1 | set2)  # Affiche : {1, 2, 3, 4, 5}\nIntersection : Récupère les éléments communs aux deux ensembles.\nprint(set1 & set2)  # Affiche : {3}\nDifférence : Récupère les éléments présents dans le premier ensemble mais pas dans le second.\nprint(set1 - set2)  # Affiche : {1, 2}\nDifférence Symétrique : Récupère les éléments présents dans un seul des deux ensembles.\nprint(set1 ^ set2)  # Affiche : {1, 2, 4, 5}"
  },
  {
    "objectID": "doc/cours/typedonnees-slides.html#les-listes-list",
    "href": "doc/cours/typedonnees-slides.html#les-listes-list",
    "title": "Les Types de données en Python",
    "section": "Les Listes (list)",
    "text": "Les Listes (list)\nLes listes sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de types différents.\nCaractéristiques :\n\nOrdonnées : Les éléments conservent leur position dans l’ordre dans lequel ils ont été ajoutés.\nModifiables : Les listes peuvent être modifiées après leur création (ajout, suppression, modification d’éléments).\nHétérogènes : Une liste peut contenir des éléments de différents types."
  },
  {
    "objectID": "doc/cours/typedonnees-slides.html#les-tuples-tuple",
    "href": "doc/cours/typedonnees-slides.html#les-tuples-tuple",
    "title": "Les Types de données en Python",
    "section": "Les Tuples (tuple)",
    "text": "Les Tuples (tuple)\nLes tuples sont des collections ordonnées, mais immuables (non modifiables après leur création). Ils sont souvent utilisés pour stocker des données constantes.\nCaractéristiques :\n\nOrdonnés : Les éléments conservent leur position.\nImmuables : Impossible de modifier, ajouter ou supprimer des éléments après leur création."
  },
  {
    "objectID": "doc/cours/typedonnees-slides.html#les-dictionnaires-dict",
    "href": "doc/cours/typedonnees-slides.html#les-dictionnaires-dict",
    "title": "Les Types de données en Python",
    "section": "Les Dictionnaires (dict)",
    "text": "Les Dictionnaires (dict)\nLes dictionnaires sont des collections non ordonnées (dans les versions antérieures à Python 3.7) qui stockent des paires clé-valeur. Chaque clé doit être unique.\nCaractéristiques :\n\nAccès rapide : Vous pouvez accéder rapidement aux valeurs à l’aide de leurs clés.\nModifiables : Vous pouvez ajouter, modifier ou supprimer des paires clé-valeur.\nClés uniques : Une clé ne peut être présente qu’une seule fois."
  },
  {
    "objectID": "doc/cours/typedonnees-slides.html#les-ensembles-set",
    "href": "doc/cours/typedonnees-slides.html#les-ensembles-set",
    "title": "Les Types de données en Python",
    "section": "Les Ensembles (set)",
    "text": "Les Ensembles (set)\nLes ensembles sont des collections non ordonnées et uniques (chaque élément apparaît une seule fois). Ils sont utiles pour éliminer les doublons ou effectuer des opérations mathématiques sur des ensembles.\nCaractéristiques :\n\nNon ordonnés : Les éléments n’ont pas de position fixe.\nÉléments uniques : Les doublons sont automatiquement supprimés.\nOpérations mathématiques : Permettent des opérations comme l’union, l’intersection, la différence, etc."
  },
  {
    "objectID": "doc/cours/introduction.html",
    "href": "doc/cours/introduction.html",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle.\n\n\n\n\nPython est un langage interprété, open source, et multiplateforme.\nCréé par Guido van Rossum en 1989 (première version en 1991).\nPoints forts :\n\nSyntaxe simple et lisible.\nLarge écosystème de bibliothèques.\n\n\n\n\n\n\n\nPratique régulière : Codez régulièrement pour solidifier vos bases.\nExplorez des projets simples : Calculatrice, jeu de devinettes, gestion d’inventaire.\nUtilisez les ressources disponibles :\n\nDocumentation officielle : python.org/doc.\nPlateformes d’exercices : LeetCode, Hackerrank.\n\n\n\n\n\n\n\n\n\nTéléchargez Python depuis python.org.\n\n\n\n\n\n\n\n\nQu’est-ce que VS Code ?\n\nUn éditeur de code léger, puissant et extensible, développé par Microsoft.\n\nIdéal pour écrire et exécuter des scripts Python grâce à ses extensions.\n\nInstaller VS Code :\n\nTéléchargez-le sur code.visualstudio.com.\n\nInstallez l’extension Python via le Visual Studio Code Marketplace :\n\nOuvrez VS Code.\nAllez dans l’onglet des extensions (icône avec des blocs).\nRecherchez Python et cliquez sur “Installer”.\n\n\n\n\n\n\n\n\nQu’est-ce qu’Anaconda ?\n\nUne distribution Python incluant Jupyter Notebook, des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.) et un gestionnaire d’environnements.\n\nIdéal pour la data science et le machine learning.\n\nInstaller Anaconda :\n\nTéléchargez-le depuis anaconda.com.\n\nSuivez les instructions pour votre système d’exploitation (Windows, macOS, Linux).\n\nAvantages :\n\nConfiguration simplifiée pour débuter.\n\nGestion facile des environnements virtuels avec conda.\n\n\n\n\n\n\n\nQu’est-ce que Jupyter Notebook ?\n\nUn environnement interactif où vous pouvez écrire et exécuter du code Python dans des blocs (appelés “cellules”).\n\nIdéal pour la data science et les visualisations.\n\nInstaller Jupyter Notebook :\n\nSi vous avez Anaconda, Jupyter est préinstallé.\n\nSinon, installez-le avec pip :\npip install notebook\n\n\n\n\n\n\n\nQu’est-ce que Google Colab ?\n\nUn environnement en ligne gratuit pour coder en Python, développé par Google.\n\nAucun besoin d’installer Python ou Jupyter : tout fonctionne dans votre navigateur.\n\nAvantage : accès à des GPU gratuits pour le machine learning.\n\nAccéder à Google Colab :\n\nRendez-vous sur colab.research.google.com.\n\nConnectez-vous avec un compte Google.\n\nCréez un nouveau notebook en cliquant sur New Notebook.\n\nFonctionnalités clés :\n\nSauvegarde automatique sur Google Drive.\n\nSupport intégré des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.).\n\n\n\n\n\n\n\n\nPython est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python.\n\n\nUne variable est un conteneur permettant de stocker des données. En Python, il suffit de nommer la variable et d’y attribuer une valeur :\nx = 5\ny = \"Python\"\nprint(x, y)\n\n\n\n\nDans un script Python, tout ce qui suit le caractère # est ignoré par l’interpréteur jusqu’à la fin de la ligne. Ces lignes sont appelées commentaires et sont destinées à expliquer le code dans un langage humain.\n\n\n\n\nClarifier le code : Expliquez des portions complexes pour vous ou d’autres développeurs.\nDocumenter le fonctionnement : Fournir des indications sur le rôle d’un morceau de code ou d’une fonction.\nFaciliter la maintenance : Les commentaires rendent votre code plus compréhensible à long terme.\n\nLes commentaires ne sont pas exécutés par Python et n’affectent donc pas les performances du programme.\n\nPour ajouter un commentaire, commencez la ligne avec un #. Python ignorera tout ce qui suit ce caractère jusqu’à la fin de la ligne.\nExemple simple :\n# Ceci est un commentaire simple\nprint(\"Hello world!\")  # Affiche un message à l'écran\n\n# Déclaration de variables\nnom = \"Alice\"  # Nom de l'utilisateur\nage = 25       # Âge de l'utilisateur\n\n# Affichage des informations\nprint(f\"Nom : {nom}\")\nprint(f\"Âge : {age}\")\n\n# Cette partie affiche une salutation\nprint(\"Bonjour et bienvenue dans le cours de Python !\")\n\n\n\n\n\nSoyez concis et clair Vos commentaires doivent aller à l’essentiel et être compréhensibles.\n\n# Calcule la somme des éléments de la liste\ntotal = sum([1, 2, 3, 4])\n\n\nÉvitez les commentaires inutiles\n\nNe commentez pas des choses évidentes que le code lui-même exprime clairement.\nExemple inutile :\n# Attribue la valeur 5 à la variable x\nx = 5\n\nMettez à jour vos commentaires\n\nAssurez-vous que vos commentaires reflètent toujours le fonctionnement réel du code, surtout après des modifications.\n\n\n\n\n\nCommentaires sur une ligne\n\nIls s’écrivent avec # au début de la ligne.\n# Ce programme affiche un message\nprint(\"Bienvenue en Python !\")\n\n\nCommentaires multilignes\n\nPour commenter plusieurs lignes, vous pouvez utiliser # au début de chaque ligne ou une chaîne de caractères triple (\"\"\" ou ''') si le commentaire est temporaire.\n# Début du programme\n# Ce script montre un exemple\n# avec des commentaires multilignes.\nOu avec une chaîne triple :\n\"\"\"\nCe script illustre :\n- L'utilisation de variables\n- L'utilisation des commentaires\n\"\"\""
  },
  {
    "objectID": "doc/cours/introduction.html#introduction",
    "href": "doc/cours/introduction.html#introduction",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle.\n\n\n\n\nPython est un langage interprété, open source, et multiplateforme.\nCréé par Guido van Rossum en 1989 (première version en 1991).\nPoints forts :\n\nSyntaxe simple et lisible.\nLarge écosystème de bibliothèques.\n\n\n\n\n\n\n\nPratique régulière : Codez régulièrement pour solidifier vos bases.\nExplorez des projets simples : Calculatrice, jeu de devinettes, gestion d’inventaire.\nUtilisez les ressources disponibles :\n\nDocumentation officielle : python.org/doc.\nPlateformes d’exercices : LeetCode, Hackerrank.\n\n\n\n\n\n\n\n\n\nTéléchargez Python depuis python.org.\n\n\n\n\n\n\n\n\nQu’est-ce que VS Code ?\n\nUn éditeur de code léger, puissant et extensible, développé par Microsoft.\n\nIdéal pour écrire et exécuter des scripts Python grâce à ses extensions.\n\nInstaller VS Code :\n\nTéléchargez-le sur code.visualstudio.com.\n\nInstallez l’extension Python via le Visual Studio Code Marketplace :\n\nOuvrez VS Code.\nAllez dans l’onglet des extensions (icône avec des blocs).\nRecherchez Python et cliquez sur “Installer”.\n\n\n\n\n\n\n\n\nQu’est-ce qu’Anaconda ?\n\nUne distribution Python incluant Jupyter Notebook, des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.) et un gestionnaire d’environnements.\n\nIdéal pour la data science et le machine learning.\n\nInstaller Anaconda :\n\nTéléchargez-le depuis anaconda.com.\n\nSuivez les instructions pour votre système d’exploitation (Windows, macOS, Linux).\n\nAvantages :\n\nConfiguration simplifiée pour débuter.\n\nGestion facile des environnements virtuels avec conda.\n\n\n\n\n\n\n\nQu’est-ce que Jupyter Notebook ?\n\nUn environnement interactif où vous pouvez écrire et exécuter du code Python dans des blocs (appelés “cellules”).\n\nIdéal pour la data science et les visualisations.\n\nInstaller Jupyter Notebook :\n\nSi vous avez Anaconda, Jupyter est préinstallé.\n\nSinon, installez-le avec pip :\npip install notebook\n\n\n\n\n\n\n\nQu’est-ce que Google Colab ?\n\nUn environnement en ligne gratuit pour coder en Python, développé par Google.\n\nAucun besoin d’installer Python ou Jupyter : tout fonctionne dans votre navigateur.\n\nAvantage : accès à des GPU gratuits pour le machine learning.\n\nAccéder à Google Colab :\n\nRendez-vous sur colab.research.google.com.\n\nConnectez-vous avec un compte Google.\n\nCréez un nouveau notebook en cliquant sur New Notebook.\n\nFonctionnalités clés :\n\nSauvegarde automatique sur Google Drive.\n\nSupport intégré des bibliothèques populaires (NumPy, Pandas, Matplotlib, etc.)."
  },
  {
    "objectID": "doc/cours/introduction.html#premiers-pas-avec-python",
    "href": "doc/cours/introduction.html#premiers-pas-avec-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "",
    "text": "Python est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python.\n\n\nUne variable est un conteneur permettant de stocker des données. En Python, il suffit de nommer la variable et d’y attribuer une valeur :\nx = 5\ny = \"Python\"\nprint(x, y)\n\n\n\n\nDans un script Python, tout ce qui suit le caractère # est ignoré par l’interpréteur jusqu’à la fin de la ligne. Ces lignes sont appelées commentaires et sont destinées à expliquer le code dans un langage humain.\n\n\n\n\nClarifier le code : Expliquez des portions complexes pour vous ou d’autres développeurs.\nDocumenter le fonctionnement : Fournir des indications sur le rôle d’un morceau de code ou d’une fonction.\nFaciliter la maintenance : Les commentaires rendent votre code plus compréhensible à long terme.\n\nLes commentaires ne sont pas exécutés par Python et n’affectent donc pas les performances du programme.\n\nPour ajouter un commentaire, commencez la ligne avec un #. Python ignorera tout ce qui suit ce caractère jusqu’à la fin de la ligne.\nExemple simple :\n# Ceci est un commentaire simple\nprint(\"Hello world!\")  # Affiche un message à l'écran\n\n# Déclaration de variables\nnom = \"Alice\"  # Nom de l'utilisateur\nage = 25       # Âge de l'utilisateur\n\n# Affichage des informations\nprint(f\"Nom : {nom}\")\nprint(f\"Âge : {age}\")\n\n# Cette partie affiche une salutation\nprint(\"Bonjour et bienvenue dans le cours de Python !\")\n\n\n\n\n\nSoyez concis et clair Vos commentaires doivent aller à l’essentiel et être compréhensibles.\n\n# Calcule la somme des éléments de la liste\ntotal = sum([1, 2, 3, 4])\n\n\nÉvitez les commentaires inutiles\n\nNe commentez pas des choses évidentes que le code lui-même exprime clairement.\nExemple inutile :\n# Attribue la valeur 5 à la variable x\nx = 5\n\nMettez à jour vos commentaires\n\nAssurez-vous que vos commentaires reflètent toujours le fonctionnement réel du code, surtout après des modifications.\n\n\n\n\n\nCommentaires sur une ligne\n\nIls s’écrivent avec # au début de la ligne.\n# Ce programme affiche un message\nprint(\"Bienvenue en Python !\")\n\n\nCommentaires multilignes\n\nPour commenter plusieurs lignes, vous pouvez utiliser # au début de chaque ligne ou une chaîne de caractères triple (\"\"\" ou ''') si le commentaire est temporaire.\n# Début du programme\n# Ce script montre un exemple\n# avec des commentaires multilignes.\nOu avec une chaîne triple :\n\"\"\"\nCe script illustre :\n- L'utilisation de variables\n- L'utilisation des commentaires\n\"\"\""
  },
  {
    "objectID": "doc/cours/introduction.html#quest-ce-quune-variable",
    "href": "doc/cours/introduction.html#quest-ce-quune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.1 Qu’est-ce qu’une variable ?",
    "text": "2.1 Qu’est-ce qu’une variable ?\nUne variable est un conteneur permettant de stocker une valeur ou des données. En Python, une variable peut contenir différents types de données comme des nombres, du texte, ou des structures complexes."
  },
  {
    "objectID": "doc/cours/introduction.html#déclaration-dune-variable",
    "href": "doc/cours/introduction.html#déclaration-dune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.2 Déclaration d’une variable",
    "text": "2.2 Déclaration d’une variable\nEn Python, il suffit d’utiliser un nom valide et de lui assigner une valeur avec le symbole =.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\nage = 25        # Entier\npi = 3.14       # Nombre flottant\nest_actif = True  # Booléen"
  },
  {
    "objectID": "doc/cours/introduction.html#les-types-de-base-en-python",
    "href": "doc/cours/introduction.html#les-types-de-base-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "2.3 Les Types de Base en Python",
    "text": "2.3 Les Types de Base en Python\nPython propose plusieurs types de données de base, essentiels pour la manipulation des informations.\n\n\nComment connaître le type d’une variable en Python ?\nPython propose une fonction intégrée appelée type() pour déterminer le type de données d’une variable.\n\n\nUtilisation de type()\nLa fonction type() prend une variable en argument et retourne son type.\nExemples de types que vous pourriez rencontrer : - str : Chaîne de caractères - int : Entier - float : Nombre décimal - bool : Valeur logique\n\nCes types de base constituent les fondations des programmes en Python et sont utilisés dans presque tous les scripts.\n\n\nChaînes de caractères (str)\nLes chaînes de caractères permettent de stocker du texte. Elles peuvent être utilisées pour manipuler des mots, des phrases ou des caractères individuels.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\ntype(nom)\n\n\n\n\nEntiers (int)\nLes entiers représentent des nombres sans décimales, qu’ils soient positifs ou négatifs.\nExemple :\n# Déclaration de variables\nage = 25        # Entier\ntype(age)\n\n\n\nFlottants (float)\nLes flottants représentent des nombres avec des décimales, idéaux pour des calculs nécessitant des fractions. Exemple :\n# Déclaration de variables\npi = 3.14       # Nombre flottant\ntype(pi)\n\n\n\nBooléens (bool)\nLes booléens sont des valeurs logiques, pouvant être True (vrai) ou False (faux). Ils sont souvent utilisés pour effectuer des comparaisons ou contrôler le flux d’un programme. Exemple :\n# Déclaration de variables\nest_actif = True  # Booléen\ntype(est_actif)\n\n\n\nRésumé des types de base\n\n\n\nType\nDescription\n\n\n\n\nstr\nChaîne de caractères\n\n\nint\nNombres entiers\n\n\nfloat\nNombres décimaux\n\n\nbool\nValeurs logiques (True/False)"
  },
  {
    "objectID": "doc/cours/introduction.html#la-fonction-print",
    "href": "doc/cours/introduction.html#la-fonction-print",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.1 La fonction print()",
    "text": "3.1 La fonction print()\nprint() est utilisée pour afficher des informations dans la console. Elle permet de montrer le contenu de variables, des messages, ou des résultats de calcul.\nExemple :\nprint(valeur)"
  },
  {
    "objectID": "doc/cours/introduction.html#afficher-plusieurs-éléments",
    "href": "doc/cours/introduction.html#afficher-plusieurs-éléments",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.2 Afficher plusieurs éléments",
    "text": "3.2 Afficher plusieurs éléments\nVous pouvez afficher plusieurs éléments en même temps en les séparant par des virgules. Python ajoute automatiquement un espace entre ces éléments.\nExemple :\nprint(\"Bonjour\", \"Python\", 3.10)"
  },
  {
    "objectID": "doc/cours/introduction.html#formatage-des-chaînes",
    "href": "doc/cours/introduction.html#formatage-des-chaînes",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.3 Formatage des chaînes",
    "text": "3.3 Formatage des chaînes\nPour des affichages dynamiques et lisibles, plusieurs méthodes de formatage sont disponibles :\n\nConcaténation avec + : Combine des chaînes de caractères.\n\nnom = \"Alice\"\nprint(\"Bonjour, \" + nom)\n\nSubstitution avec f-strings : Insère directement des variables dans une chaîne avec une syntaxe claire.\n\nnom = \"Alice\"\nage = 25\nprint(f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\")\n\nMéthode format() : Insère des variables dans une chaîne avec des positions spécifiques.\n\nnom = \"Alice\"\nage = 25\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(nom, age))"
  },
  {
    "objectID": "doc/cours/introduction.html#caractères-spéciaux",
    "href": "doc/cours/introduction.html#caractères-spéciaux",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.4 Caractères spéciaux",
    "text": "3.4 Caractères spéciaux\nCertaines séquences spéciales permettent de modifier l’affichage : - \\\\n : Effectue un saut de ligne. - \\\\t : Ajoute une tabulation.\nCes caractères sont utiles pour structurer l’affichage dans la console.\nprint(\"Bonjour\\\\nPython\")\nprint(\"Nom:\\\\tAlice\")"
  },
  {
    "objectID": "doc/cours/introduction.html#contrôler-la-fin-de-laffichage",
    "href": "doc/cours/introduction.html#contrôler-la-fin-de-laffichage",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.5 Contrôler la fin de l’affichage",
    "text": "3.5 Contrôler la fin de l’affichage\nPar défaut, chaque appel à print() termine par un saut de ligne. Il est possible de modifier ce comportement pour afficher plusieurs éléments sur la même ligne.\nprint(\"Bonjour\", end=\" \")\nprint(\"Python !\")"
  },
  {
    "objectID": "doc/cours/introduction.html#résumé",
    "href": "doc/cours/introduction.html#résumé",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "3.6 Résumé",
    "text": "3.6 Résumé\n\n\n\n\n\n\n\nMéthode\nDescription\n\n\n\n\nprint()\nAffiche des données dans la console.\n\n\nConcaténation\nCombine plusieurs chaînes de caractères.\n\n\nf-strings\nInsère des variables directement dans une chaîne.\n\n\n.format()\nFormate une chaîne avec des variables.\n\n\nCaractères spéciaux\nModifie l’apparence (nouvelle ligne, tabulation)."
  },
  {
    "objectID": "doc/cours/introduction.html#les-structures-conditionnelles",
    "href": "doc/cours/introduction.html#les-structures-conditionnelles",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "4.1 Les Structures conditionnelles",
    "text": "4.1 Les Structures conditionnelles\nLes structures conditionnelles permettent d’exécuter des blocs de code uniquement si une condition est remplie.\n\n\nLa condition if\nLa condition if est utilisée pour vérifier si une expression est vraie. Si c’est le cas, le bloc de code associé est exécuté.\n\nSyntaxe de base\nif condition:\n    # Code à exécuter si la condition est vraie\n\n\n\nExemple simple\nnombre = 10\n\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\n\n\n\nAjout de else\nL’instruction else permet d’exécuter un bloc de code si la condition est fausse.\nnombre = -5\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\nelse:\n    print(\"Le nombre est négatif ou nul.\")\n\n\n\nAjout de elif\nL’instruction elif permet de vérifier plusieurs conditions successives.\nnombre = 0\n\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\nelif nombre == 0:\n    print(\"Le nombre est nul.\")\nelse:\n    print(\"Le nombre est négatif.\")\n\n\n\n\nConditions imbriquées\nLes if peuvent être imbriqués pour vérifier des conditions multiples.\nage = 20\ncitoyen = True\n\nif age &gt;= 18:\n    if citoyen:\n        print(\"Vous pouvez voter.\")\n    else:\n        print(\"Vous ne pouvez pas voter, même si vous êtes majeur.\")\nelse:\n    print(\"Vous êtes mineur.\")\n\n\n\nComparaisons en Python\nLes opérateurs de comparaison permettent d’évaluer des expressions.\n\n\n\nOpérateur\nDescription\n\n\n\n\n==\nÉgalité\n\n\n!=\nDifférence\n\n\n&lt;\nInférieur à\n\n\n&lt;=\nInférieur ou égal à\n\n\n&gt;\nSupérieur à\n\n\n&gt;=\nSupérieur ou égal à\n\n\n\n\n\n\nOpérateurs logiques\nLes opérateurs logiques permettent de combiner plusieurs conditions.\n\n\n\nOpérateur\nDescription\n\n\n\n\nand\nToutes les conditions doivent être vraies.\n\n\nor\nAu moins une des conditions doit être vraie.\n\n\nnot\nInverse le résultat de la condition."
  },
  {
    "objectID": "doc/cours/introduction.html#les-boucles-en-python",
    "href": "doc/cours/introduction.html#les-boucles-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "4.2 Les Boucles en Python",
    "text": "4.2 Les Boucles en Python\nLes boucles permettent de répéter des actions tant qu’une condition est vraie ou pour un nombre fixe d’itérations.\n\n\nLa boucle for\n\nLa boucle for est utilisée pour parcourir une séquence (liste, chaîne de caractères, etc.).\nChaque élément de la séquence est traité successivement.\n\n\n\n\nLa boucle while\n\nLa boucle while répète un bloc de code tant qu’une condition est vraie.\nAttention aux boucles infinies : assurez-vous que la condition de sortie est atteinte.\n\n\n\n\nContrôle des boucles\n\n\n\n\n\n\n\nInstruction\nDescription\n\n\n\n\nbreak\nInterrompt la boucle immédiatement, même si la condition n’est pas terminée.\n\n\ncontinue\nPasse à l’itération suivante sans exécuter le reste du bloc de code actuel.\n\n\npass\nNe fait rien. Utilisé comme espace réservé dans une boucle ou une condition."
  },
  {
    "objectID": "doc/cours/introduction.html#résumé-1",
    "href": "doc/cours/introduction.html#résumé-1",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "4.3 Résumé",
    "text": "4.3 Résumé\n\n\n\n\n\n\n\nStructure\nDescription\n\n\n\n\nif\nExécute un bloc si une condition est vraie.\n\n\nelif\nAjoute des conditions supplémentaires.\n\n\nelse\nDéfinit un bloc exécuté si toutes les conditions sont fausses.\n\n\nfor\nParcourt une séquence ou un intervalle.\n\n\nwhile\nRépète un bloc tant qu’une condition est vraie.\n\n\nbreak\nInterrompt une boucle.\n\n\ncontinue\nSaute à l’itération suivante.\n\n\npass\nNe fait rien (utile pour des blocs vides).\n\n\n\nAvec ces structures, vous pouvez écrire des programmes dynamiques et efficaces en Python !"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#introduction",
    "href": "doc/cours/introduction-slides.html#introduction",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Introduction",
    "text": "Introduction\nPython est un langage de programmation polyvalent, apprécié pour sa simplicité et sa lisibilité. Il est utilisé dans des domaines variés comme le développement web, la data science, et l’intelligence artificielle."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#premiers-pas-avec-python",
    "href": "doc/cours/introduction-slides.html#premiers-pas-avec-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Premiers pas avec Python",
    "text": "Premiers pas avec Python\nPython est un langage polyvalent, lisible et largement utilisé. Cette section vous guide à travers les bases essentielles pour bien commencer avec Python."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#quest-ce-quune-variable",
    "href": "doc/cours/introduction-slides.html#quest-ce-quune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Qu’est-ce qu’une variable ?",
    "text": "Qu’est-ce qu’une variable ?\nUne variable est un conteneur permettant de stocker une valeur ou des données. En Python, une variable peut contenir différents types de données comme des nombres, du texte, ou des structures complexes."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#déclaration-dune-variable",
    "href": "doc/cours/introduction-slides.html#déclaration-dune-variable",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Déclaration d’une variable",
    "text": "Déclaration d’une variable\nEn Python, il suffit d’utiliser un nom valide et de lui assigner une valeur avec le symbole =.\nExemple :\n# Déclaration de variables\nnom = \"Alice\"   # Chaîne de caractères\nage = 25        # Entier\npi = 3.14       # Nombre flottant\nest_actif = True  # Booléen"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#les-types-de-base-en-python",
    "href": "doc/cours/introduction-slides.html#les-types-de-base-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Les Types de Base en Python",
    "text": "Les Types de Base en Python\nPython propose plusieurs types de données de base, essentiels pour la manipulation des informations."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#la-fonction-print",
    "href": "doc/cours/introduction-slides.html#la-fonction-print",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "La fonction print()",
    "text": "La fonction print()\nprint() est utilisée pour afficher des informations dans la console. Elle permet de montrer le contenu de variables, des messages, ou des résultats de calcul.\nExemple :\nprint(valeur)"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#afficher-plusieurs-éléments",
    "href": "doc/cours/introduction-slides.html#afficher-plusieurs-éléments",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Afficher plusieurs éléments",
    "text": "Afficher plusieurs éléments\nVous pouvez afficher plusieurs éléments en même temps en les séparant par des virgules. Python ajoute automatiquement un espace entre ces éléments.\nExemple :\nprint(\"Bonjour\", \"Python\", 3.10)"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#formatage-des-chaînes",
    "href": "doc/cours/introduction-slides.html#formatage-des-chaînes",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Formatage des chaînes",
    "text": "Formatage des chaînes\nPour des affichages dynamiques et lisibles, plusieurs méthodes de formatage sont disponibles :\n\nConcaténation avec + : Combine des chaînes de caractères.\n\nnom = \"Alice\"\nprint(\"Bonjour, \" + nom)\n\nSubstitution avec f-strings : Insère directement des variables dans une chaîne avec une syntaxe claire.\n\nnom = \"Alice\"\nage = 25\nprint(f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\")\n\nMéthode format() : Insère des variables dans une chaîne avec des positions spécifiques.\n\nnom = \"Alice\"\nage = 25\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(nom, age))"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#caractères-spéciaux",
    "href": "doc/cours/introduction-slides.html#caractères-spéciaux",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Caractères spéciaux",
    "text": "Caractères spéciaux\nCertaines séquences spéciales permettent de modifier l’affichage : - \\\\n : Effectue un saut de ligne. - \\\\t : Ajoute une tabulation.\nCes caractères sont utiles pour structurer l’affichage dans la console.\nprint(\"Bonjour\\\\nPython\")\nprint(\"Nom:\\\\tAlice\")"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#contrôler-la-fin-de-laffichage",
    "href": "doc/cours/introduction-slides.html#contrôler-la-fin-de-laffichage",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Contrôler la fin de l’affichage",
    "text": "Contrôler la fin de l’affichage\nPar défaut, chaque appel à print() termine par un saut de ligne. Il est possible de modifier ce comportement pour afficher plusieurs éléments sur la même ligne.\nprint(\"Bonjour\", end=\" \")\nprint(\"Python !\")"
  },
  {
    "objectID": "doc/cours/introduction-slides.html#résumé",
    "href": "doc/cours/introduction-slides.html#résumé",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Résumé",
    "text": "Résumé\n\n\n\n\n\n\n\nMéthode\nDescription\n\n\n\n\nprint()\nAffiche des données dans la console.\n\n\nConcaténation\nCombine plusieurs chaînes de caractères.\n\n\nf-strings\nInsère des variables directement dans une chaîne.\n\n\n.format()\nFormate une chaîne avec des variables.\n\n\nCaractères spéciaux\nModifie l’apparence (nouvelle ligne, tabulation)."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#les-structures-conditionnelles",
    "href": "doc/cours/introduction-slides.html#les-structures-conditionnelles",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Les Structures conditionnelles",
    "text": "Les Structures conditionnelles\nLes structures conditionnelles permettent d’exécuter des blocs de code uniquement si une condition est remplie."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#les-boucles-en-python",
    "href": "doc/cours/introduction-slides.html#les-boucles-en-python",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Les Boucles en Python",
    "text": "Les Boucles en Python\nLes boucles permettent de répéter des actions tant qu’une condition est vraie ou pour un nombre fixe d’itérations."
  },
  {
    "objectID": "doc/cours/introduction-slides.html#résumé-1",
    "href": "doc/cours/introduction-slides.html#résumé-1",
    "title": "Introduction à Python : Bases et Structures Fondamentales",
    "section": "Résumé",
    "text": "Résumé\n\n\n\n\n\n\n\nStructure\nDescription\n\n\n\n\nif\nExécute un bloc si une condition est vraie.\n\n\nelif\nAjoute des conditions supplémentaires.\n\n\nelse\nDéfinit un bloc exécuté si toutes les conditions sont fausses.\n\n\nfor\nParcourt une séquence ou un intervalle.\n\n\nwhile\nRépète un bloc tant qu’une condition est vraie.\n\n\nbreak\nInterrompt une boucle.\n\n\ncontinue\nSaute à l’itération suivante.\n\n\npass\nNe fait rien (utile pour des blocs vides).\n\n\n\nAvec ces structures, vous pouvez écrire des programmes dynamiques et efficaces en Python !"
  },
  {
    "objectID": "doc/cours/analysedonnees.html",
    "href": "doc/cours/analysedonnees.html",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas est une bibliothèque open-source essentielle en Python pour la manipulation et l’analyse de données. Elle permet de travailler avec des ensembles de données sous forme de tableaux en offrant des outils puissants pour nettoyer, transformer et analyser les données efficacement.\n\n\n\nFacilité de manipulation : Pandas simplifie la manipulation des données tabulaires (issues de fichiers CSV, Excel, bases de données, etc.).\nPerformance : Pandas est optimisé pour gérer de grandes quantités de données bien plus rapidement que les structures classiques comme les listes Python.\nInteropérabilité : Compatible avec NumPy, Matplotlib, SQL, et d’autres bibliothèques de data science.\n\nObjectifs du cours : - Comprendre les structures de Pandas : Series et DataFrame. - Apprendre à charger, explorer et manipuler des données. - Effectuer des analyses et transformations avancées.\n\n\n\n\n\nSi Pandas n’est pas encore installé, vous pouvez l’ajouter à votre environnement Python avec la commande suivante :\npip install pandas\nUne fois installé, importez Pandas :\nimport pandas as pd\nL’alias pd est une convention utilisée pour simplifier l’appel aux fonctions de la bibliothèque.\n\n\n\n\nPandas offre plusieurs méthodes pour créer des jeux de données ou les charger depuis divers formats.\n\n\nUn DataFrame est une table composée de lignes et de colonnes, similaire à une feuille de calcul Excel ou une base de données SQL.\ndata = {\n    'Nom': ['Alice', 'Bob', 'Charlie'],\n    'Âge': [25, 30, 35],\n    'Salaire': [50000, 60000, 70000]\n}\ndf = pd.DataFrame(data)\nprint(df)\nPourquoi utiliser un DataFrame ? - Il permet de manipuler facilement des données hétérogènes. - Il est conçu pour des opérations analytiques rapides et intuitives.\n\n\n\nPandas permet de lire des fichiers de différents formats : CSV, Excel, JSON, SQL, etc.\n# Charger un fichier CSV\ndf = pd.read_csv(\"data.csv\")\n\n# Charger un fichier Excel\ndf = pd.read_excel(\"data.xlsx\")\nExercice 1 : - Chargez un fichier CSV et affichez ses premières lignes. - Affichez le nombre total de lignes et de colonnes.\n\n\n\n\n\nL’accès aux données est une étape essentielle pour manipuler efficacement un DataFrame.\n\n\nVous pouvez sélectionner une colonne spécifique comme suit :\ndf['Nom']  # Retourne une Series\nPour sélectionner plusieurs colonnes :\ndf[['Nom', 'Salaire']]\n\n\n\n\n\n\n.loc sélectionne les données par étiquette (nom des lignes ou colonnes).\n.iloc sélectionne les données par indice numérique.\n\nExemples :\n# Sélection par étiquette avec loc\ndf.loc[0]  # Sélectionne la première ligne\n\n# Sélection par index numérique avec iloc\ndf.iloc[0]  # Sélectionne la première ligne\nSélection de plusieurs lignes :\ndf.loc[1:2]  # Sélectionne les lignes 1 à 2 (inclus)\ndf.iloc[0:2]  # Sélectionne les deux premières lignes\nExercice 2 : - Sélectionnez toutes les personnes ayant un salaire supérieur à 50 000. - Affichez uniquement les colonnes ‘Nom’ et ‘Âge’.\n\n\n\n\n\n\nLes jeux de données réels sont souvent incomplets ou mal structurés. Pandas offre des outils pour les corriger.\n\n\ndf.isnull().sum()  # Compter les valeurs manquantes\ndf.fillna(df.mean(), inplace=True)  # Remplacer les NaN par la moyenne\nPourquoi gérer les valeurs manquantes ? - Les valeurs manquantes peuvent fausser les résultats d’analyse. - Pandas permet de les remplacer ou les supprimer intelligemment.\n\n\n\ndf['Revenu Annuel'] = df['Salaire'] * 12  # Ajouter une colonne\ndf.drop(columns=['Âge'], inplace=True)  # Supprimer une colonne\nPourquoi manipuler les colonnes ? - Permet de calculer de nouvelles métriques. - Aide à nettoyer les données pour faciliter l’analyse.\nExercice 3 : - Remplacez les valeurs NaN par la médiane. - Ajoutez une colonne calculant le double du salaire.\n\n\n\n\n\nPandas permet de manipuler et personnaliser les indices d’un DataFrame pour optimiser l’analyse des données.\n\n\ndf.set_index('Nom', inplace=True)  # Définir la colonne \"Nom\" comme index\nprint(df)\n\n\n\ndf.reset_index(inplace=True)  # Restaurer l'index par défaut\nprint(df)\nPourquoi utiliser des indices personnalisés ? - Permet d’accéder plus rapidement aux lignes spécifiques. - Facilite les jointures et les regroupements de données.\n\n\n\n\n\nPandas permet de trier les données selon différentes colonnes.\n\n\ndf.sort_values(by='Salaire', ascending=False)\n\n\n\ndf.sort_index()\nPourquoi trier les données ?\n\nFacilite l’interprétation des résultats.\nPermet d’optimiser certaines analyses.\n\n\n\n\n\n\nPandas permet d’améliorer les performances des manipulations de données.\n\n\ndf['Nom'] = df['Nom'].astype('category')\nPourquoi utiliser category ?\n\nPermet de réduire la mémoire utilisée.\nOptimise les opérations de regroupement.\n\n\n\n\npd.read_csv('data.csv', chunksize=1000)  # Charger par blocs de 1000 lignes\nPourquoi charger en morceaux ?\n\nÉvite de saturer la mémoire RAM.\nFacilite le traitement de très gros fichiers.\n\n\n\n\n\n\nPandas permet d’exporter facilement les résultats de l’analyse sous différents formats.\ndf.to_csv('output.csv', index=False)  # Sauvegarde en CSV\ndf.to_excel('output.xlsx', index=False)  # Sauvegarde en Excel\ndf.to_json('output.json')  # Sauvegarde en JSON\nPourquoi exporter les données ?\n\nFacilite le partage et la réutilisation des résultats.\nPermet de documenter le travail réalisé.\n\n\n\n\n\nPandas facilite le regroupement des données et leur analyse statistique.\n\n\ndf.groupby('Nom')['Salaire'].sum()\nPourquoi utiliser GroupBy ?\n\nPermet d’analyser des tendances et de comparer des groupes.\n\n\n\n\ndf['Salaire'].mean()  # Moyenne\ndf['Salaire'].median()  # Médiane\ndf['Salaire'].std()  # Écart-type\nPourquoi les statistiques sont utiles ?\n\nAident à détecter les tendances et anomalies.\n\nExercice 4 :\n\nTrouvez la moyenne des salaires par groupe.\nIdentifiez la personne ayant le salaire le plus élevé.\n\n\n\n\n\n\nLorsqu’on travaille avec plusieurs ensembles de données, il est souvent nécessaire de les fusionner pour obtenir une vue d’ensemble cohérente. Pandas offre plusieurs méthodes pour combiner des DataFrames.\n\n\nLa méthode merge() permet de fusionner deux DataFrames sur une colonne commune.\ndf1 = pd.DataFrame({'ID': [1, 2, 3], 'Nom': ['Alice', 'Bob', 'Charlie']})\ndf2 = pd.DataFrame({'ID': [1, 2, 3], 'Salaire': [50000, 60000, 70000]})\n\nfusion = pd.merge(df1, df2, on='ID')\nprint(fusion)\n\n\n\nPandas permet plusieurs types de jointures similaires aux bases de données SQL :\n\nInner Join (Intersection) : Ne garde que les valeurs communes aux deux DataFrames.\nLeft Join (Jointure à gauche) : Conserve toutes les lignes du premier DataFrame et ajoute les correspondances du second.\nRight Join (Jointure à droite) : Conserve toutes les lignes du second DataFrame et ajoute les correspondances du premier.\nOuter Join (Jointure complète) : Conserve toutes les données des deux DataFrames, même celles sans correspondance.\n\n# Inner Join (par défaut)\npd.merge(df1, df2, on='ID', how='inner')\n\n# Left Join\npd.merge(df1, df2, on='ID', how='left')\n\n# Right Join\npd.merge(df1, df2, on='ID', how='right')\n\n# Outer Join\npd.merge(df1, df2, on='ID', how='outer')\n\n\n\nParfois, il est nécessaire de concaténer des DataFrames, c’est-à-dire les empiler verticalement ou horizontalement.\ndf3 = pd.DataFrame({'ID': [4, 5], 'Nom': ['David', 'Emma']})\nconcat_vertical = pd.concat([df1, df3], ignore_index=True)\nprint(concat_vertical)\nPourquoi utiliser concat() ?\n\nUtile lorsqu’on dispose de plusieurs fichiers contenant des données similaires et qu’on souhaite les regrouper.\nPermet de fusionner facilement des ensembles de données de manière efficace.\n\n\n\n\nDans certains cas, la fusion se fait sur plusieurs colonnes :\ndf1 = pd.DataFrame({'ID': [1, 2, 3], 'Nom': ['Alice', 'Bob', 'Charlie'], 'Ville': ['Paris', 'Lyon', 'Marseille']})\ndf2 = pd.DataFrame({'ID': [1, 2, 3], 'Ville': ['Paris', 'Lyon', 'Marseille'], 'Salaire': [50000, 60000, 70000]})\n\nfusion_multi = pd.merge(df1, df2, on=['ID', 'Ville'])\nprint(fusion_multi)\nExercice 5 :\n\nCréez deux DataFrames et appliquez différents types de jointures.\nTestez la concaténation avec des DataFrames ayant des colonnes différentes.\n\n\n\n\n\n\nCe cours vous a permis d’apprendre à :\n\nCharger et manipuler des ensembles de données.\nEffectuer des analyses exploratoires et des transformations.\nNettoyer les données et appliquer des techniques avancées.\nFusionner et joindre plusieurs ensembles de données pour une analyse plus complète."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#introduction",
    "href": "doc/cours/analysedonnees.html#introduction",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas est une bibliothèque open-source essentielle en Python pour la manipulation et l’analyse de données. Elle permet de travailler avec des ensembles de données sous forme de tableaux en offrant des outils puissants pour nettoyer, transformer et analyser les données efficacement.\n\n\n\nFacilité de manipulation : Pandas simplifie la manipulation des données tabulaires (issues de fichiers CSV, Excel, bases de données, etc.).\nPerformance : Pandas est optimisé pour gérer de grandes quantités de données bien plus rapidement que les structures classiques comme les listes Python.\nInteropérabilité : Compatible avec NumPy, Matplotlib, SQL, et d’autres bibliothèques de data science.\n\nObjectifs du cours : - Comprendre les structures de Pandas : Series et DataFrame. - Apprendre à charger, explorer et manipuler des données. - Effectuer des analyses et transformations avancées."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#installation-et-importation",
    "href": "doc/cours/analysedonnees.html#installation-et-importation",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Si Pandas n’est pas encore installé, vous pouvez l’ajouter à votre environnement Python avec la commande suivante :\npip install pandas\nUne fois installé, importez Pandas :\nimport pandas as pd\nL’alias pd est une convention utilisée pour simplifier l’appel aux fonctions de la bibliothèque."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#création-et-chargement-des-données",
    "href": "doc/cours/analysedonnees.html#création-et-chargement-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas offre plusieurs méthodes pour créer des jeux de données ou les charger depuis divers formats.\n\n\nUn DataFrame est une table composée de lignes et de colonnes, similaire à une feuille de calcul Excel ou une base de données SQL.\ndata = {\n    'Nom': ['Alice', 'Bob', 'Charlie'],\n    'Âge': [25, 30, 35],\n    'Salaire': [50000, 60000, 70000]\n}\ndf = pd.DataFrame(data)\nprint(df)\nPourquoi utiliser un DataFrame ? - Il permet de manipuler facilement des données hétérogènes. - Il est conçu pour des opérations analytiques rapides et intuitives.\n\n\n\nPandas permet de lire des fichiers de différents formats : CSV, Excel, JSON, SQL, etc.\n# Charger un fichier CSV\ndf = pd.read_csv(\"data.csv\")\n\n# Charger un fichier Excel\ndf = pd.read_excel(\"data.xlsx\")\nExercice 1 : - Chargez un fichier CSV et affichez ses premières lignes. - Affichez le nombre total de lignes et de colonnes."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#sélection-et-filtrage-des-données",
    "href": "doc/cours/analysedonnees.html#sélection-et-filtrage-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "L’accès aux données est une étape essentielle pour manipuler efficacement un DataFrame.\n\n\nVous pouvez sélectionner une colonne spécifique comme suit :\ndf['Nom']  # Retourne une Series\nPour sélectionner plusieurs colonnes :\ndf[['Nom', 'Salaire']]\n\n\n\n\n\n\n.loc sélectionne les données par étiquette (nom des lignes ou colonnes).\n.iloc sélectionne les données par indice numérique.\n\nExemples :\n# Sélection par étiquette avec loc\ndf.loc[0]  # Sélectionne la première ligne\n\n# Sélection par index numérique avec iloc\ndf.iloc[0]  # Sélectionne la première ligne\nSélection de plusieurs lignes :\ndf.loc[1:2]  # Sélectionne les lignes 1 à 2 (inclus)\ndf.iloc[0:2]  # Sélectionne les deux premières lignes\nExercice 2 : - Sélectionnez toutes les personnes ayant un salaire supérieur à 50 000. - Affichez uniquement les colonnes ‘Nom’ et ‘Âge’."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#transformation-et-nettoyage-des-données",
    "href": "doc/cours/analysedonnees.html#transformation-et-nettoyage-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Les jeux de données réels sont souvent incomplets ou mal structurés. Pandas offre des outils pour les corriger.\n\n\ndf.isnull().sum()  # Compter les valeurs manquantes\ndf.fillna(df.mean(), inplace=True)  # Remplacer les NaN par la moyenne\nPourquoi gérer les valeurs manquantes ? - Les valeurs manquantes peuvent fausser les résultats d’analyse. - Pandas permet de les remplacer ou les supprimer intelligemment.\n\n\n\ndf['Revenu Annuel'] = df['Salaire'] * 12  # Ajouter une colonne\ndf.drop(columns=['Âge'], inplace=True)  # Supprimer une colonne\nPourquoi manipuler les colonnes ? - Permet de calculer de nouvelles métriques. - Aide à nettoyer les données pour faciliter l’analyse.\nExercice 3 : - Remplacez les valeurs NaN par la médiane. - Ajoutez une colonne calculant le double du salaire."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#gestion-des-indices",
    "href": "doc/cours/analysedonnees.html#gestion-des-indices",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas permet de manipuler et personnaliser les indices d’un DataFrame pour optimiser l’analyse des données.\n\n\ndf.set_index('Nom', inplace=True)  # Définir la colonne \"Nom\" comme index\nprint(df)\n\n\n\ndf.reset_index(inplace=True)  # Restaurer l'index par défaut\nprint(df)\nPourquoi utiliser des indices personnalisés ? - Permet d’accéder plus rapidement aux lignes spécifiques. - Facilite les jointures et les regroupements de données."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#tri-et-ordonnancement-des-données",
    "href": "doc/cours/analysedonnees.html#tri-et-ordonnancement-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas permet de trier les données selon différentes colonnes.\n\n\ndf.sort_values(by='Salaire', ascending=False)\n\n\n\ndf.sort_index()\nPourquoi trier les données ?\n\nFacilite l’interprétation des résultats.\nPermet d’optimiser certaines analyses."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#optimisation-et-performances",
    "href": "doc/cours/analysedonnees.html#optimisation-et-performances",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas permet d’améliorer les performances des manipulations de données.\n\n\ndf['Nom'] = df['Nom'].astype('category')\nPourquoi utiliser category ?\n\nPermet de réduire la mémoire utilisée.\nOptimise les opérations de regroupement.\n\n\n\n\npd.read_csv('data.csv', chunksize=1000)  # Charger par blocs de 1000 lignes\nPourquoi charger en morceaux ?\n\nÉvite de saturer la mémoire RAM.\nFacilite le traitement de très gros fichiers."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#exportation-des-données",
    "href": "doc/cours/analysedonnees.html#exportation-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas permet d’exporter facilement les résultats de l’analyse sous différents formats.\ndf.to_csv('output.csv', index=False)  # Sauvegarde en CSV\ndf.to_excel('output.xlsx', index=False)  # Sauvegarde en Excel\ndf.to_json('output.json')  # Sauvegarde en JSON\nPourquoi exporter les données ?\n\nFacilite le partage et la réutilisation des résultats.\nPermet de documenter le travail réalisé."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#groupby-et-agrégations",
    "href": "doc/cours/analysedonnees.html#groupby-et-agrégations",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Pandas facilite le regroupement des données et leur analyse statistique.\n\n\ndf.groupby('Nom')['Salaire'].sum()\nPourquoi utiliser GroupBy ?\n\nPermet d’analyser des tendances et de comparer des groupes.\n\n\n\n\ndf['Salaire'].mean()  # Moyenne\ndf['Salaire'].median()  # Médiane\ndf['Salaire'].std()  # Écart-type\nPourquoi les statistiques sont utiles ?\n\nAident à détecter les tendances et anomalies.\n\nExercice 4 :\n\nTrouvez la moyenne des salaires par groupe.\nIdentifiez la personne ayant le salaire le plus élevé."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#jointures-et-fusion-de-données",
    "href": "doc/cours/analysedonnees.html#jointures-et-fusion-de-données",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Lorsqu’on travaille avec plusieurs ensembles de données, il est souvent nécessaire de les fusionner pour obtenir une vue d’ensemble cohérente. Pandas offre plusieurs méthodes pour combiner des DataFrames.\n\n\nLa méthode merge() permet de fusionner deux DataFrames sur une colonne commune.\ndf1 = pd.DataFrame({'ID': [1, 2, 3], 'Nom': ['Alice', 'Bob', 'Charlie']})\ndf2 = pd.DataFrame({'ID': [1, 2, 3], 'Salaire': [50000, 60000, 70000]})\n\nfusion = pd.merge(df1, df2, on='ID')\nprint(fusion)\n\n\n\nPandas permet plusieurs types de jointures similaires aux bases de données SQL :\n\nInner Join (Intersection) : Ne garde que les valeurs communes aux deux DataFrames.\nLeft Join (Jointure à gauche) : Conserve toutes les lignes du premier DataFrame et ajoute les correspondances du second.\nRight Join (Jointure à droite) : Conserve toutes les lignes du second DataFrame et ajoute les correspondances du premier.\nOuter Join (Jointure complète) : Conserve toutes les données des deux DataFrames, même celles sans correspondance.\n\n# Inner Join (par défaut)\npd.merge(df1, df2, on='ID', how='inner')\n\n# Left Join\npd.merge(df1, df2, on='ID', how='left')\n\n# Right Join\npd.merge(df1, df2, on='ID', how='right')\n\n# Outer Join\npd.merge(df1, df2, on='ID', how='outer')\n\n\n\nParfois, il est nécessaire de concaténer des DataFrames, c’est-à-dire les empiler verticalement ou horizontalement.\ndf3 = pd.DataFrame({'ID': [4, 5], 'Nom': ['David', 'Emma']})\nconcat_vertical = pd.concat([df1, df3], ignore_index=True)\nprint(concat_vertical)\nPourquoi utiliser concat() ?\n\nUtile lorsqu’on dispose de plusieurs fichiers contenant des données similaires et qu’on souhaite les regrouper.\nPermet de fusionner facilement des ensembles de données de manière efficace.\n\n\n\n\nDans certains cas, la fusion se fait sur plusieurs colonnes :\ndf1 = pd.DataFrame({'ID': [1, 2, 3], 'Nom': ['Alice', 'Bob', 'Charlie'], 'Ville': ['Paris', 'Lyon', 'Marseille']})\ndf2 = pd.DataFrame({'ID': [1, 2, 3], 'Ville': ['Paris', 'Lyon', 'Marseille'], 'Salaire': [50000, 60000, 70000]})\n\nfusion_multi = pd.merge(df1, df2, on=['ID', 'Ville'])\nprint(fusion_multi)\nExercice 5 :\n\nCréez deux DataFrames et appliquez différents types de jointures.\nTestez la concaténation avec des DataFrames ayant des colonnes différentes."
  },
  {
    "objectID": "doc/cours/analysedonnees.html#conclusion",
    "href": "doc/cours/analysedonnees.html#conclusion",
    "title": "Analyse de données avec Pandas",
    "section": "",
    "text": "Ce cours vous a permis d’apprendre à :\n\nCharger et manipuler des ensembles de données.\nEffectuer des analyses exploratoires et des transformations.\nNettoyer les données et appliquer des techniques avancées.\nFusionner et joindre plusieurs ensembles de données pour une analyse plus complète."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#introduction",
    "href": "doc/cours/analysedonnees-slides.html#introduction",
    "title": "Analyse de données avec Pandas",
    "section": "Introduction",
    "text": "Introduction\nPandas est une bibliothèque open-source essentielle en Python pour la manipulation et l’analyse de données. Elle permet de travailler avec des ensembles de données sous forme de tableaux en offrant des outils puissants pour nettoyer, transformer et analyser les données efficacement."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#installation-et-importation",
    "href": "doc/cours/analysedonnees-slides.html#installation-et-importation",
    "title": "Analyse de données avec Pandas",
    "section": "Installation et Importation",
    "text": "Installation et Importation\nSi Pandas n’est pas encore installé, vous pouvez l’ajouter à votre environnement Python avec la commande suivante :\npip install pandas\nUne fois installé, importez Pandas :\nimport pandas as pd\nL’alias pd est une convention utilisée pour simplifier l’appel aux fonctions de la bibliothèque."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#création-et-chargement-des-données",
    "href": "doc/cours/analysedonnees-slides.html#création-et-chargement-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "Création et Chargement des Données",
    "text": "Création et Chargement des Données\nPandas offre plusieurs méthodes pour créer des jeux de données ou les charger depuis divers formats."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#sélection-et-filtrage-des-données",
    "href": "doc/cours/analysedonnees-slides.html#sélection-et-filtrage-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "Sélection et Filtrage des Données",
    "text": "Sélection et Filtrage des Données\nL’accès aux données est une étape essentielle pour manipuler efficacement un DataFrame."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#transformation-et-nettoyage-des-données",
    "href": "doc/cours/analysedonnees-slides.html#transformation-et-nettoyage-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "Transformation et Nettoyage des Données",
    "text": "Transformation et Nettoyage des Données\nLes jeux de données réels sont souvent incomplets ou mal structurés. Pandas offre des outils pour les corriger."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#gestion-des-indices",
    "href": "doc/cours/analysedonnees-slides.html#gestion-des-indices",
    "title": "Analyse de données avec Pandas",
    "section": "Gestion des indices",
    "text": "Gestion des indices\nPandas permet de manipuler et personnaliser les indices d’un DataFrame pour optimiser l’analyse des données."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#tri-et-ordonnancement-des-données",
    "href": "doc/cours/analysedonnees-slides.html#tri-et-ordonnancement-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "Tri et ordonnancement des données",
    "text": "Tri et ordonnancement des données\nPandas permet de trier les données selon différentes colonnes."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#optimisation-et-performances",
    "href": "doc/cours/analysedonnees-slides.html#optimisation-et-performances",
    "title": "Analyse de données avec Pandas",
    "section": "Optimisation et performances",
    "text": "Optimisation et performances\nPandas permet d’améliorer les performances des manipulations de données."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#exportation-des-données",
    "href": "doc/cours/analysedonnees-slides.html#exportation-des-données",
    "title": "Analyse de données avec Pandas",
    "section": "Exportation des données",
    "text": "Exportation des données\nPandas permet d’exporter facilement les résultats de l’analyse sous différents formats.\ndf.to_csv('output.csv', index=False)  # Sauvegarde en CSV\ndf.to_excel('output.xlsx', index=False)  # Sauvegarde en Excel\ndf.to_json('output.json')  # Sauvegarde en JSON\nPourquoi exporter les données ?\n\nFacilite le partage et la réutilisation des résultats.\nPermet de documenter le travail réalisé."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#groupby-et-agrégations",
    "href": "doc/cours/analysedonnees-slides.html#groupby-et-agrégations",
    "title": "Analyse de données avec Pandas",
    "section": "GroupBy et Agrégations",
    "text": "GroupBy et Agrégations\nPandas facilite le regroupement des données et leur analyse statistique."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#jointures-et-fusion-de-données",
    "href": "doc/cours/analysedonnees-slides.html#jointures-et-fusion-de-données",
    "title": "Analyse de données avec Pandas",
    "section": "Jointures et Fusion de Données",
    "text": "Jointures et Fusion de Données\nLorsqu’on travaille avec plusieurs ensembles de données, il est souvent nécessaire de les fusionner pour obtenir une vue d’ensemble cohérente. Pandas offre plusieurs méthodes pour combiner des DataFrames."
  },
  {
    "objectID": "doc/cours/analysedonnees-slides.html#conclusion",
    "href": "doc/cours/analysedonnees-slides.html#conclusion",
    "title": "Analyse de données avec Pandas",
    "section": "Conclusion",
    "text": "Conclusion\nCe cours vous a permis d’apprendre à :\n\nCharger et manipuler des ensembles de données.\nEffectuer des analyses exploratoires et des transformations.\nNettoyer les données et appliquer des techniques avancées.\nFusionner et joindre plusieurs ensembles de données pour une analyse plus complète."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation avec Python: Analyse de données et Data visualisation",
    "section": "",
    "text": "6 sessions de 3 heures (18 heures au total)"
  },
  {
    "objectID": "index.html#contenu-du-cours",
    "href": "index.html#contenu-du-cours",
    "title": "Programmation avec Python: Analyse de données et Data visualisation",
    "section": "Contenu du cours",
    "text": "Contenu du cours\n\nIntroduction à Python\n\nPrésentation et installation\nVariables, types de données, opérateurs\n\nStructures de contrôle\n\nConditions (if, elif, else)\nBoucles (for, while)\nGestion des erreurs (try, except)\n\nLes fonctions\n\nDéfinir et appeler des fonctions\nParamètres, valeurs de retour\n\nManipulation de données avec pandas\n\nChargement de fichiers CSV/Excel\nNettoyage des données (valeurs manquantes, transformations)\nSélection et filtrage des données\n\nVisualisation des données\n\nGraphiques avec Matplotlib\nVisualisation avancée avec Seaborn\n\nProgrammation orientée objet (POO)\n\nDéfinition de classes, objets, méthodes\n\nIntroduction au Machine Learning avec Python\n\nBibliothèques essentielles : scikit-learn\nPréparation des données pour le ML (normalisation, division en train/test)\nModèles supervisés : régression linéaire et classification (KNN)\nÉvaluation des modèles : métriques (MAE, R², précision, rappel)\nNotions de surapprentissage et régularisation\n\nProjet final\n\nNettoyage, exploration, visualisation et modélisation d’un dataset"
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#introduction",
    "href": "doc/cours/manipdonnees-slides.html#introduction",
    "title": "Manipulation des données avec Numpy",
    "section": "Introduction",
    "text": "Introduction\nNumPy (Numerical Python) est une bibliothèque fondamentale pour le calcul scientifique en Python. Elle permet de travailler efficacement avec des tableaux multidimensionnels et offre une large gamme d’opérations mathématiques optimisées.\nL’intérêt principal de NumPy est sa capacité à effectuer des calculs beaucoup plus rapidement que les structures de données classiques en Python comme les listes. En effet, NumPy repose sur des algorithmes optimisés et implémentés en C, ce qui améliore considérablement la performance et réduit le temps de calcul."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#installation-et-importation",
    "href": "doc/cours/manipdonnees-slides.html#installation-et-importation",
    "title": "Manipulation des données avec Numpy",
    "section": "Installation et Importation",
    "text": "Installation et Importation\nNumPy est inclus dans de nombreuses distributions Python, mais s’il n’est pas installé, utilisez la commande suivante :\npip install numpy\nEnsuite, importez NumPy dans votre script Python :\nimport numpy as np\nL’alias np est utilisé par convention pour éviter d’avoir à taper numpy en entier à chaque fois."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#création-et-manipulation-des-tableaux-numpy",
    "href": "doc/cours/manipdonnees-slides.html#création-et-manipulation-des-tableaux-numpy",
    "title": "Manipulation des données avec Numpy",
    "section": "Création et Manipulation des Tableaux NumPy",
    "text": "Création et Manipulation des Tableaux NumPy\nNumPy repose sur une structure de données appelée ndarray (N-dimensional array), qui est un tableau multidimensionnel homogène, optimisé pour les opérations mathématiques."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#indexation-et-slicing",
    "href": "doc/cours/manipdonnees-slides.html#indexation-et-slicing",
    "title": "Manipulation des données avec Numpy",
    "section": "Indexation et Slicing",
    "text": "Indexation et Slicing\nL’accès aux éléments d’un tableau NumPy se fait de manière similaire aux listes Python, mais avec des fonctionnalités supplémentaires."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#opérations-mathématiques-et-statistiques",
    "href": "doc/cours/manipdonnees-slides.html#opérations-mathématiques-et-statistiques",
    "title": "Manipulation des données avec Numpy",
    "section": "Opérations Mathématiques et Statistiques",
    "text": "Opérations Mathématiques et Statistiques\nNumPy permet d’effectuer des calculs mathématiques sur des tableaux de manière optimisée. Ces opérations peuvent être appliquées élément par élément sans nécessiter de boucle explicite.\narr = np.array([1, 2, 3, 4, 5])\nprint(arr + 10)  # Ajouter 10 à chaque élément\nprint(arr ** 2)  # Élever chaque élément au carré\nPourquoi ces opérations sont-elles utiles ?\n\nElles permettent d’éviter l’utilisation de boucles explicites en Python, ce qui améliore grandement les performances.\nElles sont très utilisées dans le cadre du traitement des données et du calcul scientifique.\n\nNumPy fournit également des fonctions statistiques :\nprint(arr.mean())  # Moyenne\nprint(arr.sum())   # Somme\nprint(arr.std())   # Écart-type\nExercice 3 : - Créez une matrice 5x5 remplie de nombres aléatoires et calculez sa moyenne et son écart-type."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#reshaping-et-manipulation-des-formes",
    "href": "doc/cours/manipdonnees-slides.html#reshaping-et-manipulation-des-formes",
    "title": "Manipulation des données avec Numpy",
    "section": "Reshaping et Manipulation des Formes",
    "text": "Reshaping et Manipulation des Formes\nLe reshaping permet de modifier la structure d’un tableau sans en changer les données. Cela est très utile lorsqu’on manipule des matrices pour l’apprentissage automatique ou la visualisation des données.\narr = np.arange(12).reshape(3, 4)  # Transformation en 3 lignes, 4 colonnes\nprint(arr)\nLa transposition est également une technique couramment utilisée pour réarranger les axes d’un tableau :\nprint(arr.T)  # Transpose la matrice\nExercice 4 : - Créez une matrice 3x3 et affichez sa transposée."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#broadcasting-et-vectorisation",
    "href": "doc/cours/manipdonnees-slides.html#broadcasting-et-vectorisation",
    "title": "Manipulation des données avec Numpy",
    "section": "Broadcasting et Vectorisation",
    "text": "Broadcasting et Vectorisation\nLe broadcasting est un mécanisme puissant de NumPy qui permet d’effectuer des opérations entre tableaux de tailles différentes sans copier les données.\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr + np.array([10, 20, 30]))  # Broadcasting\nPourquoi le broadcasting est important ? - Il permet d’optimiser les calculs en évitant la création de copies inutiles. - Il est essentiel pour le traitement efficace des images et des séries temporelles.\nExercice 5 : - Multipliez une matrice par un vecteur ligne avec broadcasting."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#gestion-des-valeurs-manquantes",
    "href": "doc/cours/manipdonnees-slides.html#gestion-des-valeurs-manquantes",
    "title": "Manipulation des données avec Numpy",
    "section": "Gestion des Valeurs Manquantes",
    "text": "Gestion des Valeurs Manquantes\nNumPy offre plusieurs fonctions pour détecter et gérer les valeurs manquantes dans les jeux de données.\narr = np.array([1, 2, np.nan, 4, 5])\nprint(np.isnan(arr))  # Détecter les NaN\nprint(np.nanmean(arr))  # Moyenne en ignorant NaN\nPourquoi est-ce utile ? - En analyse de données, les valeurs manquantes sont courantes et doivent être traitées pour éviter les erreurs dans les calculs. - NumPy permet de gérer ces valeurs sans nécessiter de prétraitement complexe.\nExercice 6 : - Remplacez les valeurs NaN par la moyenne du tableau."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#applications-pratiques",
    "href": "doc/cours/manipdonnees-slides.html#applications-pratiques",
    "title": "Manipulation des données avec Numpy",
    "section": "Applications Pratiques",
    "text": "Applications Pratiques\nNumPy est souvent utilisé pour des applications pratiques en science des données et en intelligence artificielle."
  },
  {
    "objectID": "doc/cours/manipdonnees-slides.html#conclusion",
    "href": "doc/cours/manipdonnees-slides.html#conclusion",
    "title": "Manipulation des données avec Numpy",
    "section": "Conclusion",
    "text": "Conclusion\nCe cours vous a permis de maîtriser :\n\nLa manipulation et la création de tableaux NumPy\nLes opérations mathématiques et statistiques\nLes techniques avancées de reshaping et broadcasting"
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html",
    "href": "doc/cours/manipulationdonnees.html",
    "title": "Manipulation des données avec Numpy",
    "section": "",
    "text": "NumPy (Numerical Python) est une bibliothèque fondamentale pour le calcul scientifique en Python. Elle permet de travailler efficacement avec des tableaux multidimensionnels et offre une large gamme d’opérations mathématiques optimisées.\nL’intérêt principal de NumPy est sa capacité à effectuer des calculs beaucoup plus rapidement que les structures de données classiques en Python comme les listes. En effet, NumPy repose sur des algorithmes optimisés et implémentés en C, ce qui améliore considérablement la performance et réduit le temps de calcul.\n\n\n\nEfficacité et rapidité : NumPy effectue les opérations mathématiques sur des tableaux de manière optimisée.\nGestion de données complexes : permet de manipuler aisément des matrices, tenseurs et grandes séries de données.\nCompatibilité avec d’autres bibliothèques : NumPy est souvent utilisé avec Pandas, Matplotlib, et Scikit-learn pour l’analyse et la modélisation des données.\n\nObjectifs de ce cours : - Comprendre et manipuler les tableaux (ndarray) de NumPy - Appliquer des opérations mathématiques et statistiques - Optimiser les calculs avec le broadcasting et la vectorisation - Transformer et structurer les données efficacement"
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#introduction",
    "href": "doc/cours/manipulationdonnees.html#introduction",
    "title": "Manipulation des données avec Numpy",
    "section": "",
    "text": "NumPy (Numerical Python) est une bibliothèque fondamentale pour le calcul scientifique en Python. Elle permet de travailler efficacement avec des tableaux multidimensionnels et offre une large gamme d’opérations mathématiques optimisées.\nL’intérêt principal de NumPy est sa capacité à effectuer des calculs beaucoup plus rapidement que les structures de données classiques en Python comme les listes. En effet, NumPy repose sur des algorithmes optimisés et implémentés en C, ce qui améliore considérablement la performance et réduit le temps de calcul.\n\n\n\nEfficacité et rapidité : NumPy effectue les opérations mathématiques sur des tableaux de manière optimisée.\nGestion de données complexes : permet de manipuler aisément des matrices, tenseurs et grandes séries de données.\nCompatibilité avec d’autres bibliothèques : NumPy est souvent utilisé avec Pandas, Matplotlib, et Scikit-learn pour l’analyse et la modélisation des données.\n\nObjectifs de ce cours : - Comprendre et manipuler les tableaux (ndarray) de NumPy - Appliquer des opérations mathématiques et statistiques - Optimiser les calculs avec le broadcasting et la vectorisation - Transformer et structurer les données efficacement"
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#installation-et-importation",
    "href": "doc/cours/manipulationdonnees.html#installation-et-importation",
    "title": "Manipulation des données avec Numpy",
    "section": "2 Installation et Importation",
    "text": "2 Installation et Importation\nNumPy est inclus dans de nombreuses distributions Python, mais s’il n’est pas installé, utilisez la commande suivante :\npip install numpy\nEnsuite, importez NumPy dans votre script Python :\nimport numpy as np\nL’alias np est utilisé par convention pour éviter d’avoir à taper numpy en entier à chaque fois."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#création-et-manipulation-des-tableaux-numpy",
    "href": "doc/cours/manipulationdonnees.html#création-et-manipulation-des-tableaux-numpy",
    "title": "Manipulation des données avec Numpy",
    "section": "3 Création et Manipulation des Tableaux NumPy",
    "text": "3 Création et Manipulation des Tableaux NumPy\nNumPy repose sur une structure de données appelée ndarray (N-dimensional array), qui est un tableau multidimensionnel homogène, optimisé pour les opérations mathématiques.\n\nCréation de Tableaux (ndarray)\nLes tableaux NumPy peuvent être créés à partir de listes Python, de valeurs prédéfinies ou de valeurs générées automatiquement :\n# Création d'un tableau à partir d'une liste\narr1 = np.array([1, 2, 3, 4, 5])\nprint(arr1)\n\n# Tableau multidimensionnel\narr2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2)\nD’autres méthodes permettent de générer rapidement des tableaux :\nnp.zeros((3, 3))    # Matrice 3x3 remplie de 0\nnp.ones((2, 4))     # Matrice 2x4 remplie de 1\nnp.full((3, 3), 7)  # Matrice 3x3 remplie de 7\nnp.eye(4)           # Matrice identité 4x4\nnp.linspace(0, 10, 5)  # 5 valeurs espacées entre 0 et 10\nPourquoi ces méthodes sont utiles ?\n\nzeros et ones permettent d’initialiser rapidement des tableaux sans avoir à taper les valeurs une à une.\neye est très utilisé en algèbre linéaire pour les calculs de matrices identité.\nlinspace est idéal pour générer des valeurs numériques espacées uniformément.\n\nExercice 1 :\n\nCréez un tableau NumPy de 4x4 rempli de nombres aléatoires entre 0 et 1.\nGénérer une séquence de 10 nombres entre 1 et 100."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#indexation-et-slicing",
    "href": "doc/cours/manipulationdonnees.html#indexation-et-slicing",
    "title": "Manipulation des données avec Numpy",
    "section": "4 Indexation et Slicing",
    "text": "4 Indexation et Slicing\nL’accès aux éléments d’un tableau NumPy se fait de manière similaire aux listes Python, mais avec des fonctionnalités supplémentaires.\n\nSélection d’éléments\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[2])  # Accéder au 3e élément\nL’indexation commence toujours à 0 en Python, donc arr[2] retourne 30.\n\n\nIndexation avancée\nNumPy permet d’accéder à des sous-ensembles de tableaux plus facilement :\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[1, 2])  # 6 (ligne 2, colonne 3)\n\n\nSlicing (Découpage d’un tableau)\nAvec NumPy, on peut extraire plusieurs valeurs avec des tranches (slices) :\nsub_arr = arr2d[:2, 1:]  # Extraction de sous-tableau\nprint(sub_arr)\nPourquoi utiliser le slicing ?\n\nPermet d’extraire rapidement des parties spécifiques d’un tableau sans devoir recréer un autre tableau manuellement.\nTrès utile en analyse de données pour filtrer des valeurs selon des conditions spécifiques.\n\nExercice 2 :\n\nExtraire la première colonne d’une matrice 3x3.\nModifier les valeurs d’une portion spécifique d’un tableau."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#opérations-mathématiques-et-statistiques",
    "href": "doc/cours/manipulationdonnees.html#opérations-mathématiques-et-statistiques",
    "title": "Manipulation des données avec Numpy",
    "section": "5 Opérations Mathématiques et Statistiques",
    "text": "5 Opérations Mathématiques et Statistiques\nNumPy permet d’effectuer des calculs mathématiques sur des tableaux de manière optimisée. Ces opérations peuvent être appliquées élément par élément sans nécessiter de boucle explicite.\narr = np.array([1, 2, 3, 4, 5])\nprint(arr + 10)  # Ajouter 10 à chaque élément\nprint(arr ** 2)  # Élever chaque élément au carré\nPourquoi ces opérations sont-elles utiles ?\n\nElles permettent d’éviter l’utilisation de boucles explicites en Python, ce qui améliore grandement les performances.\nElles sont très utilisées dans le cadre du traitement des données et du calcul scientifique.\n\nNumPy fournit également des fonctions statistiques :\nprint(arr.mean())  # Moyenne\nprint(arr.sum())   # Somme\nprint(arr.std())   # Écart-type\nExercice 3 : - Créez une matrice 5x5 remplie de nombres aléatoires et calculez sa moyenne et son écart-type."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#reshaping-et-manipulation-des-formes",
    "href": "doc/cours/manipulationdonnees.html#reshaping-et-manipulation-des-formes",
    "title": "Manipulation des données avec Numpy",
    "section": "6 Reshaping et Manipulation des Formes",
    "text": "6 Reshaping et Manipulation des Formes\nLe reshaping permet de modifier la structure d’un tableau sans en changer les données. Cela est très utile lorsqu’on manipule des matrices pour l’apprentissage automatique ou la visualisation des données.\narr = np.arange(12).reshape(3, 4)  # Transformation en 3 lignes, 4 colonnes\nprint(arr)\nLa transposition est également une technique couramment utilisée pour réarranger les axes d’un tableau :\nprint(arr.T)  # Transpose la matrice\nExercice 4 : - Créez une matrice 3x3 et affichez sa transposée."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#broadcasting-et-vectorisation",
    "href": "doc/cours/manipulationdonnees.html#broadcasting-et-vectorisation",
    "title": "Manipulation des données avec Numpy",
    "section": "7 Broadcasting et Vectorisation",
    "text": "7 Broadcasting et Vectorisation\nLe broadcasting est un mécanisme puissant de NumPy qui permet d’effectuer des opérations entre tableaux de tailles différentes sans copier les données.\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr + np.array([10, 20, 30]))  # Broadcasting\nPourquoi le broadcasting est important ? - Il permet d’optimiser les calculs en évitant la création de copies inutiles. - Il est essentiel pour le traitement efficace des images et des séries temporelles.\nExercice 5 : - Multipliez une matrice par un vecteur ligne avec broadcasting."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#gestion-des-valeurs-manquantes",
    "href": "doc/cours/manipulationdonnees.html#gestion-des-valeurs-manquantes",
    "title": "Manipulation des données avec Numpy",
    "section": "8 Gestion des Valeurs Manquantes",
    "text": "8 Gestion des Valeurs Manquantes\nNumPy offre plusieurs fonctions pour détecter et gérer les valeurs manquantes dans les jeux de données.\narr = np.array([1, 2, np.nan, 4, 5])\nprint(np.isnan(arr))  # Détecter les NaN\nprint(np.nanmean(arr))  # Moyenne en ignorant NaN\nPourquoi est-ce utile ? - En analyse de données, les valeurs manquantes sont courantes et doivent être traitées pour éviter les erreurs dans les calculs. - NumPy permet de gérer ces valeurs sans nécessiter de prétraitement complexe.\nExercice 6 : - Remplacez les valeurs NaN par la moyenne du tableau."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#applications-pratiques",
    "href": "doc/cours/manipulationdonnees.html#applications-pratiques",
    "title": "Manipulation des données avec Numpy",
    "section": "9 Applications Pratiques",
    "text": "9 Applications Pratiques\nNumPy est souvent utilisé pour des applications pratiques en science des données et en intelligence artificielle.\n\nProduit Matriciel\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nprint(np.dot(A, B))  # Produit matriciel\n\n\nSimulation de Données\nsim_data = np.random.randn(1000)\nprint(np.histogram(sim_data, bins=10))  # Histogramme des valeurs simulées\nExercice 7 : - Simulez une série de valeurs et tracez son histogramme."
  },
  {
    "objectID": "doc/cours/manipulationdonnees.html#conclusion",
    "href": "doc/cours/manipulationdonnees.html#conclusion",
    "title": "Manipulation des données avec Numpy",
    "section": "10 Conclusion",
    "text": "10 Conclusion\nCe cours vous a permis de maîtriser :\n\nLa manipulation et la création de tableaux NumPy\nLes opérations mathématiques et statistiques\nLes techniques avancées de reshaping et broadcasting"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#les-fonctions-python-existantes",
    "href": "doc/cours/fonctions-modules-poo-slides.html#les-fonctions-python-existantes",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Les fonctions Python existantes",
    "text": "Les fonctions Python existantes\nPython offre une large gamme de fonctions intégrées comme print(), len(), type() ou encore sum(). Ces fonctions permettent de réaliser des opérations courantes sans définir de nouvelles fonctions.\nExemples:\nprint(\"Bonjour\")  # Affiche : Bonjour\nprint(len(\"Python\"))  # Affiche : 6"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#fonction-simple-sans-paramètre",
    "href": "doc/cours/fonctions-modules-poo-slides.html#fonction-simple-sans-paramètre",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Fonction simple sans paramètre",
    "text": "Fonction simple sans paramètre\nUne fonction sans paramètre exécute toujours les mêmes instructions :\ndef dire_bonjour():\n    return \"Bonjour !\"\n\nprint(dire_bonjour())  # Affiche : Bonjour !"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#fonction-avec-paramètres",
    "href": "doc/cours/fonctions-modules-poo-slides.html#fonction-avec-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Fonction avec paramètres",
    "text": "Fonction avec paramètres\nUne fonction avec paramètres peut être personnalisée selon les valeurs passées :\ndef saluer(nom):\n    return f\"Bonjour, {nom}!\"\n\nprint(saluer(\"Alice\"))  # Affiche : Bonjour, Alice!"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#valeur-par-défaut-des-paramètres",
    "href": "doc/cours/fonctions-modules-poo-slides.html#valeur-par-défaut-des-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Valeur par défaut des paramètres",
    "text": "Valeur par défaut des paramètres\nLes paramètres peuvent avoir des valeurs par défaut :\ndef saluer(nom, message=\"Bonjour\"):\n    return f\"{message}, {nom}!\"\n\n# Exemple d'utilisation\nprint(saluer(\"Jean\"))  # Affiche : Bonjour, Jean!\nprint(saluer(\"Marie\", \"Salut\"))  # Affiche : Salut, Marie!"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#affecter-une-instance-de-fonction-à-une-variable",
    "href": "doc/cours/fonctions-modules-poo-slides.html#affecter-une-instance-de-fonction-à-une-variable",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Affecter une instance de fonction à une variable",
    "text": "Affecter une instance de fonction à une variable\nLes fonctions peuvent être assignées à des variables pour être utilisées plus tard :\ndef addition(a, b):\n    return a + b\n\n# Affecter la fonction à une variable\najouter = addition\n\n# Exemple d'utilisation\nprint(ajouter(3, 4))  # Affiche : 7"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#fonction-avec-un-nombre-variable-de-paramètres",
    "href": "doc/cours/fonctions-modules-poo-slides.html#fonction-avec-un-nombre-variable-de-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Fonction avec un nombre variable de paramètres",
    "text": "Fonction avec un nombre variable de paramètres\nUne fonction peut accepter un nombre variable d’arguments :\ndef somme(*args):\n    return sum(args)\n\n# Exemple d'utilisation\nprint(somme(1, 2, 3, 4))  # Affiche : 10\nprint(somme(5, 10))       # Affiche : 15"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#passage-des-paramètres-immuable-et-non-immuable",
    "href": "doc/cours/fonctions-modules-poo-slides.html#passage-des-paramètres-immuable-et-non-immuable",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Passage des paramètres : immuable et non immuable",
    "text": "Passage des paramètres : immuable et non immuable\nLes types immuables comme les nombres ou les chaînes ne peuvent pas être modifiés dans une fonction, alors que les types mutables comme les listes peuvent l’être."
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#variable-localevariable-globale",
    "href": "doc/cours/fonctions-modules-poo-slides.html#variable-localevariable-globale",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Variable locale/variable globale",
    "text": "Variable locale/variable globale\n\nVariable locale : Définie à l’intérieur d’une fonction et inaccessible en dehors.\nVariable globale : Accessible partout dans le programme."
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#introduction-aux-modules",
    "href": "doc/cours/fonctions-modules-poo-slides.html#introduction-aux-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Introduction aux modules",
    "text": "Introduction aux modules\nUn module est un fichier contenant du code Python (fonctions, classes, variables) que vous pouvez réutiliser dans d’autres fichiers. L’utilisation de modules permet de structurer un projet et d’encapsuler des fonctionnalités spécifiques dans des fichiers distincts.\nExemple :\nCréez un fichier nommé mon_module.py avec le contenu suivant :\ndef saluer(nom):\n    return f\"Bonjour, {nom}!\""
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#utiliser-un-module-dans-un-autre-fichier",
    "href": "doc/cours/fonctions-modules-poo-slides.html#utiliser-un-module-dans-un-autre-fichier",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Utiliser un module dans un autre fichier",
    "text": "Utiliser un module dans un autre fichier\nDans un autre fichier, vous pouvez importer et utiliser ce module :\nimport mon_module\n\nprint(mon_module.saluer(\"Alice\"))  # Affiche : Bonjour, Alice!"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#importation-de-modules",
    "href": "doc/cours/fonctions-modules-poo-slides.html#importation-de-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Importation de modules",
    "text": "Importation de modules\nIl existe plusieurs façons d’importer un module ou ses éléments :\n\nImporter un module complet :\n\nimport math\nprint(math.sqrt(16))  # Affiche : 4.0\n\nImporter un élément spécifique d’un module :\n\nfrom math import sqrt\nprint(sqrt(16))  # Affiche : 4.0\n\nRenommer un module ou un élément lors de l’importation :\n\nimport math as m\nprint(m.sqrt(16))  # Affiche : 4.0"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#modules-standards",
    "href": "doc/cours/fonctions-modules-poo-slides.html#modules-standards",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Modules standards",
    "text": "Modules standards\nPython fournit une bibliothèque standard riche avec des modules pour diverses tâches :\n\nManipulation de dates :\n\nimport datetime\n\naujourdhui = datetime.date.today()\nprint(aujourdhui)  # Affiche la date d'aujourd'hui\n\nGénération de nombres aléatoires :\n\nimport random\n\nnombre = random.randint(1, 10)\nprint(nombre)  # Affiche un nombre aléatoire entre 1 et 10"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#créer-et-structurer-un-projet-avec-des-modules",
    "href": "doc/cours/fonctions-modules-poo-slides.html#créer-et-structurer-un-projet-avec-des-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Créer et structurer un projet avec des modules",
    "text": "Créer et structurer un projet avec des modules\nUn projet Python peut contenir plusieurs fichiers et répertoires pour organiser le code.\nStructure d’exemple :\nmon_projet/\n|-- main.py\n|-- utilitaires.py\n|-- data/\n    |-- __init__.py\n    |-- traitement.py\nDans le fichier main.py, vous pouvez importer les modules comme suit :\nfrom data.traitement import ma_fonction"
  },
  {
    "objectID": "doc/cours/fonctions-modules-poo-slides.html#les-packages",
    "href": "doc/cours/fonctions-modules-poo-slides.html#les-packages",
    "title": "Fonctions, Modules et POO en Python",
    "section": "Les packages",
    "text": "Les packages\nUn package est un répertoire contenant plusieurs modules, généralement accompagné d’un fichier __init__.py.\nExemple de structure de package :\nmon_package/\n|-- __init__.py\n|-- module1.py\n|-- module2.py\nVous pouvez importer des éléments d’un package comme suit :\nfrom mon_package.module1 import ma_fonction"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html",
    "href": "doc/cours/fonctionsmodules.html",
    "title": "Fonctions, Modules et POO en Python",
    "section": "",
    "text": "Comprendre les concepts des fonctions en Python : définition, paramètres et valeurs de retour.\nExplorer les fonctions anonymes (lambda) et leur utilisation pratique.\nDifférencier les variables locales et globales.\nMaîtriser les listes en compréhension et les dictionnaires en compréhension.\nStructurer un projet Python avec des modules.\nIntroduire les bases de la Programmation Orientée Objet (POO)."
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#les-fonctions-python-existantes",
    "href": "doc/cours/fonctionsmodules.html#les-fonctions-python-existantes",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.1 Les fonctions Python existantes",
    "text": "2.1 Les fonctions Python existantes\nPython offre une large gamme de fonctions intégrées comme print(), len(), type() ou encore sum(). Ces fonctions permettent de réaliser des opérations courantes sans définir de nouvelles fonctions.\nExemples:\nprint(\"Bonjour\")  # Affiche : Bonjour\nprint(len(\"Python\"))  # Affiche : 6"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#fonction-simple-sans-paramètre",
    "href": "doc/cours/fonctionsmodules.html#fonction-simple-sans-paramètre",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.2 Fonction simple sans paramètre",
    "text": "2.2 Fonction simple sans paramètre\nUne fonction sans paramètre exécute toujours les mêmes instructions :\ndef dire_bonjour():\n    return \"Bonjour !\"\n\nprint(dire_bonjour())  # Affiche : Bonjour !"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#fonction-avec-paramètres",
    "href": "doc/cours/fonctionsmodules.html#fonction-avec-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.3 Fonction avec paramètres",
    "text": "2.3 Fonction avec paramètres\nUne fonction avec paramètres peut être personnalisée selon les valeurs passées :\ndef saluer(nom):\n    return f\"Bonjour, {nom}!\"\n\nprint(saluer(\"Alice\"))  # Affiche : Bonjour, Alice!"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#valeur-par-défaut-des-paramètres",
    "href": "doc/cours/fonctionsmodules.html#valeur-par-défaut-des-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.4 Valeur par défaut des paramètres",
    "text": "2.4 Valeur par défaut des paramètres\nLes paramètres peuvent avoir des valeurs par défaut :\ndef saluer(nom, message=\"Bonjour\"):\n    return f\"{message}, {nom}!\"\n\n# Exemple d'utilisation\nprint(saluer(\"Jean\"))  # Affiche : Bonjour, Jean!\nprint(saluer(\"Marie\", \"Salut\"))  # Affiche : Salut, Marie!"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#affecter-une-instance-de-fonction-à-une-variable",
    "href": "doc/cours/fonctionsmodules.html#affecter-une-instance-de-fonction-à-une-variable",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.5 Affecter une instance de fonction à une variable",
    "text": "2.5 Affecter une instance de fonction à une variable\nLes fonctions peuvent être assignées à des variables pour être utilisées plus tard :\ndef addition(a, b):\n    return a + b\n\n# Affecter la fonction à une variable\najouter = addition\n\n# Exemple d'utilisation\nprint(ajouter(3, 4))  # Affiche : 7"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#fonction-avec-un-nombre-variable-de-paramètres",
    "href": "doc/cours/fonctionsmodules.html#fonction-avec-un-nombre-variable-de-paramètres",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.6 Fonction avec un nombre variable de paramètres",
    "text": "2.6 Fonction avec un nombre variable de paramètres\nUne fonction peut accepter un nombre variable d’arguments :\ndef somme(*args):\n    return sum(args)\n\n# Exemple d'utilisation\nprint(somme(1, 2, 3, 4))  # Affiche : 10\nprint(somme(5, 10))       # Affiche : 15"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#passage-des-paramètres-immuable-et-non-immuable",
    "href": "doc/cours/fonctionsmodules.html#passage-des-paramètres-immuable-et-non-immuable",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.7 Passage des paramètres : immuable et non immuable",
    "text": "2.7 Passage des paramètres : immuable et non immuable\nLes types immuables comme les nombres ou les chaînes ne peuvent pas être modifiés dans une fonction, alors que les types mutables comme les listes peuvent l’être.\n\nExemple :\n\nAvec un type immuable (chaîne) :\ndef modifier_chaine(chaine):\n    chaine += \" modifié\"\n    return chaine\n\ntexte = \"Texte original\"\nprint(modifier_chaine(texte))  # Affiche : Texte original modifié\nprint(texte)  # Affiche : Texte original\n\n\n\nAvec un type mutable (liste) :\ndef ajouter_element(liste):\n    liste.append(5)\n\nma_liste = [1, 2, 3]\najouter_element(ma_liste)\nprint(ma_liste)  # Affiche : [1, 2, 3, 5]"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#variable-localevariable-globale",
    "href": "doc/cours/fonctionsmodules.html#variable-localevariable-globale",
    "title": "Fonctions, Modules et POO en Python",
    "section": "2.8 Variable locale/variable globale",
    "text": "2.8 Variable locale/variable globale\n\nVariable locale : Définie à l’intérieur d’une fonction et inaccessible en dehors.\nVariable globale : Accessible partout dans le programme.\n\n\nExemple :\n\nVariables locale :\nx = 10  # Variable globale\n\ndef afficher_variables():\n    y = 5  # Variable locale\n    print(\"x =\", x)  # Accède à la variable globale\n    print(\"y =\", y)  # Accède à la variable locale\n\nafficher_variables()\n# print(y)  # Provoque une erreur : y n'est pas défini en dehors de la fonction\n\n\n\nModifier une variable globale :\nz = 20  # Variable globale\n\ndef modifier_globale():\n    global z  # Permet de modifier la variable globale\n    z = 30\n\nmodifier_globale()\nprint(z)  # Affiche : 30\n\n\nFonctions anonymes (lambda) et leur usage pratique\nLes fonctions anonymes, appelées “lambda” en Python, sont des fonctions définies sans utiliser le mot-clé def. Elles permettent de créer des fonctions courtes, généralement en une seule ligne.\n\n\n\nDéfinir une fonction lambda\nUne fonction lambda suit cette syntaxe :\nlambda arguments: expression\n\narguments : Les paramètres que la fonction prend.\nexpression : L’opération ou le calcul effectué.\n\nExemple :\ncarre = lambda x: x ** 2\nprint(carre(4))  # Affiche : 16\n\n\n\nUtilisation des fonctions lambda\nLes fonctions lambda sont souvent utilisées lorsqu’une fonction temporaire ou rapide est nécessaire. Voici quelques cas d’usage pratique :\n\n1. Utilisation avec map()\nLa fonction map() applique une fonction donnée à chaque élément d’un itérable (comme une liste).\nnombres = [1, 2, 3, 4, 5]\ncarres = list(map(lambda x: x ** 2, nombres))\nprint(carres)  # Affiche : [1, 4, 9, 16, 25]\n\n\n2. Utilisation avec filter()\nLa fonction filter() retourne les éléments d’un itérable qui satisfont une condition.\nnombres = [1, 2, 3, 4, 5]\nnombres_pairs = list(filter(lambda x: x % 2 == 0, nombres))\nprint(nombres_pairs)  # Affiche : [2, 4]\n\n\n3. Utilisation avec sorted()\nLes fonctions lambda sont souvent utilisées pour trier des listes selon des critères spécifiques.\nnombres = [(1, 2), (3, 1), (5, 0)]\nnombres_tries = sorted(nombres, key=lambda x: x[1])\nprint(nombres_tries)  # Affiche : [(5, 0), (3, 1), (1, 2)]\n\n\n\n\nComparaison avec les fonctions définies\nLes fonctions lambda sont utiles pour des cas simples, mais elles ne remplacent pas les fonctions définies avec def, surtout pour des tâches complexes.\n\nExemple avec def :\ndef carre(x):\n    return x ** 2\n\nprint(carre(4))  # Affiche : 16\n\n\n\n\nUtilisation avancée\n\n1. Combiner lambda avec reduce()\nLa fonction reduce() applique une fonction de cumul à une séquence, réduisant ainsi cette séquence à une seule valeur.\nfrom functools import reduce\n\nnombres = [1, 2, 3, 4]\nsomme = reduce(lambda x, y: x + y, nombres)\nprint(somme)  # Affiche : 10\n\n\n2. Lambda dans des dictionnaires\nLes fonctions lambda peuvent être utilisées dans des dictionnaires pour effectuer des calculs conditionnels.\noperations = {\n    \"addition\": lambda x, y: x + y,\n    \"multiplication\": lambda x, y: x * y\n}\n\nprint(operations[\"addition\"](3, 5))  # Affiche : 8\nprint(operations[\"multiplication\"](3, 5))  # Affiche : 15\n\n\n\n\nBonnes pratiques\n\nLisibilité : N’utilisez pas de lambda pour des fonctions complexes. Préférez une fonction def pour améliorer la lisibilité.\nUsage limité : Les fonctions lambda sont conçues pour des cas simples et temporaires.\nDocumentez : Bien que les lambda soient concises, documentez leur utilisation si elles sont utilisées dans un code complexe.\n\n\n\n\nExercices pratiques\n\nCalcul de la somme des carrés :\n\nUtilisez une fonction lambda avec map() pour calculer le carré de chaque élément d’une liste, puis la somme des carrés avec reduce().\n\nFiltrage :\n\nÉcrivez une fonction lambda avec filter() pour trouver tous les mots contenant plus de 3 lettres dans une liste de mots.\n\nTri personnalisé :\n\nCréez une liste de tuples représentant des produits avec leur prix. Utilisez une fonction lambda avec sorted() pour trier la liste par prix."
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#introduction-aux-modules",
    "href": "doc/cours/fonctionsmodules.html#introduction-aux-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.1 Introduction aux modules",
    "text": "3.1 Introduction aux modules\nUn module est un fichier contenant du code Python (fonctions, classes, variables) que vous pouvez réutiliser dans d’autres fichiers. L’utilisation de modules permet de structurer un projet et d’encapsuler des fonctionnalités spécifiques dans des fichiers distincts.\nExemple :\nCréez un fichier nommé mon_module.py avec le contenu suivant :\ndef saluer(nom):\n    return f\"Bonjour, {nom}!\""
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#utiliser-un-module-dans-un-autre-fichier",
    "href": "doc/cours/fonctionsmodules.html#utiliser-un-module-dans-un-autre-fichier",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.2 Utiliser un module dans un autre fichier",
    "text": "3.2 Utiliser un module dans un autre fichier\nDans un autre fichier, vous pouvez importer et utiliser ce module :\nimport mon_module\n\nprint(mon_module.saluer(\"Alice\"))  # Affiche : Bonjour, Alice!"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#importation-de-modules",
    "href": "doc/cours/fonctionsmodules.html#importation-de-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.3 Importation de modules",
    "text": "3.3 Importation de modules\nIl existe plusieurs façons d’importer un module ou ses éléments :\n\nImporter un module complet :\n\nimport math\nprint(math.sqrt(16))  # Affiche : 4.0\n\nImporter un élément spécifique d’un module :\n\nfrom math import sqrt\nprint(sqrt(16))  # Affiche : 4.0\n\nRenommer un module ou un élément lors de l’importation :\n\nimport math as m\nprint(m.sqrt(16))  # Affiche : 4.0"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#modules-standards",
    "href": "doc/cours/fonctionsmodules.html#modules-standards",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.4 Modules standards",
    "text": "3.4 Modules standards\nPython fournit une bibliothèque standard riche avec des modules pour diverses tâches :\n\nManipulation de dates :\n\nimport datetime\n\naujourdhui = datetime.date.today()\nprint(aujourdhui)  # Affiche la date d'aujourd'hui\n\nGénération de nombres aléatoires :\n\nimport random\n\nnombre = random.randint(1, 10)\nprint(nombre)  # Affiche un nombre aléatoire entre 1 et 10"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#créer-et-structurer-un-projet-avec-des-modules",
    "href": "doc/cours/fonctionsmodules.html#créer-et-structurer-un-projet-avec-des-modules",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.5 Créer et structurer un projet avec des modules",
    "text": "3.5 Créer et structurer un projet avec des modules\nUn projet Python peut contenir plusieurs fichiers et répertoires pour organiser le code.\nStructure d’exemple :\nmon_projet/\n|-- main.py\n|-- utilitaires.py\n|-- data/\n    |-- __init__.py\n    |-- traitement.py\nDans le fichier main.py, vous pouvez importer les modules comme suit :\nfrom data.traitement import ma_fonction"
  },
  {
    "objectID": "doc/cours/fonctionsmodules.html#les-packages",
    "href": "doc/cours/fonctionsmodules.html#les-packages",
    "title": "Fonctions, Modules et POO en Python",
    "section": "3.6 Les packages",
    "text": "3.6 Les packages\nUn package est un répertoire contenant plusieurs modules, généralement accompagné d’un fichier __init__.py.\nExemple de structure de package :\nmon_package/\n|-- __init__.py\n|-- module1.py\n|-- module2.py\nVous pouvez importer des éléments d’un package comme suit :\nfrom mon_package.module1 import ma_fonction\n\n\nIntroduction à la Programmation Orientée Objet (POO)\nLa programmation orientée objet (POO) est un paradigme de programmation basé sur le concept de “classes” et “objets”, qui permet de structurer le code de manière modulaire et réutilisable.\n\n\n\nConcepts clés\n\nClasse : Modèle ou plan permettant de créer des objets. Elle définit les attributs (données) et les méthodes (fonctions).\nObjet : Instance d’une classe.\nAttributs : Variables associées à une classe ou un objet.\nMéthodes : Fonctions définies dans une classe pour manipuler ses attributs ou accomplir des tâches spécifiques.\n\n\n\n\nCréer une classe simple et instancier des objets\nVoici un exemple de classe simple représentant une “Personne” :\nclass Personne:\n    def __init__(self, nom, age):\n        self.nom = nom\n        self.age = age\n\n    def se_presenter(self):\n        return f\"Je m'appelle {self.nom} et j'ai {self.age} ans.\"\n\n# Instanciation d'objets\npersonne1 = Personne(\"Alice\", 30)\npersonne2 = Personne(\"Bob\", 25)\n\n# Utilisation\nprint(personne1.se_presenter())  # Affiche : Je m'appelle Alice et j'ai 30 ans.\nprint(personne2.se_presenter())  # Affiche : Je m'appelle Bob et j'ai 25 ans.\n\n\n\nObjet complexe\nUne classe peut contenir des attributs qui sont eux-mêmes des objets :\nclass Adresse:\n    def __init__(self, rue, ville):\n        self.rue = rue\n        self.ville = ville\n\nclass Personne:\n    def __init__(self, nom, age, adresse):\n        self.nom = nom\n        self.age = age\n        self.adresse = adresse\n\n    def afficher_adresse(self):\n        return f\"{self.adresse.rue}, {self.adresse.ville}\"\n\nadresse = Adresse(\"123 Rue Principale\", \"Paris\")\npersonne = Personne(\"Alice\", 30, adresse)\nprint(personne.afficher_adresse())  # Affiche : 123 Rue Principale, Paris\n\n\n\nHéritage\nL’héritage permet à une classe d’hériter des attributs et des méthodes d’une autre classe. Cela favorise la réutilisation du code.\nclass Animal:\n    def __init__(self, nom):\n        self.nom = nom\n\n    def parler(self):\n        pass  # Méthode à redéfinir\n\nclass Chien(Animal):\n    def parler(self):\n        return \"Woof\"\n\nclass Chat(Animal):\n    def parler(self):\n        return \"Meow\"\n\nchien = Chien(\"Rex\")\nchat = Chat(\"Miaou\")\nprint(chien.parler())  # Affiche : Woof\nprint(chat.parler())  # Affiche : Meow\n\n\n\nPolymorphisme\nLe polymorphisme permet d’utiliser une même méthode définie dans plusieurs classes différentes.\nanimaux = [Chien(\"Rex\"), Chat(\"Miaou\")]\n\nfor animal in animaux:\n    print(f\"{animal.nom} dit {animal.parler()}\")\n\n\n\nEncapsulation et propriétés\nL’encapsulation permet de contrôler l’accès et la modification des attributs d’une classe. Cela se fait généralement à l’aide des propriétés.\nclass CompteBancaire:\n    def __init__(self, titulaire, solde):\n        self.titulaire = titulaire\n        self.__solde = solde  # Attribut privé\n\n    @property\n    def solde(self):\n        return self.__solde\n\n    @solde.setter\n    def solde(self, montant):\n        if montant &gt;= 0:\n            self.__solde = montant\n        else:\n            raise ValueError(\"Le solde ne peut pas être négatif\")\n\ncompte = CompteBancaire(\"Alice\", 1000)\nprint(compte.solde)  # Accès au solde\ncompte.solde = 2000  # Modification du solde\nprint(compte.solde)  # Affiche : 2000\n\n\n\nAbstraction\nL’abstraction consiste à définir des classes ou des méthodes génériques qui servent de base pour les classes spécifiques. Cela se fait avec des classes ou méthodes abstraites.\nfrom abc import ABC, abstractmethod\n\nclass Forme(ABC):\n    @abstractmethod\n    def aire(self):\n        pass\n\nclass Rectangle(Forme):\n    def __init__(self, largeur, hauteur):\n        self.largeur = largeur\n        self.hauteur = hauteur\n\n    def aire(self):\n        return self.largeur * self.hauteur\n\nrectangle = Rectangle(10, 5)\nprint(rectangle.aire())  # Affiche : 50\n\n\n\nExercices pratiques\n\nCréer une classe Livre :\n\nAttributs : titre, auteur, pages.\nMéthode : afficher_informations qui affiche les détails du livre.\n\nCréer une classe Bibliotheque :\n\nAttributs : liste de livres.\nMéthodes : ajouter un livre, retirer un livre, afficher tous les livres.\n\nCréer une hiérarchie d’héritage :\n\nClasse de base Vehicule.\nClasses dérivées : Voiture, Moto avec des méthodes spécifiques comme afficher_type.\n\nCréer une classe abstraite Forme :\n\nMéthodes abstraites : aire et perimetre.\nImplémenter les classes Cercle et Rectangle."
  },
  {
    "objectID": "doc/cours/visualisationdonnees-slides.html#bibliothèques-principales-en-python",
    "href": "doc/cours/visualisationdonnees-slides.html#bibliothèques-principales-en-python",
    "title": "Visualisation des Données avec Matplotlib et Seaborn",
    "section": "Bibliothèques principales en Python :",
    "text": "Bibliothèques principales en Python :\n\nMatplotlib : Outil puissant pour créer des graphiques personnalisables.\nSeaborn : Extension de Matplotlib qui simplifie la création de graphiques statistiques avec des styles améliorés."
  },
  {
    "objectID": "doc/cours/visualisationdonnees-slides.html#choix-du-type-de-graphique-selon-la-nature-des-données",
    "href": "doc/cours/visualisationdonnees-slides.html#choix-du-type-de-graphique-selon-la-nature-des-données",
    "title": "Visualisation des Données avec Matplotlib et Seaborn",
    "section": "Choix du Type de Graphique selon la Nature des Données",
    "text": "Choix du Type de Graphique selon la Nature des Données\n\n\n\n\n\n\n\n\nType de Graphique\nType de Données\nUtilisation principale\n\n\n\n\nCourbe linéaire\nVariable continue\nSuivi d’une tendance\n\n\nHistogramme\nVariable numérique continue\nDistribution d’une variable\n\n\nDiagramme en barres\nVariable catégorielle\nComparaison entre différentes catégories\n\n\nNuage de points\nDeux variables numériques\nRelation entre deux variables\n\n\nBoxplot\nVariable numérique / catégorielle\nComparaison de distributions\n\n\nViolin plot\nVariable numérique / catégorielle\nVisualisation de la distribution\n\n\nHeatmap\nMatrice de valeurs numériques\nCorrélation entre variables\n\n\nPie chart (camembert)\nVariables catégoriques\nRépartition proportionnelle"
  },
  {
    "objectID": "doc/cours/dataviz.html",
    "href": "doc/cours/dataviz.html",
    "title": "Visualisation des Données avec Matplotlib et Seaborn",
    "section": "",
    "text": "La visualisation des données est une étape cruciale en science des données. Elle permet de mieux comprendre la structure des données, d’identifier des tendances, des anomalies et de communiquer efficacement les résultats de l’analyse.\n\n\n\nCompréhension : Transformer des données brutes en graphiques clairs et lisibles.\nCommunication : Présenter des résultats analytiques de manière percutante et accessible.\nAnalyse exploratoire : Détecter rapidement des corrélations, des patterns ou des valeurs aberrantes.\n\n\n\n\n\nMatplotlib : Outil puissant pour créer des graphiques personnalisables.\nSeaborn : Extension de Matplotlib qui simplifie la création de graphiques statistiques avec des styles améliorés.\n\n\n\n\n\n\n\n\n\n\n\n\nType de Graphique\nType de Données\nUtilisation principale\n\n\n\n\nCourbe linéaire\nVariable continue\nSuivi d’une tendance\n\n\nHistogramme\nVariable numérique continue\nDistribution d’une variable\n\n\nDiagramme en barres\nVariable catégorielle\nComparaison entre différentes catégories\n\n\nNuage de points\nDeux variables numériques\nRelation entre deux variables\n\n\nBoxplot\nVariable numérique / catégorielle\nComparaison de distributions\n\n\nViolin plot\nVariable numérique / catégorielle\nVisualisation de la distribution\n\n\nHeatmap\nMatrice de valeurs numériques\nCorrélation entre variables\n\n\nPie chart (camembert)\nVariables catégoriques\nRépartition proportionnelle"
  },
  {
    "objectID": "doc/cours/dataviz.html#bibliothèques-principales-en-python",
    "href": "doc/cours/dataviz.html#bibliothèques-principales-en-python",
    "title": "Visualisation des Données avec Matplotlib et Seaborn",
    "section": "",
    "text": "Matplotlib : Outil puissant pour créer des graphiques personnalisables.\nSeaborn : Extension de Matplotlib qui simplifie la création de graphiques statistiques avec des styles améliorés."
  },
  {
    "objectID": "doc/cours/dataviz.html#choix-du-type-de-graphique-selon-la-nature-des-données",
    "href": "doc/cours/dataviz.html#choix-du-type-de-graphique-selon-la-nature-des-données",
    "title": "Visualisation des Données avec Matplotlib et Seaborn",
    "section": "",
    "text": "Type de Graphique\nType de Données\nUtilisation principale\n\n\n\n\nCourbe linéaire\nVariable continue\nSuivi d’une tendance\n\n\nHistogramme\nVariable numérique continue\nDistribution d’une variable\n\n\nDiagramme en barres\nVariable catégorielle\nComparaison entre différentes catégories\n\n\nNuage de points\nDeux variables numériques\nRelation entre deux variables\n\n\nBoxplot\nVariable numérique / catégorielle\nComparaison de distributions\n\n\nViolin plot\nVariable numérique / catégorielle\nVisualisation de la distribution\n\n\nHeatmap\nMatrice de valeurs numériques\nCorrélation entre variables\n\n\nPie chart (camembert)\nVariables catégoriques\nRépartition proportionnelle"
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#programmation-avec-python-bases-et-applications",
    "href": "doc/cours/intro-python-slides.html#programmation-avec-python-bases-et-applications",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Programmation avec Python : Bases et Applications",
    "text": "Programmation avec Python : Bases et Applications\n\n18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#objectifs",
    "href": "doc/cours/intro-python-slides.html#objectifs",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Objectifs",
    "text": "Objectifs\n\nComprendre les bases du langage Python.\nManipuler les variables, types de données et structures de contrôle.\nExplorer les bibliothèques populaires : NumPy, Pandas, Matplotlib.\nIntroduire les concepts de machine learning avec Scikit-learn.\nRéaliser un projet intégrant toutes les notions vues."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#python",
    "href": "doc/cours/intro-python-slides.html#python",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Python",
    "text": "Python\n\nLangage polyvalent : data science, machine learning, développement web, automatisation.\nAvantages :\n\nSyntaxe simple et claire.\nLarge écosystème de bibliothèques open source.\nUtilisé par des entreprises, start-ups, et dans la recherche académique."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#organisation-des-tp",
    "href": "doc/cours/intro-python-slides.html#organisation-des-tp",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Organisation des TP",
    "text": "Organisation des TP\n\n5 TP + 1 projet final\nEnvironnements : VS Code, Jupyter Notebook, Google Colab.\nApproche : Alternance entre exercices guidés et explorations libres.\nLes projets doivent suivre une structuration rigoureuse :\n\nNettoyage des données.\nVisualisation.\nAnalyse et modélisation."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#ce-quil-faut-faire",
    "href": "doc/cours/intro-python-slides.html#ce-quil-faut-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Ce qu’il faut faire",
    "text": "Ce qu’il faut faire\n\nLisez attentivement les consignes de chaque TP.\nEssayez de résoudre les exercices par vous-même.\nRecherchez dans les cours et tutoriels en ligne.\nTravaillez en binôme pour échanger des idées.\nPosez des questions à l’enseignante en cas de blocage."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#à-ne-pas-faire",
    "href": "doc/cours/intro-python-slides.html#à-ne-pas-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "À ne pas faire",
    "text": "À ne pas faire\n\nUtiliser ChatGPT sans comprendre la solution.\nCopier/coller des réponses sans vérifier leur validité.\nNe pas documenter votre code ou vos démarches.\n\n\nNote : Ces pratiques nuisent à l’apprentissage et à la compréhension."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#évaluation",
    "href": "doc/cours/intro-python-slides.html#évaluation",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Évaluation",
    "text": "Évaluation\n\nPartie 1 : Projet à faire à la maison.\n\nSujet distribué une semaine avant la date de l’examen.\nAnalyse et exploration d’un dataset fourni.\nÀ rendre sous forme d’un notebook bien structuré :\n\nExplication des étapes de nettoyage.\nVisualisation des données et interprétation.\nConclusions et recommandations."
  },
  {
    "objectID": "doc/cours/intro-python-slides.html#bibliographie",
    "href": "doc/cours/intro-python-slides.html#bibliographie",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Bibliographie",
    "text": "Bibliographie\n\nDocumentation officielle Python\n[Cours excellent de l’ENSAE] (https://pythonds.linogaliana.fr/)\nPython for Everybody\nPython Crash Course (Livre)\nSite\nMémento Bases Python 3 de Laurent POINTAL, 2012-2013\nAbrégé Dense Python 3.2 de Laurent POINTAL, 2012"
  },
  {
    "objectID": "doc/cours/intro.html",
    "href": "doc/cours/intro.html",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "",
    "text": "18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro.html#programmation-avec-python-bases-et-applications",
    "href": "doc/cours/intro.html#programmation-avec-python-bases-et-applications",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "",
    "text": "18h : CM+TP\nContact : natachayepnga@gmail.com\nOutils recommandés : VS Code, Jupyter Notebook"
  },
  {
    "objectID": "doc/cours/intro.html#objectifs",
    "href": "doc/cours/intro.html#objectifs",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Objectifs",
    "text": "Objectifs\n\nComprendre les bases du langage Python.\nManipuler les variables, types de données et structures de contrôle.\nExplorer les bibliothèques populaires : NumPy, Pandas, Matplotlib.\nIntroduire les concepts de machine learning avec Scikit-learn.\nRéaliser un projet intégrant toutes les notions vues."
  },
  {
    "objectID": "doc/cours/intro.html#python",
    "href": "doc/cours/intro.html#python",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Python",
    "text": "Python\n\nLangage polyvalent : data science, machine learning, développement web, automatisation.\nAvantages :\n\nSyntaxe simple et claire.\nLarge écosystème de bibliothèques open source.\nUtilisé par des entreprises, start-ups, et dans la recherche académique."
  },
  {
    "objectID": "doc/cours/intro.html#organisation-des-tp",
    "href": "doc/cours/intro.html#organisation-des-tp",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Organisation des TP",
    "text": "Organisation des TP\n\n5 TP + 1 projet final\nEnvironnements : VS Code, Jupyter Notebook, Google Colab.\nApproche : Alternance entre exercices guidés et explorations libres.\nLes projets doivent suivre une structuration rigoureuse :\n\nNettoyage des données.\nVisualisation.\nAnalyse et modélisation."
  },
  {
    "objectID": "doc/cours/intro.html#ce-quil-faut-faire",
    "href": "doc/cours/intro.html#ce-quil-faut-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Ce qu’il faut faire",
    "text": "Ce qu’il faut faire\n\nLisez attentivement les consignes de chaque TP.\nEssayez de résoudre les exercices par vous-même.\nRecherchez dans les cours et tutoriels en ligne.\nTravaillez en binôme pour échanger des idées.\nPosez des questions à l’enseignante en cas de blocage."
  },
  {
    "objectID": "doc/cours/intro.html#à-ne-pas-faire",
    "href": "doc/cours/intro.html#à-ne-pas-faire",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "À ne pas faire",
    "text": "À ne pas faire\n\nUtiliser ChatGPT sans comprendre la solution.\nCopier/coller des réponses sans vérifier leur validité.\nNe pas documenter votre code ou vos démarches.\n\n\nNote : Ces pratiques nuisent à l’apprentissage et à la compréhension."
  },
  {
    "objectID": "doc/cours/intro.html#évaluation",
    "href": "doc/cours/intro.html#évaluation",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Évaluation",
    "text": "Évaluation\n\nPartie 1 : Projet à faire à la maison.\n\nSujet distribué une semaine avant la date de l’examen.\nAnalyse et exploration d’un dataset fourni.\nÀ rendre sous forme d’un notebook bien structuré :\n\nExplication des étapes de nettoyage.\nVisualisation des données et interprétation.\nConclusions et recommandations.\n\n\n\n\n\nPartie 2 : QCM.\n\nDurée : 2h.\nQuestions portant sur les concepts abordés pendant le cours et les TP.\nLa date sera définie à l’avance."
  },
  {
    "objectID": "doc/cours/intro.html#bibliographie",
    "href": "doc/cours/intro.html#bibliographie",
    "title": "Programmation avec Python : Bases et Applications",
    "section": "Bibliographie",
    "text": "Bibliographie\n\nDocumentation officielle Python\n[Cours excellent de l’ENSAE] (https://pythonds.linogaliana.fr/)\nPython for Everybody\nPython Crash Course (Livre)\nSite\nMémento Bases Python 3 de Laurent POINTAL, 2012-2013\nAbrégé Dense Python 3.2 de Laurent POINTAL, 2012\n\n\n\nA Quick, Painless Tutorial on the Python Language de Norman Matloff, 2008 (PDF)\nTutoriels Python en ligne\nDernière version de Python et interface IDLE\nOutil IEP (Interactive Editor for Python)\nThink Python - How to Think Like a Computer Scientist d’Allen B. Downey, 2014\nApprendre à programmer avec Python de Gérard Swinnen, 2009\n\n\n\nUne introduction à Python 3 de Robert CORDEAU et Laurent POINTAL, 2010\nCours Python de l’École Polytechnique Universitaire UMPC\nDocumentation sur l’intégration C/C++/Python\nPython Development with PyDev and Eclipse - Tutorial de Lars Vogel, 2011\nApprenez à programmer en Python - Site du Zéro - Vincent Le Goff, 2011\nAssociation francophone Python"
  },
  {
    "objectID": "doc/tp/tp4.html#récupération-et-exploration-des-données",
    "href": "doc/tp/tp4.html#récupération-et-exploration-des-données",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.1 1. Récupération et Exploration des Données",
    "text": "2.1 1. Récupération et Exploration des Données\n\n2.1.1 Téléchargement des données depuis Yahoo Finance\nNous allons utiliser la bibliothèque yfinance pour récupérer les prix historiques des actions de plusieurs entreprises technologiques.\nimport pandas as pd\nimport yfinance as yf\n\n# Liste des tickers des entreprises étudiées\ntickers = ['NVDA', 'AAPL', 'AMZN', 'MSFT']\n\n# Téléchargement des données de 2020 à 2024\ndf = yf.download(tickers, start='2020-01-01', end='2024-01-01', group_by='ticker')\n\n# Affichage des premières lignes du DataFrame\nprint(df.head())\n\n\n2.1.2 Analyse exploratoire\n📌 Questions à traiter :\n\nQuelles sont les colonnes disponibles dans le DataFrame ?\n\nQuel est le nombre total de lignes et de colonnes ?\n\nY a-t-il des valeurs manquantes ? Comment les gérer ?"
  },
  {
    "objectID": "doc/tp/tp4.html#nettoyage-et-préparation-des-données",
    "href": "doc/tp/tp4.html#nettoyage-et-préparation-des-données",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.2 2. Nettoyage et Préparation des Données",
    "text": "2.2 2. Nettoyage et Préparation des Données\n📌 Questions à traiter :\n\nSupprimez les lignes contenant des valeurs manquantes.\n\nDéfinissez la colonne Date comme index du DataFrame.\n\nVérifiez les types de données des colonnes et convertissez-les si nécessaire."
  },
  {
    "objectID": "doc/tp/tp4.html#analyse-des-tendances-du-marché",
    "href": "doc/tp/tp4.html#analyse-des-tendances-du-marché",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.3 3. Analyse des Tendances du Marché",
    "text": "2.3 3. Analyse des Tendances du Marché\n\n2.3.1 Calcul du rendement journalier\nLe rendement journalier d’une action est donné par la formule :\n[ R_t = ]\n📌 Questions à traiter :\n\nQuelle est la tendance des prix des actions pour chaque entreprise ?\n\nQuel jour chaque action a-t-elle atteint son plus haut prix ?\n\nCalculez le rendement quotidien de chaque action et affichez sa moyenne."
  },
  {
    "objectID": "doc/tp/tp4.html#comparaison-des-performances",
    "href": "doc/tp/tp4.html#comparaison-des-performances",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.4 4. Comparaison des Performances",
    "text": "2.4 4. Comparaison des Performances\n📌 Questions à traiter :\n\nQuelle entreprise a eu la meilleure croissance sur la période analysée ?\n\nQuel est le rendement moyen mensuel de chaque action ?\n\nComparez la volatilité des différentes actions."
  },
  {
    "objectID": "doc/tp/tp4.html#conclusion",
    "href": "doc/tp/tp4.html#conclusion",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.5 Conclusion",
    "text": "2.5 Conclusion\n\nQuelle entreprise a eu la meilleure croissance sur la période ?\n\nQuel titre a offert le rendement moyen le plus élevé ?\n\nQuelle action était la plus volatile, indiquant un risque plus élevé ?\n\nDiscussion sur les facteurs pouvant expliquer ces résultats (ex. crise, innovations, changements dans l’industrie)."
  },
  {
    "objectID": "doc/tp/tp4.html#résumé-des-principales-manipulations-avec-pandas",
    "href": "doc/tp/tp4.html#résumé-des-principales-manipulations-avec-pandas",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.6 Résumé des principales manipulations avec pandas",
    "text": "2.6 Résumé des principales manipulations avec pandas\n\n\n\n\n\n\n\nOpération\nCommande Pandas\n\n\n\n\nTélécharger des données financières\nyfinance.download()\n\n\nAfficher les colonnes disponibles\ndf.columns\n\n\nVérifier la présence de valeurs manquantes\ndf.isnull().sum()\n\n\nSupprimer les valeurs manquantes\ndf.dropna()\n\n\nDéfinir un index de type datetime\ndf.index = pd.to_datetime(df.index)\n\n\nCalculer le rendement journalier\n.pct_change()\n\n\nCalculer la volatilité\n.std()\n\n\nTrouver la date du prix maximum\n.idxmax()\n\n\nAgréger les données par mois\n.resample('M').mean()"
  },
  {
    "objectID": "doc/tp/tp4.html#partie-2-analyse-du-risque-de-défaut",
    "href": "doc/tp/tp4.html#partie-2-analyse-du-risque-de-défaut",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.7 Partie 2 : Analyse du Risque de Défaut",
    "text": "2.7 Partie 2 : Analyse du Risque de Défaut\nNous allons maintenant utiliser une base de données de crédit pour analyser les facteurs influençant le risque de défaut.\nLa base de données est disponible ici: https://www.kaggle.com/datasets/laotse/credit-risk-dataset?resource=download ### Description des Colonnes de la Base de Données\n\n\n\n\n\n\n\nNom de la Colonne\nDescription\n\n\n\n\nperson_age\nÂge\n\n\nperson_income\nRevenu annuel\n\n\nperson_home_ownership\nType de propriété\n\n\nperson_emp_length\nAncienneté professionnelle (années)\n\n\nloan_intent\nBut du prêt\n\n\nloan_grade\nGrade du prêt\n\n\nloan_amnt\nMontant du prêt\n\n\nloan_int_rate\nTaux d’intérêt\n\n\nloan_status\nStatut du prêt (0: non défaut, 1: défaut)\n\n\nloan_percent_income\nPourcentage du revenu\n\n\ncb_person_default_on_file\nHistorique de défaut\n\n\ncb_person_cred_hist_length\nLongueur de l’historique de crédit\n\n\n\n\n2.7.1 1. Chargement et Exploration des Données\ndf_credit = pd.read_csv('credit_risk_data.csv')\nprint(df_credit.head())\ndf_credit.info()\ndf_credit.describe()\n📌 Questions : 1. Quelles sont les variables disponibles pour l’analyse du risque de défaut ? 2. Quelle est la répartition des clients en défaut et non en défaut ? 3. Identifiez les valeurs manquantes et proposez une méthode de traitement.\n\n\n2.7.2 2. Nettoyage et Préparation des Données\n📌 Questions : 1. Convertissez les variables catégoriques en variables numériques. 2. Séparez le dataset en deux groupes : clients en défaut et non en défaut.\n\n\n2.7.3 3. Analyse des Facteurs de Risque\n📌 Questions : Dans cette section, nous allons explorer les facteurs influençant le risque de défaut en manipulant pandas et en réalisant des analyses numériques."
  },
  {
    "objectID": "doc/tp/tp4.html#objectifs",
    "href": "doc/tp/tp4.html#objectifs",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.8 Objectifs",
    "text": "2.8 Objectifs\n\nManipuler des DataFrames pandas pour explorer les relations entre les variables.\n\nUtiliser des statistiques descriptives et des mesures de corrélation.\n\nComprendre comment les facteurs influencent le risque de défaut et interpréter les résultats."
  },
  {
    "objectID": "doc/tp/tp4.html#questions-et-analyses",
    "href": "doc/tp/tp4.html#questions-et-analyses",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.9 Questions et Analyses",
    "text": "2.9 Questions et Analyses\n\n2.9.1 1. Impact du revenu annuel sur le risque de défaut\nAnalyse numérique\n- Afficher les statistiques descriptives du revenu annuel en fonction du statut de défaut.\n- Comparer les moyennes et médianes des revenus des clients en défaut et non en défaut.\n- Calculer l’écart-type et la variance du revenu annuel pour chaque groupe.\nÉtapes\n1. Charger les données dans un DataFrame pandas.\n2. Utiliser .describe() pour obtenir des statistiques globales sur le revenu annuel.\n3. Utiliser .groupby('Défaut') et .agg(['mean', 'median', 'std', 'var']) pour comparer les groupes.\n4. Interpréter les résultats et voir si une tendance se dégage.\n\n\n\n2.9.2 2. Influence de l’historique des paiements sur le risque de défaut\nAnalyse numérique\n- Calculer le nombre moyen de paiements en retard pour chaque statut de défaut.\n- Analyser la médiane et l’écart-type du nombre de paiements en retard.\n- Déterminer si les clients en défaut ont un historique de paiements significativement différent des autres.\nÉtapes\n1. Utiliser .groupby('Défaut')['Nb_Paiements_Retard'].agg(['mean', 'median', 'std']).\n2. Comparer les valeurs moyennes et médianes pour identifier les différences entre les groupes.\n3. Vérifier si la dispersion des retards de paiement est plus élevée chez les clients en défaut.\n\n\n\n2.9.3 3. Identification des facteurs les plus corrélés au risque de défaut\nAnalyse numérique\n- Calculer la matrice de corrélation entre les variables.\n- Identifier les trois facteurs les plus corrélés avec le risque de défaut.\n- Vérifier si ces corrélations sont significatives.\nÉtapes\n1. Utiliser .corr() pour calculer la matrice de corrélation du DataFrame.\n2. Extraire les valeurs de corrélation associées à la colonne “Défaut”.\n3. Trier ces valeurs par ordre décroissant et sélectionner les trois variables les plus influentes.\n4. Interpréter les résultats et vérifier si ces facteurs sont cohérents avec les analyses précédentes.\n\n\n2.9.4 Synthèse\nDans cette section, nous allons approfondir l’étude des facteurs influençant le risque de défaut en réalisant des analyses numériques sur la répartition des âges et l’impact du statut d’emploi."
  },
  {
    "objectID": "doc/tp/tp4.html#objectifs-1",
    "href": "doc/tp/tp4.html#objectifs-1",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.10 Objectifs",
    "text": "2.10 Objectifs\n\nAnalyser la distribution des âges des clients à l’aide de statistiques descriptives.\n\nExaminer l’influence du statut d’emploi sur le risque de défaut à travers des mesures numériques.\n\nSynthétiser les résultats obtenus et proposer des interprétations."
  },
  {
    "objectID": "doc/tp/tp4.html#questions-et-analyses-1",
    "href": "doc/tp/tp4.html#questions-et-analyses-1",
    "title": "TP Analyse de Données avec Pandas",
    "section": "2.11 Questions et Analyses",
    "text": "2.11 Questions et Analyses\n\n2.11.1 Analyse de la distribution des âges des clients\nAnalyse numérique\n- Calculer les statistiques descriptives générales sur l’âge des clients.\n- Identifier l’âge moyen, la médiane, l’écart-type et les valeurs minimales/maximales.\n- Déterminer s’il y a des valeurs aberrantes en comparant l’écart interquartile.\nÉtapes\n1. Utiliser .describe() sur la colonne Âge pour obtenir les principales statistiques.\n2. Vérifier les bornes des quartiles avec .quantile([0.25, 0.5, 0.75]).\n3. Déterminer les valeurs aberrantes potentielles en utilisant la règle des 1,5 IQR (Interquartile Range).\n4. Comparer ces statistiques avec celles d’autres variables pour voir si certaines tranches d’âge sont plus représentées parmi les clients en défaut.\n\n\n\n2.11.2 Influence du statut d’emploi sur le risque de défaut\nAnalyse numérique\n- Compter le nombre de clients par catégorie de statut d’emploi.\n- Calculer la proportion de clients en défaut dans chaque catégorie de statut d’emploi.\n- Identifier si certaines catégories ont un taux de défaut significativement plus élevé.\nÉtapes\n1. Utiliser .value_counts() sur la colonne Statut_Emploi pour connaître la répartition des clients par catégorie.\n2. Grouper les données par Statut_Emploi et calculer le taux de défaut dans chaque groupe avec .groupby('Statut_Emploi')['Défaut'].mean().\n3. Comparer ces taux et identifier les catégories ayant une probabilité plus élevée de défaut.\n4. Interpréter les résultats en lien avec les analyses précédentes (ex. une catégorie d’emploi avec des revenus plus faibles pourrait avoir un taux de défaut plus élevé)."
  },
  {
    "objectID": "doc/tp/tp3.html",
    "href": "doc/tp/tp3.html",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "Comprendre l’utilisation du module NumPy pour le calcul scientifique.\nCréer et manipuler des tableaux multidimensionnels.\nAppliquer des opérations mathématiques et statistiques sur des données.\nExplorer les masques booléens pour des filtrages avancés.\n\nVous pouvez télécharger le fichier .ipynb en cliquant ici\n\n\n\nNumPy (Numerical Python) est une bibliothèque puissante pour manipuler des tableaux et effectuer des calculs scientifiques. Elle est optimisée pour la performance et largement utilisée dans l’analyse de données.\n\n\n\nPerformance : Calculs rapides grâce à une implémentation en C.\nSimplicité : Manipulation intuitive des tableaux multidimensionnels.\nRichesse fonctionnelle : Nombreuses fonctions mathématiques, algébriques, et statistiques.\n\n\n\n\n\nimport numpy as np\n\n# Tableau 1D\nA = np.array([1, 2, 3])\n\n# Tableau 2D\nB = np.array([[1, 2], [3, 4]])\nprint(A)\nprint(B)\n\n# Zéros et Uns\nzeros = np.zeros((3, 3))\nones = np.ones((2, 4))\nprint(zeros)\nprint(ones)\n\n# Valeurs aléatoires\nrandom = np.random.random((3, 3))\nprint(random)\n\n# Plages de valeurs\narange = np.arange(0, 10, 2)\nlinspace = np.linspace(0, 1, 5)\nprint(arange)\nprint(linspace)\n\n# Informations sur un tableau\nprint(B.shape)  # Dimensions\nprint(B.size)   # Nombre d'éléments\nprint(B.dtype)  # Type des éléments\n\n\n\n# Accéder aux éléments\nprint(B[0, 1])\nprint(B[:, 1])\nprint(B[1, :])\n\n# Modifier des éléments\nB[0, 0] = 100\nprint(B)\n\n# Ajouter des éléments\nA = np.append(A, [4, 5])\nprint(A)\n\n# Supprimer des éléments\nC = np.delete(A, [0, 1])\nprint(C)\n\n\n\n# Opérations arithmétiques\nD = B + 10\nprint(D)\n\nE = B * 2\nprint(E)\n\n# Statistiques\nprint(np.sum(B))\nprint(np.mean(B))\nprint(np.std(B))\n\n# Masques booléens\nmask = B &gt; 2\nprint(mask)\nprint(B[mask])\n\n# Modification conditionnelle\nB[B &gt; 2] = -1\nprint(B)\n\n\n\n\n\n\nCréez un tableau 3x3 contenant des valeurs aléatoires entre 0 et 1.\nRemplacez les valeurs inférieures à 0.5 par 0.\nCalculez la somme et la moyenne des éléments du tableau.\n\n\n\n\n\nCréez un tableau 1D de 10 éléments entre 1 et 100.\nSupprimez les trois derniers éléments et ajoutez deux nouveaux.\nRemplacez les valeurs paires par -1.\n\n\n\n\n\nCréez une matrice 4x4 contenant des valeurs aléatoires entre -10 et 10.\nUtilisez un masque pour remplacer les valeurs négatives par leur valeur absolue.\nCalculez la moyenne des valeurs finales.\n\n\n\n\n\n\nNumPy permet de manipuler efficacement des tableaux pour des calculs rapides.\nLes masques booléens offrent des possibilités puissantes pour le filtrage et la modification des données.\nL’utilisation des opérations vectorisées améliore grandement les performances.\n\n\n\n\nDocumentation officielle NumPy"
  },
  {
    "objectID": "doc/tp/tp3.html#objectifs-du-tp",
    "href": "doc/tp/tp3.html#objectifs-du-tp",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "Comprendre l’utilisation du module NumPy pour le calcul scientifique.\nCréer et manipuler des tableaux multidimensionnels.\nAppliquer des opérations mathématiques et statistiques sur des données.\nExplorer les masques booléens pour des filtrages avancés.\n\nVous pouvez télécharger le fichier .ipynb en cliquant ici"
  },
  {
    "objectID": "doc/tp/tp3.html#introduction-à-numpy",
    "href": "doc/tp/tp3.html#introduction-à-numpy",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "NumPy (Numerical Python) est une bibliothèque puissante pour manipuler des tableaux et effectuer des calculs scientifiques. Elle est optimisée pour la performance et largement utilisée dans l’analyse de données.\n\n\n\nPerformance : Calculs rapides grâce à une implémentation en C.\nSimplicité : Manipulation intuitive des tableaux multidimensionnels.\nRichesse fonctionnelle : Nombreuses fonctions mathématiques, algébriques, et statistiques."
  },
  {
    "objectID": "doc/tp/tp3.html#création-de-tableaux",
    "href": "doc/tp/tp3.html#création-de-tableaux",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "import numpy as np\n\n# Tableau 1D\nA = np.array([1, 2, 3])\n\n# Tableau 2D\nB = np.array([[1, 2], [3, 4]])\nprint(A)\nprint(B)\n\n# Zéros et Uns\nzeros = np.zeros((3, 3))\nones = np.ones((2, 4))\nprint(zeros)\nprint(ones)\n\n# Valeurs aléatoires\nrandom = np.random.random((3, 3))\nprint(random)\n\n# Plages de valeurs\narange = np.arange(0, 10, 2)\nlinspace = np.linspace(0, 1, 5)\nprint(arange)\nprint(linspace)\n\n# Informations sur un tableau\nprint(B.shape)  # Dimensions\nprint(B.size)   # Nombre d'éléments\nprint(B.dtype)  # Type des éléments"
  },
  {
    "objectID": "doc/tp/tp3.html#accès-et-modifications",
    "href": "doc/tp/tp3.html#accès-et-modifications",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "# Accéder aux éléments\nprint(B[0, 1])\nprint(B[:, 1])\nprint(B[1, :])\n\n# Modifier des éléments\nB[0, 0] = 100\nprint(B)\n\n# Ajouter des éléments\nA = np.append(A, [4, 5])\nprint(A)\n\n# Supprimer des éléments\nC = np.delete(A, [0, 1])\nprint(C)"
  },
  {
    "objectID": "doc/tp/tp3.html#opérations-mathématiques-et-statistiques",
    "href": "doc/tp/tp3.html#opérations-mathématiques-et-statistiques",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "# Opérations arithmétiques\nD = B + 10\nprint(D)\n\nE = B * 2\nprint(E)\n\n# Statistiques\nprint(np.sum(B))\nprint(np.mean(B))\nprint(np.std(B))\n\n# Masques booléens\nmask = B &gt; 2\nprint(mask)\nprint(B[mask])\n\n# Modification conditionnelle\nB[B &gt; 2] = -1\nprint(B)"
  },
  {
    "objectID": "doc/tp/tp3.html#exercices-pratiques",
    "href": "doc/tp/tp3.html#exercices-pratiques",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "Créez un tableau 3x3 contenant des valeurs aléatoires entre 0 et 1.\nRemplacez les valeurs inférieures à 0.5 par 0.\nCalculez la somme et la moyenne des éléments du tableau.\n\n\n\n\n\nCréez un tableau 1D de 10 éléments entre 1 et 100.\nSupprimez les trois derniers éléments et ajoutez deux nouveaux.\nRemplacez les valeurs paires par -1.\n\n\n\n\n\nCréez une matrice 4x4 contenant des valeurs aléatoires entre -10 et 10.\nUtilisez un masque pour remplacer les valeurs négatives par leur valeur absolue.\nCalculez la moyenne des valeurs finales."
  },
  {
    "objectID": "doc/tp/tp3.html#récapitulatif",
    "href": "doc/tp/tp3.html#récapitulatif",
    "title": "Manipulation de données avec Numpy",
    "section": "",
    "text": "NumPy permet de manipuler efficacement des tableaux pour des calculs rapides.\nLes masques booléens offrent des possibilités puissantes pour le filtrage et la modification des données.\nL’utilisation des opérations vectorisées améliore grandement les performances.\n\n\n\n\nDocumentation officielle NumPy"
  }
]